<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BinTV Web - Binary Structure Viewer (Focused Edition)</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap');
        
        body {
            margin: 0;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            background: #0d1117;
            color: #c9d1d9;
            overflow: hidden;
        }
        
        .terminal-border {
            border: 1px solid #30363d;
            box-shadow: 0 0 10px rgba(48, 54, 61, 0.3);
        }
        
        .terminal-glow {
            text-shadow: 0 0 2px rgba(88, 166, 255, 0.3);
        }
        
        .hex-cell {
            display: inline-block;
            padding: 2px 4px;
            margin: 0;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #8b949e;
            background: rgba(110, 118, 129, 0.05);
            font-size: 14px;
            position: relative;
        }
        
        .hex-cell:hover {
            background: rgba(88, 166, 255, 0.2);
            color: #58a6ff;
        }
        
        .hex-offset {
            color: #58a6ff;
            font-weight: 600;
            user-select: none;
            display: inline-block;
            width: 100px;
            font-size: 14px;
        }
        
        .ascii-char {
            display: inline-block;
            width: 1ch;
            text-align: center;
            color: #8b949e;
            opacity: 0.8;
            padding: 2px 1px;
            font-size: 14px;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .field-highlight-0 { 
            background: rgba(248, 81, 73, 0.4); 
            box-shadow: 0 0 8px rgba(248, 81, 73, 0.6), inset 0 0 4px rgba(248, 81, 73, 0.3);
            color: #ff9b97 !important;
        }
        .field-highlight-0.hovered {
            background: rgba(248, 81, 73, 0.7) !important;
            box-shadow: 0 0 16px rgba(248, 81, 73, 1), inset 0 0 8px rgba(248, 81, 73, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-1 { 
            background: rgba(246, 173, 85, 0.4); 
            box-shadow: 0 0 8px rgba(246, 173, 85, 0.6), inset 0 0 4px rgba(246, 173, 85, 0.3);
            color: #ffc98e !important;
        }
        .field-highlight-1.hovered {
            background: rgba(246, 173, 85, 0.7) !important;
            box-shadow: 0 0 16px rgba(246, 173, 85, 1), inset 0 0 8px rgba(246, 173, 85, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-2 { 
            background: rgba(87, 171, 90, 0.4); 
            box-shadow: 0 0 8px rgba(87, 171, 90, 0.6), inset 0 0 4px rgba(87, 171, 90, 0.3);
            color: #a0e3a3 !important;
        }
        .field-highlight-2.hovered {
            background: rgba(87, 171, 90, 0.7) !important;
            box-shadow: 0 0 16px rgba(87, 171, 90, 1), inset 0 0 8px rgba(87, 171, 90, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-3 { 
            background: rgba(88, 166, 255, 0.4); 
            box-shadow: 0 0 8px rgba(88, 166, 255, 0.6), inset 0 0 4px rgba(88, 166, 255, 0.3);
            color: #a8d4ff !important;
        }
        .field-highlight-3.hovered {
            background: rgba(88, 166, 255, 0.7) !important;
            box-shadow: 0 0 16px rgba(88, 166, 255, 1), inset 0 0 8px rgba(88, 166, 255, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-4 { 
            background: rgba(188, 128, 240, 0.4); 
            box-shadow: 0 0 8px rgba(188, 128, 240, 0.6), inset 0 0 4px rgba(188, 128, 240, 0.3);
            color: #d4b3ff !important;
        }
        .field-highlight-4.hovered {
            background: rgba(188, 128, 240, 0.7) !important;
            box-shadow: 0 0 16px rgba(188, 128, 240, 1), inset 0 0 8px rgba(188, 128, 240, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-5 { 
            background: rgba(255, 121, 198, 0.4); 
            box-shadow: 0 0 8px rgba(255, 121, 198, 0.6), inset 0 0 4px rgba(255, 121, 198, 0.3);
            color: #ffa3d9 !important;
        }
        .field-highlight-5.hovered {
            background: rgba(255, 121, 198, 0.7) !important;
            box-shadow: 0 0 16px rgba(255, 121, 198, 1), inset 0 0 8px rgba(255, 121, 198, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-6 { 
            background: rgba(121, 192, 255, 0.4); 
            box-shadow: 0 0 8px rgba(121, 192, 255, 0.6), inset 0 0 4px rgba(121, 192, 255, 0.3);
            color: #b3d9ff !important;
        }
        .field-highlight-6.hovered {
            background: rgba(121, 192, 255, 0.7) !important;
            box-shadow: 0 0 16px rgba(121, 192, 255, 1), inset 0 0 8px rgba(121, 192, 255, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-7 { 
            background: rgba(255, 158, 100, 0.4); 
            box-shadow: 0 0 8px rgba(255, 158, 100, 0.6), inset 0 0 4px rgba(255, 158, 100, 0.3);
            color: #ffb380 !important;
        }
        .field-highlight-7.hovered {
            background: rgba(255, 158, 100, 0.7) !important;
            box-shadow: 0 0 16px rgba(255, 158, 100, 1), inset 0 0 8px rgba(255, 158, 100, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        
        .tree-node {
            cursor: pointer;
            padding: 4px 6px;
            margin: 2px 0;
            transition: all 0.15s;
            user-select: none;
            border-left: 2px solid transparent;
            color: #c9d1d9;
            font-size: 13px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }
        
        .tree-node:hover {
            background: rgba(88, 166, 255, 0.1);
            border-left: 2px solid #58a6ff;
        }
        
        .tree-node:hover .edit-btn {
            opacity: 1;
        }
        
        .tree-node.selected {
            background: rgba(88, 166, 255, 0.15);
            border-left: 2px solid #58a6ff;
        }

        .tree-node.expandable::before {
            content: '‚ñ∂';
            display: inline-block;
            margin-right: 4px;
            transition: transform 0.2s;
            color: #58a6ff;
        }

        .tree-node.expandable.expanded::before {
            transform: rotate(90deg);
        }
        
        .edit-btn {
            opacity: 0;
            transition: opacity 0.2s;
            padding: 2px 6px;
            font-size: 11px;
            background: #21262d;
            border: 1px solid #30363d;
            color: #58a6ff;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .edit-btn:hover {
            background: #30363d;
            border-color: #58a6ff;
        }
        
        .export-menu {
            position: absolute;
            right: 0;
            top: 100%;
            margin-top: 4px;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 4px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            min-width: 180px;
        }
        
        .export-menu button {
            display: block;
            width: 100%;
            padding: 8px 12px;
            text-align: left;
            background: transparent;
            border: none;
            color: #c9d1d9;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .export-menu button:hover {
            background: #21262d;
            color: #58a6ff;
        }
        
        .export-menu button:first-child {
            border-radius: 4px 4px 0 0;
        }
        
        .export-menu button:last-child {
            border-radius: 0 0 4px 4px;
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }
        
        .modal-content {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 20px;
            min-width: 400px;
            max-width: 600px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .modal-input {
            width: 100%;
            padding: 8px 12px;
            background: #0d1117;
            border: 1px solid #30363d;
            color: #c9d1d9;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }
        
        .modal-input:focus {
            outline: none;
            border-color: #58a6ff;
            box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.1);
        }
        
        input[type="file"] {
            display: none;
        }
        
        .scrollbar-thin::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .scrollbar-thin::-webkit-scrollbar-track {
            background: rgba(110, 118, 129, 0.1);
        }
        
        .scrollbar-thin::-webkit-scrollbar-thumb {
            background: rgba(88, 166, 255, 0.3);
            border-radius: 3px;
        }
        
        .scrollbar-thin::-webkit-scrollbar-thumb:hover {
            background: rgba(88, 166, 255, 0.5);
        }

        .code-editor {
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            background: #0d1117;
            color: #c9d1d9;
            border: 1px solid #30363d;
            font-size: 13px;
        }
        
        /* Syntax highlighting for code editor */
        .code-editor-highlighted {
            position: relative;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .code-editor-textarea {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: transparent;
            color: transparent;
            caret-color: #c9d1d9;
            resize: none;
            border: none;
            outline: none;
            padding: 12px;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
            overflow-y: auto;
            z-index: 2;
        }
        
        .code-editor-textarea::selection {
            background: rgba(88, 166, 255, 0.3);
        }
        
        .code-editor-display {
            pointer-events: none;
            white-space: pre;
            overflow-wrap: normal;
            word-break: normal;
            z-index: 1;
            color: #c9d1d9;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .code-editor-display > div {
            padding: 12px;
        }
        
        /* Python syntax highlighting colors (GitHub Dark theme) */
        .token-comment { color: #8b949e; font-style: italic; }
        .token-keyword { color: #ff7b72; font-weight: 600; }
        .token-string { color: #a5d6ff; }
        .token-number { color: #79c0ff; }
        .token-function { color: #d2a8ff; }
        .token-class { color: #ffa657; }
        .token-operator { color: #ff7b72; }
        .token-builtin { color: #79c0ff; }
        .token-variable { color: #ffa657; }

        .btn-terminal {
            background: #21262d;
            border: 1px solid #30363d;
            color: #58a6ff;
            transition: all 0.2s;
            font-weight: 500;
            font-size: 13px;
        }

        .btn-terminal:hover:not(:disabled) {
            background: #30363d;
            border-color: #58a6ff;
        }

        .btn-terminal:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .hex-line {
            display: flex;
            align-items: center;
            margin: 0;
            padding: 2px 0;
            transition: background 0.1s;
            white-space: nowrap;
        }

        .hex-line:hover {
            background: rgba(110, 118, 129, 0.05);
        }

        .loading-spinner {
            border: 2px solid rgba(88, 166, 255, 0.2);
            border-top: 2px solid #58a6ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-box {
            background: rgba(248, 81, 73, 0.1);
            border: 1px solid rgba(248, 81, 73, 0.3);
            box-shadow: 0 0 5px rgba(248, 81, 73, 0.1);
            padding: 8px;
            margin: 8px 0;
            color: #ff7b72;
            font-size: 12px;
        }

        .tree-children {
            margin-left: 15px;
            border-left: 1px solid rgba(88, 166, 255, 0.2);
            padding-left: 8px;
        }
        
        .terminal-title {
            background: #161b22;
            border-bottom: 1px solid #30363d;
            padding: 10px;
            color: #58a6ff;
            font-weight: 600;
            font-size: 13px;
        }
        
        .blink {
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .panel {
            background: #0d1117;
            border: 1px solid #30363d;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script>
        // Construct Library - Focused, Dynamic Templates
        const CONSTRUCT_LIBRARY = {
            // ===== NETWORK - Full Stack Protocols =====
            
            "full_tcp": {
                name: "Full TCP Packet (Eth+IP+TCP)",
                description: "Complete TCP packet: Ethernet + IPv4 + TCP headers",
                category: "Network",
                code: `# Full TCP Packet (Ethernet + IPv4 + TCP Headers)
format_struct = Struct(
    # Ethernet Layer
    "ethernet" / Struct(
        "dst_mac" / Bytes(6),
        "src_mac" / Bytes(6),
        "ethertype" / Int16ub,
    ),
    # IPv4 Layer (no options for simplicity, use IHL=5)
    "ipv4" / Struct(
        "version_ihl" / Int8ub,
        "dscp_ecn" / Int8ub,
        "total_length" / Int16ub,
        "identification" / Int16ub,
        "flags_fragment" / Int16ub,
        "ttl" / Int8ub,
        "protocol" / Int8ub,
        "checksum" / Int16ub,
        "src_ip" / Bytes(4),
        "dst_ip" / Bytes(4),
    ),
    # TCP Layer (no options for simplicity)
    "tcp" / Struct(
        "src_port" / Int16ub,
        "dst_port" / Int16ub,
        "seq_num" / Int32ub,
        "ack_num" / Int32ub,
        "data_offset_flags" / Int16ub,
        "window_size" / Int16ub,
        "checksum" / Int16ub,
        "urgent_pointer" / Int16ub,
    ),
    # Payload follows
)`
            },
            
            "full_udp": {
                name: "Full UDP Packet (Eth+IP+UDP)",
                description: "Complete UDP packet: Ethernet + IPv4 + UDP with payload",
                category: "Network",
                code: `# Full UDP Packet with Dynamic Payload
format_struct = Struct(
    # Ethernet Layer
    "ethernet" / Struct(
        "dst_mac" / Bytes(6),
        "src_mac" / Bytes(6),
        "ethertype" / Int16ub,
    ),
    # IPv4 Layer
    "ipv4" / Struct(
        "version_ihl" / Int8ub,
        "dscp_ecn" / Int8ub,
        "total_length" / Int16ub,
        "identification" / Int16ub,
        "flags_fragment" / Int16ub,
        "ttl" / Int8ub,
        "protocol" / Int8ub,
        "checksum" / Int16ub,
        "src_ip" / Bytes(4),
        "dst_ip" / Bytes(4),
    ),
    # UDP Layer
    "udp" / Struct(
        "src_port" / Int16ub,
        "dst_port" / Int16ub,
        "length" / Int16ub,
        "checksum" / Int16ub,
        "payload" / Bytes(this.length.value - 8),
    ),
)`
            },
            
            "full_dns": {
                name: "Full DNS Packet (Eth+IP+UDP+DNS)",
                description: "Complete DNS query/response with header",
                category: "Network",
                code: `# Full DNS Packet
format_struct = Struct(
    # Ethernet Layer
    "ethernet" / Struct(
        "dst_mac" / Bytes(6),
        "src_mac" / Bytes(6),
        "ethertype" / Int16ub,
    ),
    # IPv4 Layer
    "ipv4" / Struct(
        "version_ihl" / Int8ub,
        "dscp_ecn" / Int8ub,
        "total_length" / Int16ub,
        "identification" / Int16ub,
        "flags_fragment" / Int16ub,
        "ttl" / Int8ub,
        "protocol" / Int8ub,
        "checksum" / Int16ub,
        "src_ip" / Bytes(4),
        "dst_ip" / Bytes(4),
    ),
    # UDP Layer
    "udp" / Struct(
        "src_port" / Int16ub,
        "dst_port" / Int16ub,
        "length" / Int16ub,
        "checksum" / Int16ub,
    ),
    # DNS Layer
    "dns" / Struct(
        "transaction_id" / Int16ub,
        "flags" / Int16ub,
        "questions" / Int16ub,
        "answer_rrs" / Int16ub,
        "authority_rrs" / Int16ub,
        "additional_rrs" / Int16ub,
        # Questions/Answers follow (variable length DNS names)
    ),
)`
            },
            
            "full_dhcp": {
                name: "Full DHCP Packet (Eth+IP+UDP+DHCP)",
                description: "Complete DHCP message with dynamic hardware address",
                category: "Network",
                code: `# Full DHCP Packet
format_struct = Struct(
    # Ethernet Layer
    "ethernet" / Struct(
        "dst_mac" / Bytes(6),
        "src_mac" / Bytes(6),
        "ethertype" / Int16ub,
    ),
    # IPv4 Layer
    "ipv4" / Struct(
        "version_ihl" / Int8ub,
        "dscp_ecn" / Int8ub,
        "total_length" / Int16ub,
        "identification" / Int16ub,
        "flags_fragment" / Int16ub,
        "ttl" / Int8ub,
        "protocol" / Int8ub,
        "checksum" / Int16ub,
        "src_ip" / Bytes(4),
        "dst_ip" / Bytes(4),
    ),
    # UDP Layer
    "udp" / Struct(
        "src_port" / Int16ub,
        "dst_port" / Int16ub,
        "length" / Int16ub,
        "checksum" / Int16ub,
    ),
    # DHCP Layer
    "dhcp" / Struct(
        "op" / Int8ub,
        "htype" / Int8ub,
        "hlen" / Int8ub,
        "hops" / Int8ub,
        "xid" / Int32ub,
        "secs" / Int16ub,
        "flags" / Int16ub,
        "ciaddr" / Bytes(4),
        "yiaddr" / Bytes(4),
        "siaddr" / Bytes(4),
        "giaddr" / Bytes(4),
        "chaddr" / Bytes(this.hlen.value),
        "chaddr_padding" / Bytes(16 - this.hlen.value),
        "sname" / Bytes(64),
        "file" / Bytes(128),
        "magic_cookie" / Bytes(4),
        # DHCP options follow (TLV: type-length-value)
    ),
)`
            },
            
            "full_arp": {
                name: "Full ARP Packet (Eth+ARP)",
                description: "Complete ARP request/reply with dynamic addresses",
                category: "Network",
                code: `# Full ARP Packet
format_struct = Struct(
    # Ethernet Layer
    "ethernet" / Struct(
        "dst_mac" / Bytes(6),
        "src_mac" / Bytes(6),
        "ethertype" / Int16ub,
    ),
    # ARP Layer
    "arp" / Struct(
        "htype" / Int16ub,
        "ptype" / Int16ub,
        "hlen" / Int8ub,
        "plen" / Int8ub,
        "operation" / Int16ub,
        "sender_mac" / Bytes(this.hlen.value),
        "sender_ip" / Bytes(this.plen.value),
        "target_mac" / Bytes(this.hlen.value),
        "target_ip" / Bytes(this.plen.value),
    ),
)`
            },
            
            // ===== FILES - Executables & Archives =====
            
            "elf": {
                name: "ELF Header (64-bit)",
                description: "ELF executable/library header with program headers",
                category: "Files",
                code: `# ELF 64-bit Header
format_struct = Struct(
    "magic" / Bytes(4),
    "class" / Int8ub,
    "endian" / Int8ub,
    "version" / Int8ub,
    "osabi" / Int8ub,
    "abiversion" / Int8ub,
    "padding" / Bytes(7),
    "type" / Int16ul,
    "machine" / Int16ul,
    "version2" / Int32ul,
    "entry" / Int64ul,
    "phoff" / Int64ul,
    "shoff" / Int64ul,
    "flags" / Int32ul,
    "ehsize" / Int16ul,
    "phentsize" / Int16ul,
    "phnum" / Int16ul,
    "shentsize" / Int16ul,
    "shnum" / Int16ul,
    "shstrndx" / Int16ul,
)`
            },
            
            "pe": {
                name: "PE Header (Windows)",
                description: "PE/COFF executable header (DOS + PE)",
                category: "Files",
                code: `# PE Header (DOS Stub + PE Signature)
format_struct = Struct(
    # DOS Header
    "dos_magic" / Bytes(2),
    "dos_lastsize" / Int16ul,
    "dos_nblocks" / Int16ul,
    "dos_nreloc" / Int16ul,
    "dos_hdrsize" / Int16ul,
    "dos_minalloc" / Int16ul,
    "dos_maxalloc" / Int16ul,
    "dos_ss" / Int16ul,
    "dos_sp" / Int16ul,
    "dos_checksum" / Int16ul,
    "dos_ip" / Int16ul,
    "dos_cs" / Int16ul,
    "dos_lfarlc" / Int16ul,
    "dos_ovno" / Int16ul,
    "dos_res" / Bytes(8),
    "dos_oemid" / Int16ul,
    "dos_oeminfo" / Int16ul,
    "dos_res2" / Bytes(20),
    "pe_offset" / Int32ul,
)`
            },
            
            "zip": {
                name: "ZIP Local File Header",
                description: "ZIP archive local file header with dynamic filename and extra fields",
                category: "Files",
                code: `# ZIP Local File Header (Dynamic)
format_struct = Struct(
    "signature" / Bytes(4),
    "version" / Int16ul,
    "flags" / Int16ul,
    "compression" / Int16ul,
    "mod_time" / Int16ul,
    "mod_date" / Int16ul,
    "crc32" / Int32ul,
    "compressed_size" / Int32ul,
    "uncompressed_size" / Int32ul,
    "filename_length" / Int16ul,
    "extra_length" / Int16ul,
    "filename" / Bytes(this.filename_length.value),
    "extra_field" / Bytes(this.extra_length.value),
    # Compressed data follows
)`
            },
            
            "gzip": {
                name: "GZIP Header",
                description: "GZIP compression header with dynamic filename/comment",
                category: "Files",
                code: `# GZIP Header (Dynamic)
format_struct = Struct(
    "magic" / Bytes(2),
    "method" / Int8ub,
    "flags" / Int8ub,
    "mtime" / Int32ul,
    "extra_flags" / Int8ub,
    "os" / Int8ub,
    # If flags & 0x04: extra field follows (2-byte length + data)
    # If flags & 0x08: null-terminated filename follows
    # If flags & 0x10: null-terminated comment follows
)`
            },
            
            "tar": {
                name: "TAR Header (POSIX)",
                description: "POSIX TAR archive header with filename and metadata",
                category: "Files",
                code: `# TAR Header (POSIX/ustar)
format_struct = Struct(
    "name" / Bytes(100),
    "mode" / Bytes(8),
    "uid" / Bytes(8),
    "gid" / Bytes(8),
    "size" / Bytes(12),
    "mtime" / Bytes(12),
    "checksum" / Bytes(8),
    "typeflag" / Bytes(1),
    "linkname" / Bytes(100),
    "magic" / Bytes(6),
    "version" / Bytes(2),
    "uname" / Bytes(32),
    "gname" / Bytes(32),
    "devmajor" / Bytes(8),
    "devminor" / Bytes(8),
    "prefix" / Bytes(155),
    "padding" / Bytes(12),
    # File data follows (size field indicates length)
)`
            },
            
            "png": {
                name: "PNG Chunk",
                description: "PNG image chunk with dynamic data field",
                category: "Files",
                code: `# PNG Chunk (Dynamic)
format_struct = Struct(
    "length" / Int32ub,
    "type" / Bytes(4),
    "data" / Bytes(this.length.value),
    "crc" / Int32ub,
)`
            },
            
            "jpeg": {
                name: "JPEG Segment",
                description: "JPEG image segment with dynamic data",
                category: "Files",
                code: `# JPEG Segment (Dynamic)
format_struct = Struct(
    "marker" / Bytes(2),
    "length" / Int16ub,
    "data" / Bytes(this.length.value - 2),
)`
            },
            
            // ===== FIRMWARE - Filesystems & Images =====
            
            "squashfs": {
                name: "SquashFS Superblock",
                description: "SquashFS compressed filesystem superblock",
                category: "Firmware",
                code: `# SquashFS Superblock
format_struct = Struct(
    "magic" / Bytes(4),
    "inode_count" / Int32ul,
    "mtime" / Int32ul,
    "block_size" / Int32ul,
    "fragment_count" / Int32ul,
    "compression" / Int16ul,
    "block_log" / Int16ul,
    "flags" / Int16ul,
    "id_count" / Int16ul,
    "version_major" / Int16ul,
    "version_minor" / Int16ul,
    "root_inode" / Int64ul,
    "bytes_used" / Int64ul,
    "id_table_start" / Int64ul,
    "xattr_table_start" / Int64ul,
    "inode_table_start" / Int64ul,
    "directory_table_start" / Int64ul,
    "fragment_table_start" / Int64ul,
    "lookup_table_start" / Int64ul,
)`
            },
            
            "ext4": {
                name: "EXT2/3/4 Superblock",
                description: "EXT filesystem superblock (compatible with ext2/ext3/ext4)",
                category: "Firmware",
                code: `# EXT2/3/4 Superblock
format_struct = Struct(
    "inodes_count" / Int32ul,
    "blocks_count" / Int32ul,
    "r_blocks_count" / Int32ul,
    "free_blocks_count" / Int32ul,
    "free_inodes_count" / Int32ul,
    "first_data_block" / Int32ul,
    "log_block_size" / Int32ul,
    "log_frag_size" / Int32ul,
    "blocks_per_group" / Int32ul,
    "frags_per_group" / Int32ul,
    "inodes_per_group" / Int32ul,
    "mtime" / Int32ul,
    "wtime" / Int32ul,
    "mnt_count" / Int16ul,
    "max_mnt_count" / Int16ul,
    "magic" / Int16ul,
    "state" / Int16ul,
    "errors" / Int16ul,
    "minor_rev_level" / Int16ul,
    "lastcheck" / Int32ul,
    "checkinterval" / Int32ul,
    "creator_os" / Int32ul,
    "rev_level" / Int32ul,
    "def_resuid" / Int16ul,
    "def_resgid" / Int16ul,
)`
            },
            
            "cpio": {
                name: "CPIO Archive (newc)",
                description: "CPIO archive header (newc format, common in initramfs)",
                category: "Firmware",
                code: `# CPIO Archive Header (newc format)
format_struct = Struct(
    "magic" / Bytes(6),
    "ino" / Bytes(8),
    "mode" / Bytes(8),
    "uid" / Bytes(8),
    "gid" / Bytes(8),
    "nlink" / Bytes(8),
    "mtime" / Bytes(8),
    "filesize" / Bytes(8),
    "devmajor" / Bytes(8),
    "devminor" / Bytes(8),
    "rdevmajor" / Bytes(8),
    "rdevminor" / Bytes(8),
    "namesize" / Bytes(8),
    "check" / Bytes(8),
    # Filename follows (namesize bytes)
    # File data follows (filesize bytes)
)`
            },
            
            // ===== EXAMPLES - Advanced Construct Features =====
            
            "aes_encrypted": {
                name: "AES Encrypted Data",
                description: "AES-CBC encrypted structure (EncryptedSym)",
                category: "Examples",
                code: `# AES Encrypted Structure Example
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

format_struct = Struct(
    "key" / Bytes(32),  # AES-256 key
    "iv" / Bytes(16),   # Initialization vector
    "enc_data" / EncryptedSym(
        Aligned(16,
            Struct(
                "width" / Int16ul,
                "height" / Int16ul,
                "format" / Int32ul,
            )
        ),
        lambda ctx: Cipher(
            algorithms.AES(ctx.key.value), 
            modes.CBC(ctx.iv.value),
            backend=default_backend()
        )
    )
)

# Build Mode: fill key (32 bytes), iv (16 bytes), width, height, format
# The inner struct will be automatically encrypted!
# Note: Use ctx.field.value due to RawCopy wrapper for offset tracking
`
            },
            
            "compressed_data": {
                name: "Compressed Data (zlib)",
                description: "Zlib compressed payload with length prefix (Compressed)",
                category: "Examples",
                code: `# Compressed Data Example
format_struct = Struct(
    "magic" / Const(b"COMP"),
    "compressed" / Prefixed(Int32ul, 
        Compressed(GreedyBytes, "zlib")
    )
)

# Build Mode: just provide the magic
# For compressed field, provide raw uncompressed data as hex
# It will be automatically compressed during build!
`
            },
            
            "checksummed": {
                name: "Checksummed Data",
                description: "Data with SHA256 checksum (Checksum + RawCopy)",
                category: "Examples",
                code: `# Checksummed Data Example
import hashlib

format_struct = Struct(
    "fields" / RawCopy(Struct(
        "version" / Int32ul,
        "length" / Int32ul,
        "data" / Bytes(16),
    )),
    "checksum" / Checksum(Bytes(32),
        lambda data: hashlib.sha256(data).digest(),
        this.fields.data
    ),
)

# Build Mode: provide version, length, data
# Checksum will be auto-calculated from the raw bytes!
`
            },
            
            "xor_encoded": {
                name: "XOR Encoded Data",
                description: "XOR obfuscated payload (ProcessXor)",
                category: "Examples",
                code: `# XOR Encoded Data Example
format_struct = Struct(
    "xor_key" / Int8ul,
    "encoded" / ProcessXor(
        this.xor_key.value,
        Struct(
            "secret_id" / Int32ul,
            "secret_value" / Int32ul,
        )
    )
)

# Build Mode: provide xor_key (e.g., 0xAB), secret_id, secret_value
# Data will be XORed automatically during build!
# Note: Use this.field.value due to RawCopy wrapper for offset tracking
`
            },
            
            "null_terminated": {
                name: "Null-Terminated String",
                description: "C-style null-terminated string (NullTerminated)",
                category: "Examples",
                code: `# Null-Terminated String Example
format_struct = Struct(
    "name" / NullTerminated(GreedyBytes),
    "age" / Int8ul,
)

# Build Mode: provide name as hex (e.g., "48656c6c6f" for "Hello")
# Null terminator will be added automatically!
`
            },
            
            "prefixed_array": {
                name: "Prefixed Array",
                description: "Length-prefixed array of items (PrefixedArray)",
                category: "Examples",
                code: `# Prefixed Array Example
format_struct = Struct(
    "magic" / Const(b"PARR"),
    "items" / PrefixedArray(Int16ul, 
        Struct(
            "id" / Int32ul,
            "value" / Int32ul,
        )
    ),
)

# Note: PrefixedArray requires array input during build
# This is better demonstrated with parsing existing data
`
            },
        };
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Utility functions
        const formatHex = (byte) => byte.toString(16).padStart(2, '0').toUpperCase();
        
        const formatAscii = (byte) => {
            return (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
        };

        // Python/Construct integration
        let pyodide = null;
        let pyodideReady = false;

        // Static Python helpers
        const PYTHON_BOOTSTRAP = `
import json
import traceback
import struct
from construct import *

# --- 1. Instrumentation & UI Helpers ---
_ui_roots = []
_ui_stack = []

class InstrumentedWrapper(Subconstruct):
    def __init__(self, subcon, name):
        super().__init__(subcon)
        self.name = name

    def _parse(self, stream, context, path):
        node = { "name": self.name, "children": [], "value": None, "offset": 0, "length": 0, "rawValue": None }
        if _ui_stack: _ui_stack[-1]['children'].append(node)
        else: _ui_roots.append(node)
        _ui_stack.append(node)
        start_offset = stream.tell()
        try:
            obj = self.subcon._parse(stream, context, path)
            end_offset = stream.tell()
            node['offset'] = start_offset
            node['length'] = end_offset - start_offset
            node['rawValue'] = obj
            node['value'] = self._format_value(obj, node['length'])
            return obj
        except Exception as e:
            node['error'] = str(e)
            raise e
        finally:
            _ui_stack.pop()
            
    def _build(self, obj, stream, context, path):
        return self.subcon._build(obj, stream, context, path)

    def _format_value(self, val, length):
        if isinstance(val, bytes):
            if len(val) > 16: return f"{val[:8].hex().upper()}... ({len(val)} bytes)"
            return val.hex().upper()
        if isinstance(val, int):
            if length == 1: return f"0x{val:02X} ({val})"
            if length == 2: return f"0x{val:04X} ({val})"
            if length == 4: return f"0x{val:08X} ({val})"
            return f"0x{val:X} ({val})"
        return str(val)

def instrument_structure(sc, name=""):
    if isinstance(sc, Renamed): return instrument_structure(sc.subcon, sc.name)
    if isinstance(sc, Struct):
        new_subcons = [instrument_structure(sub, sub.name) for sub in sc.subcons]
        return InstrumentedWrapper(Struct(*new_subcons), name or "Struct")
    elif isinstance(sc, Array):
        return InstrumentedWrapper(Array(sc.count, instrument_structure(sc.subcon, "")), name or "Array")
    else:
        field_name = name or getattr(sc, "name", None) or type(sc).__name__
        return InstrumentedWrapper(sc, field_name)

# --- 2. Schema Introspection Helpers ---
# Find def get_type_info(sc): and replace it with this:
def get_type_info(sc):
    if isinstance(sc, Renamed): sc = sc.subcon
    if isinstance(sc, FormatField):
        return {"type": "integer", "size": sc.length, "signed": getattr(sc, "signed", False)}
    if isinstance(sc, Bytes):
        # FIX: Check if size is actually an integer. If it's a Path (this.a), return None.
        size = sc.length if isinstance(sc.length, int) else None
        return {"type": "bytes", "size": size}
    if isinstance(sc, Const):
        val = sc.value
        if isinstance(val, bytes): val = val.hex().upper()
        return {"type": "const", "value": val}
    return {"type": "unknown", "repr": str(type(sc))}
    
def extract_schema(sc, path=""):
    fields = []
    def walk(subcon, current_path):
        if isinstance(subcon, Renamed):
            name = subcon.name
            info = get_type_info(subcon.subcon)
            if isinstance(subcon.subcon, Struct):
                for sub in subcon.subcon.subcons:
                    walk(sub, current_path + [name])
                return
            fields.append({ "id": ".".join(current_path + [name]), "name": name, "path": current_path, "info": info })
            return
        if isinstance(subcon, Struct):
            for sub in subcon.subcons:
                walk(sub, current_path)
            return
    walk(sc, [])
    return fields

def get_struct_obj():
    for name in ['format_struct', 'struct', 'packet', 'header']:
        if name in globals() and isinstance(globals()[name], Construct):
            return globals()[name]
    return None

def get_schema_json():
    s = get_struct_obj()
    if not s: return {"error": "No struct found"}
    try:
        return {"schema": extract_schema(s)}
    except Exception as e:
        return {"error": str(e)}

def build_and_parse_live(values_json):
    global _ui_roots, _ui_stack
    s = get_struct_obj()
    if not s: return {"error": "No struct found"}
    try:
        vals = json.loads(values_json)
        container = Container()
        
        def set_nested(root, path, value):
            curr = root
            for p in path[:-1]:
                if p not in curr: curr[p] = Container()
                curr = curr[p]
            
            final_val = value
            # Handle hex strings for bytes fields
            if isinstance(value, str):
                clean = value.replace(' ', '').replace('0x', '')
                if all(c in '0123456789ABCDEFabcdef' for c in clean):
                     if len(clean) % 2 == 0 and len(clean) > 0:
                         try: 
                            final_val = bytes.fromhex(clean)
                         except: pass

            curr[path[-1]] = final_val

        for key, val in vals.items():
            set_nested(container, key.split('.'), val)

        # Build
        data = s.build(container)
        
        # Parse Back for Highlighting
        _ui_roots = []
        _ui_stack = []
        instrumented = instrument_structure(s, "root")
        instrumented.parse(data)
        
        def clean_node(n):
            return {
                "name": n['name'], "value": n['value'], "offset": n['offset'], "length": n['length'],
                "children": [clean_node(c) for c in n['children']]
            }
        
        fields = [clean_node(n) for n in _ui_roots]
        if len(fields) == 1 and fields[0]['name'] == 'root': fields = fields[0]['children']

        return { "hex": data.hex(), "fields": fields }
    except Exception as e:
        return {"error": str(e), "traceback": traceback.format_exc()}
`;

       const initPyodide = async () => {
            if (pyodideReady) return pyodide;
            
            console.log('Loading Pyodide...');
            pyodide = await loadPyodide({
                indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
            });
            
            await pyodide.loadPackage(['micropip']);
            const micropip = pyodide.pyimport('micropip');
            await micropip.install('construct');
            
            try { await pyodide.loadPackage('cryptography'); } catch (err) {}
            
            console.log('Bootstrapping Python environment...');
            await pyodide.runPythonAsync(PYTHON_BOOTSTRAP);
            
            console.log('Pyodide ready!');
            pyodideReady = true;
            return pyodide;
        };


        const parseWithConstruct = async (data, structCode) => {
            if (!pyodideReady) throw new Error('Pyodide not ready');

            try {
                const dataArray = Array.from(data);
                const dataBytes = pyodide.toPy(dataArray);
                pyodide.globals.set('data_list', dataBytes);

                // FIXED: We explicitly assign the output to 'output_json' and return it at the end
                const runnerCode = `
${structCode}

import json
import traceback

output_json = ""

try:
    s = get_struct_obj()
    if not s: raise Exception("No struct found")
    
    global _ui_roots, _ui_stack
    _ui_roots = []
    _ui_stack = []
    
    inst = instrument_structure(s, "root")
    inst.parse(bytes(data_list))
    
    def clean_node(n):
        return {
            "name": n['name'], "value": n['value'], "offset": n['offset'], "length": n['length'],
            "rawValue": n['rawValue'] if isinstance(n['rawValue'], (int, str, bool, type(None))) else None,
            "children": [clean_node(c) for c in n['children']]
        }
    
    final_fields = [clean_node(n) for n in _ui_roots]
    if len(final_fields) == 1 and final_fields[0]['name'] == 'root':
            final_fields = final_fields[0]['children']
            
    output_json = json.dumps({"fields": final_fields})
except Exception as e:
    output_json = json.dumps({"error": str(e), "traceback": traceback.format_exc()})

# The last line is the return value for runPythonAsync
output_json
`;
                
                const result = await pyodide.runPythonAsync(runnerCode);
                
                // Guard against empty result
                if (!result) return [];
                
                const parsed = JSON.parse(result);
                
                if (parsed.error) throw new Error(parsed.error);
                return parsed.fields || [];

            } catch (error) {
                console.error('Parse error:', error);
                throw error;
            }
        };
        
const SmartInput = ({ field, value, onChange, onFocus }) => {
            // Initial mode: integers use 'int', bytes default to 'hex'
            const initialMode = field.info.type === 'integer' ? 'int' : 'hex';
            const [mode, setMode] = useState(initialMode);
            const [localValue, setLocalValue] = useState('');
            const [isFocused, setIsFocused] = useState(false);
            
            // Ref for cursor management
            const inputRef = useRef(null);
            const cursorTarget = useRef(null);
            
            const type = field.info.type;
            const size = field.info.size; // Size in bytes (undefined if dynamic)

            // --- 1. Sync Logic (Parent -> Local) ---
            useEffect(() => {
                if (isFocused) return;

                if (value === undefined || value === null) {
                    setLocalValue('');
                    return;
                }

                if (type === 'integer') {
                    setLocalValue(value.toString());
                } 
                else if (type === 'bytes') {
                    if (mode === 'text') {
                        // Decode hex to text for display
                        try {
                            const hex = value.toString().replace(/[^0-9A-Fa-f]/g, '');
                            let str = '';
                            for (let i = 0; i < hex.length; i += 2) {
                                const code = parseInt(hex.substr(i, 2), 16);
                                // Filter printable ASCII
                                str += (code >= 32 && code <= 126) ? String.fromCharCode(code) : '.';
                            }
                            setLocalValue(str);
                        } catch (e) { setLocalValue(''); }
                    } else {
                        // Hex: Format as "AA BB CC"
                        const clean = value.toString().replace(/[^0-9A-Fa-f]/g, '').toUpperCase();
                        const chunks = clean.match(/.{1,2}/g) || [];
                        setLocalValue(chunks.join(' '));
                    }
                }
            }, [value, isFocused, mode, type]);

            // --- 2. Cursor Restoration Effect ---
            // This runs immediately after render to put the cursor back where it belongs
            useEffect(() => {
                if (cursorTarget.current !== null && inputRef.current) {
                    inputRef.current.setSelectionRange(cursorTarget.current, cursorTarget.current);
                    cursorTarget.current = null;
                }
            }, [localValue]);

            // --- 3. Change Handler (The "Hex Editor" Logic) ---
            const handleChange = (e) => {
                const newValue = e.target.value;
                const selectionStart = e.target.selectionStart;

                if (mode === 'int') {
                    setLocalValue(newValue);
                    // Standard integer validation
                    if (/^(0x)?[0-9A-Fa-f]*$/.test(newValue)) {
                        let num = newValue.startsWith('0x') ? parseInt(newValue, 16) : parseInt(newValue, 10);
                        const maxVal = size ? Math.pow(2, size * 8) - 1 : Number.MAX_SAFE_INTEGER;
                        if (!isNaN(num) && num <= maxVal) {
                            onChange(field.id, num);
                        }
                    }
                }
                else if (mode === 'hex') {
                    // --- Reactive Hex Logic ---
                    
                    // 1. Calculate how many *real* hex digits were before the cursor
                    //    This helps us find the new position after we add spaces.
                    const rawBeforeCursor = newValue.substring(0, selectionStart).replace(/[^0-9A-Fa-f]/g, '').length;
                    
                    // 2. Strip everything to raw hex
                    let raw = newValue.replace(/[^0-9A-Fa-f]/g, '').toUpperCase();
                    
                    // 3. Enforce Size Limit (if defined)
                    if (size && raw.length > size * 2) {
                        // If we are over the limit, trim from the end (standard insert behavior)
                        raw = raw.substring(0, size * 2);
                    }
                    
                    // 4. Reformat with spaces (Reactive Spacing)
                    const chunks = raw.match(/.{1,2}/g) || [];
                    const formatted = chunks.join(' ');
                    
                    setLocalValue(formatted);

                    // 5. Calculate new cursor position
                    //    Find the index in 'formatted' that corresponds to 'rawBeforeCursor' hex digits
                    let newPos = 0;
                    let hexCount = 0;
                    for (let i = 0; i < formatted.length; i++) {
                        if (/[0-9A-Fa-f]/.test(formatted[i])) {
                            hexCount++;
                        }
                        if (hexCount === rawBeforeCursor) {
                            newPos = i + 1;
                            break;
                        }
                    }
                    
                    // Small UX tweak: if landing on a space, jump over it
                    if (formatted[newPos] === ' ') newPos++;

                    // Schedule cursor update
                    cursorTarget.current = newPos;

                    // 6. Update Parent with Clean Hex
                    onChange(field.id, raw);
                }
                else if (mode === 'text') {
                    // --- Text Logic ---
                    let text = newValue;
                    
                    // Limit Size
                    if (size && text.length > size) {
                        text = text.substring(0, size);
                    }
                    
                    setLocalValue(text);
                    
                    // Convert to Hex for parent
                    let hex = '';
                    for (let i = 0; i < text.length; i++) {
                        hex += text.charCodeAt(i).toString(16).padStart(2, '0');
                    }
                    onChange(field.id, hex.toUpperCase());
                }
            };

            const toggleMode = () => {
                setMode(mode === 'hex' ? 'text' : 'hex');
                setIsFocused(false); // Trigger re-sync
            };

            const getTypeLabel = () => {
                if (type === 'integer') return `${field.info.signed ? 'i' : 'u'}${size * 8}`;
                if (type === 'bytes') return `byte[${size || '‚àû'}]`;
                return type;
            };

            const getIcon = () => {
                if (mode === 'int') return 'üî¢';
                if (mode === 'hex') return '0x';
                if (mode === 'text') return 'Aa';
                return 'üìù';
            };

            const isConst = type === 'const';

            return (
                <div className={`group bg-gray-900 border ${isFocused ? 'border-blue-500' : 'border-gray-800'} hover:border-blue-500/50 rounded-md p-2 transition-all`}>
                    <div className="flex justify-between items-center mb-1">
                        <div className="flex items-center gap-2">
                            <label className="text-xs font-semibold text-gray-400 group-hover:text-blue-400 transition-colors">
                                {field.name}
                            </label>
                            {/* Toggle Button */}
                            {type === 'bytes' && !isConst && (
                                <button 
                                    onClick={toggleMode}
                                    className="text-[10px] px-1.5 py-0.5 rounded bg-gray-800 hover:bg-gray-700 text-blue-300 border border-gray-700 transition-colors"
                                    title={`Switch to ${mode === 'hex' ? 'Text' : 'Hex'} input`}
                                >
                                    {mode === 'hex' ? 'HEX' : 'TXT'}
                                </button>
                            )}
                        </div>
                        <span className="text-[10px] uppercase tracking-wider text-gray-600 font-mono bg-gray-800 px-1 rounded">
                            {getTypeLabel()}
                        </span>
                    </div>
                    
                    <div className="relative">
                        <div className="absolute left-2 top-1/2 transform -translate-y-1/2 opacity-50 text-xs grayscale font-mono font-bold select-none">
                            {getIcon()}
                        </div>
                        <input
                            ref={inputRef}
                            type="text"
                            value={isConst ? field.info.value : localValue}
                            onChange={handleChange}
                            onFocus={() => { setIsFocused(true); onFocus && onFocus(field.id); }}
                            onBlur={() => setIsFocused(false)}
                            readOnly={isConst}
                            // We don't use maxLength here for Hex because spaces inflate the length.
                            // We handle limits in handleChange instead.
                            placeholder={mode === 'hex' ? 'FF 00 AA...' : 'Enter text...'}
                            className={`w-full bg-black/30 border border-gray-700 rounded px-2 py-1 pl-8 text-sm font-mono focus:outline-none focus:border-blue-500 transition-colors ${
                                isConst ? 'opacity-50 cursor-not-allowed text-gray-500' : 'text-blue-100'
                            }`}
                        />
                    </div>
                </div>
            );
        };

        const LiveBuilder = ({ pyodide, structDef, onBuildComplete }) => { 
            const [schema, setSchema] = useState([]);
            const [values, setValues] = useState({});
            const [status, setStatus] = useState("Initializing...");
            const [error, setError] = useState(null);
            
            // Load Schema on Mount
                useEffect(() => {
                const loadSchema = async () => {
                    try {
                        if (!pyodide) return;
                        
                        // 1. Define the user's struct in Python first!
                        await pyodide.runPythonAsync(structDef);

                        // 2. Now ask for the schema
                        const res = await pyodide.runPythonAsync(`
                            import json
                            json.dumps(get_schema_json())
                        `);                        
                        const data = JSON.parse(res);
                        
                        if (data.error) {
                            setError(data.error);
                            setSchema([]);
                        } else {
                            setSchema(data.schema || []);
                            setError(null);
                            setStatus("Ready");
                            
                            // Initialize default values based on schema
                            const defaults = {};
                            data.schema.forEach(f => {
                                if (f.info.type === 'const') return;
                                defaults[f.id] = f.info.type === 'bytes' ? '00'.repeat(f.info.size || 1) : 0;
                            });
                            setValues(defaults);
                        }
                    } catch (e) {
                        setError("Failed to load struct schema: " + e.message);
                    }
                };
                loadSchema();
            }, [pyodide, structDef]);

            // Debounced Live Build
            useEffect(() => {
                if (schema.length === 0 || !pyodide) return;

                const timer = setTimeout(async () => {
                    setStatus("Building...");
                    try {
                        const jsonValues = JSON.stringify(values);
                        // We need to escape the JSON string for Python
                        const safeJson = jsonValues.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
                        
                        const res = await pyodide.runPythonAsync(`
                            import json
                            json.dumps(build_and_parse_live('${safeJson}'))
                        `);
                        
                        const result = JSON.parse(res);
                        
                        if (result.error) {
                            // Don't show hard error overlay, just status
                            setStatus("Build Invalid: " + result.error.split('\n').pop());
                        } else {
                            // Convert hex string back to Uint8Array
                            const hex = result.hex;
                            const bytes = new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                            
                            onBuildComplete(bytes, result.fields);
                            setStatus("‚úì Live Preview Updated");
                        }
                    } catch (e) {
                        console.error(e);
                        setStatus("Build Error");
                    }
                }, 300); // 300ms debounce

                return () => clearTimeout(timer);
            }, [values, schema, pyodide]);

            const handleValueChange = (id, val) => {
                setValues(prev => ({ ...prev, [id]: val }));
            };

            const handleFocus = (id) => {
                // Future: Highlight field in hex view
            };

            return (
                <div className="flex flex-col h-full bg-[#0d1117]">
                    <div className="p-3 border-b border-gray-800 bg-[#161b22]">
                        <div className="flex justify-between items-center">
                            <h3 className="font-semibold text-blue-400">Live Builder</h3>
                            <span className={`text-xs px-2 py-0.5 rounded ${status.startsWith('‚úì') ? 'bg-green-900/50 text-green-400' : 'bg-gray-800 text-gray-400'}`}>
                                {status}
                            </span>
                        </div>
                        {error && <div className="text-xs text-red-400 mt-1">{error}</div>}
                    </div>

                    <div className="flex-1 overflow-y-auto p-4 space-y-3 scrollbar-thin">
                        {schema.length === 0 && !error && (
                            <div className="text-center text-gray-600 mt-10">
                                <div className="loading-spinner w-6 h-6 border-2 mx-auto mb-2"></div>
                                Analyzing Structure...
                            </div>
                        )}
                        
                        {schema.map(field => (
                            <SmartInput 
                                key={field.id} 
                                field={field} 
                                value={values[field.id]} 
                                onChange={handleValueChange}
                                onFocus={handleFocus}
                            />
                        ))}
                        
                        <div className="mt-8 p-3 bg-blue-900/10 border border-blue-500/20 rounded text-xs text-blue-300/70">
                            üí° Data is built & parsed in real-time. The Hex View on the right reflects your changes instantly.
                        </div>
                    </div>
                </div>
            );
        };

        // Hex View Component with Virtual Scrolling
        const HexView = ({ data, highlightRanges = [], onByteClick, selectedField, hoveredField }) => {
            const [scrollTop, setScrollTop] = useState(0);
            const containerRef = useRef(null);
            
            const bytesPerLine = 16;
            const lineHeight = 24; // pixels per line
            const overscan = 10; // render extra lines above/below viewport
            
            const totalLines = Math.ceil(data.length / bytesPerLine);
            const totalHeight = totalLines * lineHeight;
            
            // Calculate visible range
            const containerHeight = containerRef.current?.clientHeight || 600;
            const visibleLines = Math.ceil(containerHeight / lineHeight);
            const startLine = Math.max(0, Math.floor(scrollTop / lineHeight) - overscan);
            const endLine = Math.min(totalLines, startLine + visibleLines + overscan * 2);
            
            const handleScroll = (e) => {
                setScrollTop(e.target.scrollTop);
            };

            const getHighlightClass = (byteIndex) => {
                // Check if this byte is in the hovered field
                const isHovered = hoveredField && 
                                  byteIndex >= hoveredField.offset && 
                                  byteIndex < hoveredField.offset + hoveredField.length;
                
                for (let i = 0; i < highlightRanges.length; i++) {
                    const range = highlightRanges[i];
                    if (byteIndex >= range.offset && byteIndex < range.offset + range.length) {
                        // Use topLevelIndex for color instead of range index
                        const baseClass = `field-highlight-${range.topLevelIndex % 8}`;
                        return isHovered ? `${baseClass} hovered` : baseClass;
                    }
                }
                return '';
            };
            
            // Only render visible lines
            const visibleLineElements = [];
            for (let lineIdx = startLine; lineIdx < endLine; lineIdx++) {
                const offset = lineIdx * bytesPerLine;
                const lineData = data.slice(offset, Math.min(offset + bytesPerLine, data.length));
                const y = lineIdx * lineHeight;
                
                visibleLineElements.push(
                    <div 
                        key={lineIdx} 
                        className="hex-line" 
                        style={{ 
                            position: 'absolute', 
                            top: `${y}px`,
                            left: 0,
                            right: 0,
                            height: `${lineHeight}px`
                        }}
                    >
                        <span className="hex-offset">
                            {offset.toString(16).padStart(8, '0').toUpperCase()}
                        </span>
                        <span className="mx-4">
                            {Array.from(lineData).map((byte, byteIdx) => {
                                const globalIdx = offset + byteIdx;
                                const highlightClass = getHighlightClass(globalIdx);
                                return (
                                    <span
                                        key={byteIdx}
                                        className={`hex-cell ${highlightClass}`}
                                        onClick={() => onByteClick && onByteClick(globalIdx)}
                                        title={`Offset: 0x${globalIdx.toString(16)}, Value: 0x${formatHex(byte)} (${byte})`}
                                    >
                                        {formatHex(byte)}
                                    </span>
                                );
                            })}
                            {Array(bytesPerLine - lineData.length).fill(0).map((_, i) => (
                                <span key={`pad-${i}`} className="hex-cell opacity-30">¬∑¬∑</span>
                            ))}
                        </span>
                        <span className="ml-4 border-l border-gray-700 pl-4">
                            {Array.from(lineData).map((byte, byteIdx) => {
                                const globalIdx = offset + byteIdx;
                                const highlightClass = getHighlightClass(globalIdx);
                                return (
                                    <span 
                                        key={byteIdx} 
                                        className={`ascii-char ${highlightClass}`}
                                        title={`Offset: 0x${globalIdx.toString(16)}`}
                                    >
                                        {formatAscii(byte)}
                                    </span>
                                );
                            })}
                        </span>
                    </div>
                );
            }

            return (
                <div 
                    ref={containerRef}
                    className="font-mono text-sm"
                    style={{ 
                        height: '100%', 
                        overflow: 'auto',
                        position: 'relative'
                    }}
                    onScroll={handleScroll}
                >
                    <div style={{ height: `${totalHeight}px`, position: 'relative' }}>
                        {visibleLineElements}
                    </div>
                </div>
            );
        };

        // Edit Modal Component
        const EditModal = ({ field, onClose, onSave }) => {
            // --- 1. Initialization Logic ---
            // Determine initial mode and value based on the field data
            const getInitialState = () => {
                const isInt = typeof field.rawValue === 'number';
                // Default to 'int' for numbers, 'hex' for everything else (safest for binary editing)
                const initialMode = isInt ? 'int' : 'hex';
                
                let val = '';
                if (isInt) {
                    val = field.rawValue.toString();
                } else if (field.value) {
                    // Extract raw hex from the display string (which might be "AA BB..." or "0x...")
                    const raw = field.value.replace(/^0x/, '').replace(/[^0-9A-Fa-f]/g, '').toUpperCase();
                    // Initial formatting
                    const chunks = raw.match(/.{1,2}/g) || [];
                    val = chunks.join(' ');
                }
                
                return { mode: initialMode, val };
            };

            const initialState = getInitialState();
            const [mode, setMode] = useState(initialState.mode);
            const [localValue, setLocalValue] = useState(initialState.val);
            const [error, setError] = useState('');
            
            // Refs for cursor management
            const inputRef = useRef(null);
            const cursorTarget = useRef(null);

            const size = field.length; // We always know the size in Edit Mode

            // --- 2. Cursor Restoration ---
            // Puts the cursor back in the right place after React re-renders the formatted value
            useEffect(() => {
                if (cursorTarget.current !== null && inputRef.current) {
                    inputRef.current.setSelectionRange(cursorTarget.current, cursorTarget.current);
                    cursorTarget.current = null;
                }
            }, [localValue]);

            // --- 3. Reactive Change Handler ---
            const handleChange = (e) => {
                const newValue = e.target.value;
                const selectionStart = e.target.selectionStart;

                setError(''); // Clear errors on type

                if (mode === 'int') {
                    setLocalValue(newValue);
                }
                else if (mode === 'hex') {
                    // --- Reactive Hex Logic (Same as SmartInput) ---
                    
                    // 1. Count real hex digits before cursor
                    const rawBeforeCursor = newValue.substring(0, selectionStart).replace(/[^0-9A-Fa-f]/g, '').length;
                    
                    // 2. Get raw hex
                    let raw = newValue.replace(/[^0-9A-Fa-f]/g, '').toUpperCase();
                    
                    // 3. Strict Size Limit
                    if (size && raw.length > size * 2) {
                        raw = raw.substring(0, size * 2);
                    }
                    
                    // 4. Format with spaces
                    const chunks = raw.match(/.{1,2}/g) || [];
                    const formatted = chunks.join(' ');
                    
                    setLocalValue(formatted);

                    // 5. Calculate new cursor position
                    let newPos = 0;
                    let hexCount = 0;
                    for (let i = 0; i < formatted.length; i++) {
                        if (/[0-9A-Fa-f]/.test(formatted[i])) hexCount++;
                        if (hexCount === rawBeforeCursor) {
                            newPos = i + 1;
                            break;
                        }
                    }
                    // Jump over space
                    if (formatted[newPos] === ' ') newPos++;
                    
                    cursorTarget.current = newPos;
                }
                else if (mode === 'text') {
                    // --- Text Logic ---
                    let text = newValue;
                    if (size && text.length > size) {
                        text = text.substring(0, size);
                    }
                    setLocalValue(text);
                }
            };

            const handleSaveClick = () => {
                try {
                    let newBytes;

                    if (mode === 'int') {
                        // Integer Validation
                        if (!/^(0x)?[0-9A-Fa-f]+$/.test(localValue) && !/^\d+$/.test(localValue)) {
                            throw new Error("Invalid integer format");
                        }
                        let val = localValue.startsWith('0x') ? parseInt(localValue, 16) : parseInt(localValue, 10);
                        
                        // Check Bounds
                        const max = size === 1 ? 0xFF : size === 2 ? 0xFFFF : size === 4 ? 0xFFFFFFFF : Number.MAX_SAFE_INTEGER;
                        if (val < 0 || val > max) throw new Error(`Value exceeds ${size} byte(s)`);
                        
                        // Convert to Bytes (Little Endian default for integers)
                        newBytes = new Uint8Array(size);
                        for (let i = 0; i < size; i++) {
                             newBytes[i] = (val >> (i * 8)) & 0xFF;
                        }

                    } else if (mode === 'hex') {
                        // Hex Validation
                        const raw = localValue.replace(/[^0-9A-Fa-f]/g, '');
                        // Auto-pad with zeros if user leaves it short (e.g. "F" -> "0F")
                        const padded = raw.padEnd(size * 2, '0');
                        
                        newBytes = new Uint8Array(size);
                        for (let i = 0; i < size; i++) {
                            newBytes[i] = parseInt(padded.substr(i*2, 2), 16);
                        }
                    } else {
                        // Text Validation
                        newBytes = new Uint8Array(size); // Zero-filled by default
                        for (let i = 0; i < Math.min(localValue.length, size); i++) {
                            newBytes[i] = localValue.charCodeAt(i);
                        }
                    }
                    
                    onSave(field.offset, newBytes);
                    onClose();
                } catch (e) {
                    setError(e.message);
                }
            };

            const toggleMode = () => {
                // Cycle: Hex -> Text -> Hex (Int is usually sticky unless manually switched, or we can cycle all 3)
                // Let's stick to Hex/Text toggle for Bytes fields, and keep Int for Int fields.
                if (mode === 'int') return; // Don't toggle out of Int mode easily to avoid confusion
                
                const newMode = mode === 'hex' ? 'text' : 'hex';
                setMode(newMode);
                setLocalValue(''); // Clear value on toggle to avoid conversion confusion
                setError('');
            };

            const getIcon = () => {
                if (mode === 'int') return 'üî¢';
                if (mode === 'hex') return '0x';
                if (mode === 'text') return 'Aa';
                return 'üìù';
            };

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content" onClick={(e) => e.stopPropagation()}>
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-lg font-semibold" style={{ color: '#58a6ff' }}>
                                Edit Field: {field.name}
                            </h2>
                            {mode !== 'int' && (
                                <button 
                                    onClick={toggleMode}
                                    className="text-xs px-2 py-1 rounded bg-gray-800 border border-gray-700 hover:border-blue-500 text-blue-400 transition-colors"
                                >
                                    Mode: {mode.toUpperCase()}
                                </button>
                            )}
                        </div>
                        
                        <div className="mb-6">
                            <div className="text-sm mb-2 flex justify-between" style={{ color: '#8b949e' }}>
                                <span>Offset: 0x{field.offset.toString(16).padStart(4, '0')}</span>
                                <span>Size: {size} bytes</span>
                            </div>
                            
                            <div className="relative group">
                                <div className="absolute left-3 top-1/2 transform -translate-y-1/2 opacity-50 text-sm grayscale font-mono font-bold select-none pointer-events-none">
                                    {getIcon()}
                                </div>
                                <input
                                    ref={inputRef}
                                    type="text"
                                    className="w-full bg-[#0d1117] border border-gray-600 rounded px-3 py-2 pl-10 text-base font-mono focus:outline-none focus:border-blue-500 transition-colors text-blue-100"
                                    value={localValue}
                                    onChange={handleChange}
                                    onKeyDown={(e) => e.key === 'Enter' && handleSaveClick()}
                                    placeholder={mode === 'hex' ? 'FF 00 AA...' : 'Enter value...'}
                                    autoFocus
                                />
                            </div>
                            
                            <div className="mt-2 text-xs text-gray-500 flex justify-between">
                                <span>
                                    {mode === 'hex' && `Hex: ${localValue.replace(/\s/g, '').length / 2} / ${size} bytes`}
                                    {mode === 'text' && `Text: ${localValue.length} / ${size} chars`}
                                    {mode === 'int' && `Integer (${size * 8}-bit)`}
                                </span>
                                {mode === 'hex' && <span>Reactive Insert Mode</span>}
                            </div>
                            
                            {error && (
                                <div className="mt-3 text-sm p-2 rounded bg-red-900/20 border border-red-500/50 text-red-400">
                                    ‚ö†Ô∏è {error}
                                </div>
                            )}
                        </div>
                        
                        <div className="flex justify-end space-x-2">
                            <button
                                onClick={onClose}
                                className="px-4 py-2 btn-terminal rounded hover:bg-gray-800"
                            >
                                Cancel
                            </button>
                            <button
                                onClick={handleSaveClick}
                                className="px-6 py-2 rounded font-medium text-white shadow-lg transition-transform active:scale-95"
                                style={{
                                    background: '#238636',
                                    border: '1px solid #2ea043',
                                }}
                            >
                                Save Changes
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Syntax Highlighter Component
        const CodeEditor = ({ value, onChange, placeholder, spellCheck = false }) => {
            const textareaRef = useRef(null);
            const displayRef = useRef(null);
            const contentRef = useRef(null);
            
            const handleScroll = (e) => {
                // Sync scroll position using transform (more reliable than scrollTop)
                if (contentRef.current) {
                    contentRef.current.style.transform = `translate(${-e.target.scrollLeft}px, ${-e.target.scrollTop}px)`;
                }
            };
            
            const handleKeyDown = (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    
                    const textarea = e.target;
                    const start = textarea.selectionStart;
                    const end = textarea.selectionEnd;
                    
                    // Insert 4 spaces
                    const newValue = value.substring(0, start) + '    ' + value.substring(end);
                    onChange({ target: { value: newValue } });
                    
                    // Set cursor position after the inserted spaces
                    setTimeout(() => {
                        textarea.selectionStart = textarea.selectionEnd = start + 4;
                    }, 0);
                }
            };
            
            const highlightSyntax = (code) => {
                if (!code) return '';
                
                // Escape HTML
                const escapeHtml = (text) => text
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                
                // Token patterns (order matters - most specific first!)
                const patterns = [
                    { regex: /#[^\n]*/g, className: 'token-comment' },
                    { regex: /b"(?:[^"\\]|\\.)*"|b'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'/g, className: 'token-string' },
                    { regex: /\b(import|from|def|class|if|else|elif|for|while|return|lambda|try|except|with|as|in|True|False|None)\b/g, className: 'token-keyword' },
                    { regex: /\b(Struct|Bytes|Int8ub|Int8ul|Int8sb|Int8sl|Int16ub|Int16ul|Int16sb|Int16sl|Int32ub|Int32ul|Int32sb|Int32sl|Int64ub|Int64ul|Int64sb|Int64sl|Float32l|Float32b|Float64l|Float64b|Array|Aligned|Default|EncryptedSym|Compressed|Prefixed|PrefixedArray|Computed|Rebuild|Enum|FlagsEnum|Switch|Const|Padding|Padded|Container|Cipher|algorithms|modes|AES|CBC|RawCopy|Checksum|ProcessXor|NullTerminated|GreedyBytes|GreedyRange|VarInt|CString|PascalString|Bitwise|BitsInteger|Bit|Nibble|Octet|Flag|ExprAdapter|Validator|Hex|HexDump|Probe|Debugger|Peek|IfThenElse|Pass|Terminated|Tell|Seek|Pointer|default_backend|hashlib|sha256|md5)\b/g, className: 'token-class' },
                    { regex: /\b(os|this|ctx|obj|_)\b/g, className: 'token-builtin' },
                    { regex: /\b(0x[0-9A-Fa-f]+|\d+)\b/g, className: 'token-number' },
                    { regex: /[\/=]/g, className: 'token-operator' },
                ];
                
                // Find all matches across all patterns
                const allMatches = [];
                patterns.forEach(pattern => {
                    let match;
                    const regex = new RegExp(pattern.regex.source, pattern.regex.flags);
                    while ((match = regex.exec(code)) !== null) {
                        allMatches.push({
                            start: match.index,
                            end: match.index + match[0].length,
                            text: match[0],
                            className: pattern.className
                        });
                    }
                });
                
                // Sort by position
                allMatches.sort((a, b) => a.start - b.start);
                
                // Remove overlapping matches (keep first match)
                const nonOverlapping = [];
                let lastEnd = 0;
                for (const match of allMatches) {
                    if (match.start >= lastEnd) {
                        nonOverlapping.push(match);
                        lastEnd = match.end;
                    }
                }
                
                // Build highlighted output
                let result = '';
                let pos = 0;
                
                for (const match of nonOverlapping) {
                    // Add text before match (unformatted)
                    if (pos < match.start) {
                        result += escapeHtml(code.substring(pos, match.start));
                    }
                    
                    // Add highlighted match
                    result += `<span class="${match.className}">${escapeHtml(match.text)}</span>`;
                    pos = match.end;
                }
                
                // Add remaining text
                if (pos < code.length) {
                    result += escapeHtml(code.substring(pos));
                }
                
                return result;
            };
            
            return (
                <div className="code-editor-highlighted flex-1" style={{ position: 'relative', background: '#0d1117', overflow: 'hidden' }}>
                    <div 
                        ref={displayRef}
                        className="code-editor-display"
                        style={{ 
                            position: 'absolute',
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0,
                            overflow: 'hidden',
                            pointerEvents: 'none'
                        }}
                    >
                        <div 
                            ref={contentRef}
                            style={{ willChange: 'transform' }}
                            dangerouslySetInnerHTML={{ __html: highlightSyntax(value) }}
                        />
                    </div>
                    <textarea
                        ref={textareaRef}
                        className="code-editor-textarea"
                        value={value}
                        onChange={onChange}
                        onKeyDown={handleKeyDown}
                        onScroll={handleScroll}
                        placeholder={placeholder}
                        spellCheck={spellCheck}
                    />
                </div>
            );
        };

        // Structure Tree Component
        const TreeNode = ({ node, depth = 0, onSelect, selectedPath, currentPath = [], onEdit, onHover }) => {
            const [expanded, setExpanded] = useState(true);
            const hasChildren = node.children && node.children.length > 0;
            const isSelected = JSON.stringify(currentPath) === JSON.stringify(selectedPath);
            const canEdit = !hasChildren && node.length > 0;
            
            // Format the size display
            const sizeDisplay = node.length === 1 ? '1 byte' : `${node.length} bytes`;
            
            return (
                <div>
                    <div
                        className={`tree-node ${hasChildren ? 'expandable' : ''} ${expanded ? 'expanded' : ''} ${isSelected ? 'selected' : ''}`}
                        onMouseEnter={() => onHover && onHover(node)}
                        onMouseLeave={() => onHover && onHover(null)}
                    >
                        <div
                            onClick={(e) => {
                                e.stopPropagation();
                                if (hasChildren) {
                                    setExpanded(!expanded);
                                }
                                onSelect(node, currentPath);
                            }}
                            style={{ flex: 1, display: 'flex', flexDirection: 'column' }}
                        >
                            <div className="flex items-center justify-between">
                                <span className="font-semibold text-blue-400">{node.name}</span>
                                <span className="text-xs text-gray-500">
                                    @0x{node.offset.toString(16).padStart(4, '0')} ({sizeDisplay})
                                </span>
                            </div>
                            {node.value !== null && node.value !== undefined && (
                                <div className="text-sm text-gray-300 mt-1 ml-4">
                                    {node.value}
                                </div>
                            )}
                        </div>
                        
                        {canEdit && (
                            <div style={{ display: 'flex', gap: '4px', position: 'relative' }}>
                                <button
                                    className="edit-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        onEdit(node);
                                    }}
                                    title="Edit field value"
                                >
                                    ‚úèÔ∏è Edit
                                </button>
                                <button
                                    className="edit-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        // Toggle export menu
                                        const menu = e.currentTarget.nextElementSibling;
                                        if (menu) {
                                            // Close all other menus first
                                            document.querySelectorAll('.export-menu').forEach(m => {
                                                if (m !== menu) m.style.display = 'none';
                                            });
                                            menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
                                        }
                                    }}
                                    title="Export field data"
                                >
                                    üíæ
                                </button>
                                <div 
                                    className="export-menu"
                                    style={{ display: 'none' }}
                                    onClick={(e) => e.stopPropagation()}
                                >
                                    <button onClick={(e) => {
                                        e.stopPropagation();
                                        e.currentTarget.parentElement.style.display = 'none';
                                        if (window.onExportField) {
                                            window.onExportField(node, 'python');
                                        }
                                    }}>üìã Copy Python bytes</button>
                                    <button onClick={(e) => {
                                        e.stopPropagation();
                                        e.currentTarget.parentElement.style.display = 'none';
                                        if (window.onExportField) {
                                            window.onExportField(node, 'file');
                                        }
                                    }}>üíæ Save as file</button>
                                </div>
                            </div>
                        )}
                    </div>
                    {hasChildren && expanded && (
                        <div className="tree-children">
                            {node.children.map((child, idx) => (
                                <TreeNode
                                    key={idx}
                                    node={child}
                                    depth={depth + 1}
                                    onSelect={onSelect}
                                    selectedPath={selectedPath}
                                    currentPath={[...currentPath, idx]}
                                    onEdit={onEdit}
                                    onHover={onHover}
                                />
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const StructureTree = ({ fields, onFieldSelect, selectedField, onFieldEdit, onFieldHover }) => {
            const [selectedPath, setSelectedPath] = useState(null);
            
            const handleSelect = (node, path) => {
                setSelectedPath(path);
                onFieldSelect(node);
            };
            
            return (
                <div className="space-y-1">
                    {fields.length === 0 ? (
                        <div className="text-gray-500 p-4 text-center">
                            No structure parsed yet. Define a Construct structure and click Parse.
                        </div>
                    ) : (
                        fields.map((field, idx) => (
                            <TreeNode
                                key={idx}
                                node={field}
                                onSelect={handleSelect}
                                selectedPath={selectedPath}
                                currentPath={[idx]}
                                onEdit={onFieldEdit}
                                onHover={onFieldHover}
                            />
                        ))
                    )}
                </div>
            );
        };

        // Main App Component
        const BinTVApp = () => {
            const [fileData, setFileData] = useState(null);
            const [originalFileData, setOriginalFileData] = useState(null);
            const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
            const [fileName, setFileName] = useState('');
            const [structDef, setStructDef] = useState(`# Define your Construct structure here
# Example:
format_struct = Struct(
    "magic" / Bytes(4),
    "version" / Int16ul,
    "size" / Int32ul,
    "data" / Bytes(8),
    "checksum" / Int32ul,
)`);
            const [parsedFields, setParsedFields] = useState([]);
            const [selectedField, setSelectedField] = useState(null);
            const [hoveredField, setHoveredField] = useState(null);
            const [highlightRanges, setHighlightRanges] = useState([]);
            const [isLoading, setIsLoading] = useState(true);
            const [isParsing, setIsParsing] = useState(false);
            const [error, setError] = useState(null);
            const [parseStatus, setParseStatus] = useState('');
            const [editingField, setEditingField] = useState(null);
            
            // Build mode state
            const [isBuildMode, setIsBuildMode] = useState(false);
            const [buildValues, setBuildValues] = useState({});
            
            // PCAP-specific state
            const [isPcapFile, setIsPcapFile] = useState(false);
            const [pcapPackets, setPcapPackets] = useState([]);
            const [currentPacketIndex, setCurrentPacketIndex] = useState(0);
            const [originalPcapData, setOriginalPcapData] = useState(null);
            
            const fileInputRef = useRef(null);
            const parseTimeoutRef = useRef(null);

            useEffect(() => {
                initPyodide().then(() => {
                    setIsLoading(false);
                    setParseStatus('>>> Python environment ready');
                    
                    // Check URL parameters for template
                    const urlParams = new URLSearchParams(window.location.search);
                    const template = urlParams.get('template');
                    if (template && CONSTRUCT_LIBRARY[template]) {
                        setStructDef(CONSTRUCT_LIBRARY[template].code);
                        setParseStatus(`>>> Loaded template: ${CONSTRUCT_LIBRARY[template].name}`);
                    }
                }).catch(err => {
                    setError('Failed to initialize Pyodide: ' + err.message);
                    setIsLoading(false);
                });
            }, []);

            // Reactive parsing with debounce
            useEffect(() => {
                if (!fileData || !pyodideReady) return;
                
                // Check if structDef has actual content (not just comments)
                const hasRealContent = structDef.split('\n').some(line => {
                    const trimmed = line.trim();
                    return trimmed && !trimmed.startsWith('#');
                });
                
                if (!hasRealContent) return;
                
                // For PCAP files, parse immediately when packet changes (no debounce)
                if (isPcapFile) {
                    handleParse();
                    return;
                }
                
                // For regular files, use debounced parsing
                // Clear previous timeout
                if (parseTimeoutRef.current) {
                    clearTimeout(parseTimeoutRef.current);
                }
                
                // Set new timeout for debounced parsing
                parseTimeoutRef.current = setTimeout(() => {
                    handleParse();
                }, 500); // Parse 500ms after user stops typing
                
                return () => {
                    if (parseTimeoutRef.current) {
                        clearTimeout(parseTimeoutRef.current);
                    }
                };
            }, [structDef, fileData, pyodideReady, isPcapFile]);

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                setFileName(file.name);
                setParseStatus(`>>> Loading file: ${file.name}`);
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    const arrayBuffer = e.target.result;
                    const uint8Array = new Uint8Array(arrayBuffer);
                    
                    // Check if it's a PCAP file by magic number (more reliable than extension)
                    let isPcap = false;
                    if (uint8Array.length >= 4) {
                        const view = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
                        const magic = view.getUint32(0, true);  // Try little-endian
                        const magicBE = view.getUint32(0, false); // Try big-endian
                        
                        // PCAP: 0xa1b2c3d4 (LE) or 0xd4c3b2a1 (BE)
                        // PCAPNG: 0x0A0D0D0A
                        isPcap = (magic === 0xa1b2c3d4 || magicBE === 0xd4c3b2a1 || magic === 0x0A0D0D0A);
                        
                        if (!isPcap) {
                            // Also check file extension as fallback
                            const fileName = file.name.toLowerCase();
                            isPcap = fileName.endsWith('.pcap') || fileName.endsWith('.pcapng');
                        }
                    }
                    
                    if (isPcap) {
                        try {
                            const packets = parsePcap(uint8Array);
                            setIsPcapFile(true);
                            setPcapPackets(packets);
                            setOriginalPcapData(uint8Array);
                            setCurrentPacketIndex(0);
                            
                            // Load first packet
                            if (packets.length > 0) {
                                setFileData(packets[0].data);
                                setOriginalFileData(new Uint8Array(packets[0].data));
                                setParseStatus(`>>> PCAP loaded: ${packets.length} packets, showing packet 0 (${packets[0].data.length} bytes)`);
                            } else {
                                setParseStatus(`>>> PCAP loaded but contains no packets`);
                            }
                        } catch (err) {
                            console.error('PCAP parsing error:', err);
                            setParseStatus(`>>> PCAP parse error: ${err.message}`);
                            // Fall back to loading as regular binary
                            setIsPcapFile(false);
                            setFileData(uint8Array);
                            setOriginalFileData(new Uint8Array(uint8Array));
                        }
                    } else {
                        // Regular binary file
                        setIsPcapFile(false);
                        setPcapPackets([]);
                        setFileData(uint8Array);
                        setOriginalFileData(new Uint8Array(uint8Array));
                        setHasUnsavedChanges(false);
                        setParseStatus(`>>> File loaded: ${uint8Array.length} bytes`);
                    }
                };
                
                reader.readAsArrayBuffer(file);
            };
            
            // PCAP parsing function
            const parsePcap = (data) => {
                const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
                const packets = [];
                
                // Check magic number to determine format
                const magic = view.getUint32(0, true);
                const magicBE = view.getUint32(0, false);
                
                // PCAPNG format: 0x0A0D0D0A
                if (magic === 0x0A0D0D0A) {
                    console.log('PCAPNG format detected');
                    return parsePcapNG(data, view);
                }
                
                // PCAP format
                const isLittleEndian = magic === 0xa1b2c3d4;
                const isBigEndian = magicBE === 0xd4c3b2a1;
                
                if (!isLittleEndian && !isBigEndian) {
                    throw new Error('Not a valid PCAP/PCAPNG file (invalid magic number)');
                }
                
                let offset = 24;
                let packetNum = 0;
                
                while (offset + 16 <= data.length) {
                    const ts_sec = view.getUint32(offset, isLittleEndian);
                    const ts_usec = view.getUint32(offset + 4, isLittleEndian);
                    const incl_len = view.getUint32(offset + 8, isLittleEndian);
                    const orig_len = view.getUint32(offset + 12, isLittleEndian);
                    
                    offset += 16;
                    
                    if (offset + incl_len > data.length) break;
                    
                    const packetData = new Uint8Array(data.buffer, data.byteOffset + offset, incl_len);
                    
                    packets.push({
                        index: packetNum,
                        timestamp: ts_sec + ts_usec / 1000000,
                        capturedLength: incl_len,
                        originalLength: orig_len,
                        data: packetData,
                        offset: offset
                    });
                    
                    offset += incl_len;
                    packetNum++;
                }
                return packets;
            };
            
            const parsePcapNG = (data, view) => {
                const packets = [];
                let offset = 0;
                let packetNum = 0;
                
                while (offset + 12 <= data.length) {
                    const blockType = view.getUint32(offset, true);
                    const blockLen = view.getUint32(offset + 4, true);
                    
                    if (blockLen < 12 || offset + blockLen > data.length) break;
                    
                    if (blockType === 0x00000006) { // Enhanced Packet Block
                        const capturedLen = view.getUint32(offset + 20, true);
                        const originalLen = view.getUint32(offset + 24, true);
                        const dataOffset = offset + 28;
                        
                        if (dataOffset + capturedLen <= offset + blockLen) {
                            const packetData = new Uint8Array(data.buffer, data.byteOffset + dataOffset, capturedLen);
                            packets.push({
                                index: packetNum,
                                timestamp: 0, 
                                capturedLength: capturedLen,
                                originalLength: originalLen,
                                data: packetData,
                                offset: dataOffset
                            });
                            packetNum++;
                        }
                    } else if (blockType === 0x00000003) { // Simple Packet Block
                        const originalLen = view.getUint32(offset + 8, true);
                        const capturedLen = Math.min(originalLen, blockLen - 16);
                        const dataOffset = offset + 12;
                        
                        if (dataOffset + capturedLen <= offset + blockLen) {
                            const packetData = new Uint8Array(data.buffer, data.byteOffset + dataOffset, capturedLen);
                            packets.push({
                                index: packetNum,
                                timestamp: 0,
                                capturedLength: capturedLen,
                                originalLength: originalLen,
                                data: packetData,
                                offset: dataOffset
                            });
                            packetNum++;
                        }
                    }
                    offset += blockLen;
                }
                return packets;
            };
            
            const handlePacketChange = (newIndex) => {
                if (!isPcapFile || newIndex < 0 || newIndex >= pcapPackets.length) return;
                
                const packet = pcapPackets[newIndex];
                setCurrentPacketIndex(newIndex);
                setFileData(packet.data);
                setOriginalFileData(new Uint8Array(packet.data));
                setHasUnsavedChanges(false);
                setParseStatus(`>>> Showing packet ${newIndex} of ${pcapPackets.length - 1} (${packet.data.length} bytes)`);
            };

            const flattenFields = (fields, list = []) => {
                fields.forEach((field, topLevelIndex) => {
                    list.push({
                        offset: field.offset,
                        length: field.length,
                        topLevelIndex: topLevelIndex,
                        name: field.name,
                        value: field.value
                    });
                    if (field.children) {
                        flattenFieldsNested(field.children, list, topLevelIndex, field.name);
                    }
                });
                return list;
            };
            
            const flattenFieldsNested = (fields, list, topLevelIndex, parentName) => {
                fields.forEach(field => {
                    list.push({
                        offset: field.offset,
                        length: field.length,
                        topLevelIndex: topLevelIndex,
                        name: parentName + '.' + field.name,
                        value: field.value
                    });
                    if (field.children) {
                        flattenFieldsNested(field.children, list, topLevelIndex, parentName + '.' + field.name);
                    }
                });
            };

            const handleParse = async (isAuto = false) => {
                if (!fileData || !pyodideReady) return;
                
                if (!isAuto) setError(null);
                if (!isAuto) setParseStatus('>>> Parsing structure...');
                
                setIsParsing(true);
                
                try {
                    const fields = await parseWithConstruct(fileData, structDef);
                    setParsedFields(fields);
                    setHighlightRanges(flattenFields(fields));
                    setParseStatus(`>>> Parse complete: ${fields.length} fields`);
                    setError(null);
                    
                } catch (err) {
                    console.warn('Parse failed:', err.message);
                    if (isAuto) {
                        setParseStatus('>>> ...'); 
                    } else {
                        setError(err.message);
                        setParsedFields([]);
                        setHighlightRanges([]);
                        setParseStatus('>>> Parse error');
                    }
                } finally {
                    setIsParsing(false);
                }
            };

            const handleFieldSelect = (field) => { setSelectedField(field); };
            const handleFieldHover = (field) => { setHoveredField(field); };
            const handleFieldEdit = (field) => { setEditingField(field); };
            
            // Expose to window for menu callbacks
            useEffect(() => {
                window.onExportField = (field, format) => {
                    if (!fileData || !field || field.length === 0) return;
                    const fieldBytes = fileData.slice(field.offset, field.offset + field.length);
                    
                    if (format === 'python') {
                        const hexBytes = Array.from(fieldBytes)
                            .map(b => '\\x' + b.toString(16).padStart(2, '0'))
                            .join('');
                        const pythonCode = `b"${hexBytes}"`;
                        navigator.clipboard.writeText(pythonCode).then(() => {
                            setParseStatus(`>>> Copied ${field.name} as Python bytes`);
                        });
                    } else if (format === 'file') {
                        const blob = new Blob([fieldBytes], { type: 'application/octet-stream' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        const safeFieldName = field.name.replace(/[^a-zA-Z0-9_-]/g, '_');
                        a.download = `${fileName}_${safeFieldName}.bin`;
                        a.click();
                        URL.revokeObjectURL(url);
                        setParseStatus(`>>> Exported ${field.name} to file`);
                    }
                };
            }, [fileData, fileName]);

            useEffect(() => {
                if (!fileData || !pyodideReady) return;
                
                const hasRealContent = structDef.split('\n').some(line => {
                    const trimmed = line.trim();
                    return trimmed && !trimmed.startsWith('#');
                });
                
                if (!hasRealContent) return;
                
                if (isPcapFile) {
                    handleParse(true);
                    return;
                }
                
                if (parseTimeoutRef.current) clearTimeout(parseTimeoutRef.current);
                
                parseTimeoutRef.current = setTimeout(() => {
                    handleParse(true);
                }, 500);
                
                return () => {
                    if (parseTimeoutRef.current) clearTimeout(parseTimeoutRef.current);
                };
            }, [structDef, fileData, pyodideReady, isPcapFile]);
            
            const handleSaveEdit = (offset, newBytes) => {
                const newData = new Uint8Array(fileData);
                newData.set(newBytes, offset);
                setFileData(newData);
                setHasUnsavedChanges(true);
                setParseStatus(`>>> Field edited at 0x${offset.toString(16)}`);
                setTimeout(() => handleParse(), 100);
            };
            
            const handleSaveFile = () => {
                if (!fileData) return;
                const blob = new Blob([fileData], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName.replace(/(\.[^.]+)?$/, '_modified$1');
                a.click();
                URL.revokeObjectURL(url);
                setHasUnsavedChanges(false);
                setOriginalFileData(new Uint8Array(fileData));
                setParseStatus('>>> File saved');
            };
            
            const handleResetChanges = () => {
                if (originalFileData) {
                    setFileData(new Uint8Array(originalFileData));
                    setHasUnsavedChanges(false);
                    setParseStatus('>>> Changes reset');
                    setTimeout(() => handleParse(), 100);
                }
            };
            
            const toggleBuildMode = () => {
                const newMode = !isBuildMode;
                setIsBuildMode(newMode);
                if (newMode) {
                    setParseStatus('>>> üî® Build Mode: Create binary from template');
                    setBuildValues({});
                } else {
                    setParseStatus('>>> Parse Mode');
                }
            };

            // --- üåü NEON HUD EXPORT ENGINE (No Lines) üåü ---

            const handleExportSVG = async () => {
                if (!fileData || parsedFields.length === 0) {
                    alert('Please load a file and parse it first!');
                    return;
                }

                if (typeof JSZip === 'undefined') {
                    const loadLib = confirm("This feature requires JSZip. Load it from CDN now?");
                    if (loadLib) {
                        await new Promise((resolve) => {
                            const script = document.createElement('script');
                            script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
                            script.onload = resolve;
                            document.head.appendChild(script);
                        });
                    } else return;
                }

                const shouldFragment = confirm("üì¶ Export Mode:\n\nOK = Fragment large nested structures into a ZIP (Best for complex files)\nCancel = Single SVG Overview (Best for small headers)");

                setParseStatus('>>> Generating Neon Export...');

                if (shouldFragment) {
                    await generateFragmentedZip(fileData, parsedFields);
                } else {
                    const svgString = generateNeonSVG(fileData, parsedFields, fileName, "Master View");
                    downloadBlob(svgString, `${fileName}_neon_hud.svg`, 'image/svg+xml');
                }
                
                setParseStatus('>>> Export complete');
            };

            const downloadBlob = (content, filename, type) => {
                const blob = new Blob([content], { type: type });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            };

            const generateFragmentedZip = async (data, fields) => {
                const zip = new JSZip();
                
                // 1. Master Overview
                const mainFields = fields.map(f => ({ ...f, children: [] })); 
                const mainSvg = generateNeonSVG(data, mainFields, fileName, "Overview Map");
                zip.file("00_Overview.svg", mainSvg);

                // 2. Fragment Children
                fields.forEach((field, idx) => {
                    const safeName = field.name.replace(/[^a-z0-9]/gi, '_');
                    const prefix = (idx + 1).toString().padStart(2, '0');
                    const fieldData = data.slice(field.offset, field.offset + field.length);
                    
                    const adjustOffsets = (nodes, subtract) => {
                        return nodes.map(n => ({
                            ...n,
                            offset: n.offset - subtract,
                            children: n.children ? adjustOffsets(n.children, subtract) : []
                        }));
                    };

                    const relativeChildren = adjustOffsets(field.children || [], field.offset);
                    
                    if (relativeChildren.length > 0) {
                        const fragSvg = generateNeonSVG(fieldData, relativeChildren, field.name, `Fragment ${prefix}`);
                        zip.file(`${prefix}_${safeName}.svg`, fragSvg);
                    }
                });

                const content = await zip.generateAsync({ type: "blob" });
                downloadBlob(content, `${fileName}_Neon_Export.zip`, "application/zip");
            };

            // --- üé® NEON HUD RENDERER (Color-Mapped) üé® ---
            const generateNeonSVG = (data, fields, title, subtitle) => {
                // Config
                const CONFIG = {
                    hexX: 40,
                    hexY: 100,
                    treeX: 520, // Moved right slightly for separation
                    rowHeight: 22,
                    bytesPerRow: 16,
                    maxRows: 128,
                    colors: [
                        '#00f3ff', // Cyan
                        '#bc13fe', // Neon Purple
                        '#00ff9d', // Matrix Green
                        '#ff0055', // Cyber Red
                        '#fcee0a', // Electric Yellow
                        '#4d4dff', // Deep Blue
                        '#ff9e00'  // Orange
                    ]
                };

                // 1. Calculate Dimensions & Flatten Tree
                const totalRows = Math.ceil(data.length / CONFIG.bytesPerRow);
                const displayRows = Math.min(totalRows, CONFIG.maxRows);
                const hexHeight = displayRows * CONFIG.rowHeight;
                
                let renderList = [];
                const flatten = (nodes, depth=0) => {
                    nodes.forEach(node => {
                        renderList.push({ node, depth });
                        if (node.children && node.children.length > 0) {
                            flatten(node.children, depth + 1);
                        }
                    });
                };
                flatten(fields);
                
                const treeHeight = renderList.length * 28;
                const totalHeight = Math.max(hexHeight, treeHeight) + 150;
                const width = 1100;

                // 2. SVG Header with Glow Filters
                let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${width}" height="${totalHeight}" viewBox="0 0 ${width} ${totalHeight}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&amp;display=swap');
      text { font-family: 'JetBrains Mono', monospace; }
      .bg { fill: #090a0f; }
      
      /* Hex Styles */
      .hex-byte { font-size: 12px; fill: #404550; } /* Dimmed default */
      .hex-active { font-weight: bold; filter: url(#textGlow); }
      .hex-offset { font-size: 10px; fill: #30363d; }
      
      /* Tree Styles */
      .tree-label { font-size: 13px; font-weight: bold; }
      .tree-val { font-size: 12px; fill: #8b949e; }
      .tree-meta { font-size: 10px; opacity: 0.6; fill: #8b949e; }
      
      /* Headers */
      .title { font-size: 24px; font-weight: bold; fill: #fff; filter: url(#headerGlow); }
      .subtitle { font-size: 14px; fill: #00f3ff; opacity: 0.8; }
    </style>
    
    <filter id="headerGlow" x="-20%" y="-20%" width="140%" height="140%">
      <feGaussianBlur stdDeviation="2" result="blur" />
      <feComposite in="SourceGraphic" in2="blur" operator="over" />
    </filter>
    
    <filter id="textGlow" x="-20%" y="-20%" width="140%" height="140%">
      <feGaussianBlur stdDeviation="1" result="blur" />
      <feComposite in="SourceGraphic" in2="blur" operator="over" />
    </filter>
    
    <linearGradient id="lineGrad" x1="0%" y1="0%" x2="100%" y2="0%">
       <stop offset="0%" style="stop-color:#090a0f;stop-opacity:0" />
       <stop offset="50%" style="stop-color:#ffffff;stop-opacity:0.3" />
       <stop offset="100%" style="stop-color:#090a0f;stop-opacity:0" />
    </linearGradient>
  </defs>
  
  <rect width="100%" height="100%" class="bg"/>
  
  <g transform="translate(40, 50)">
    <text x="0" y="0" class="title">${title}</text>
    <text x="0" y="24" class="subtitle">// ${subtitle} [${data.length} bytes]</text>
    <line x1="0" y1="35" x2="${width-80}" y2="35" stroke="url(#lineGrad)" stroke-width="1"/>
  </g>
`;

                // 3. Render Hex Grid (Left Side)
                let hexSvg = `<g transform="translate(${CONFIG.hexX}, ${CONFIG.hexY})">`;
                
                // Color Mapping Logic:
                // Map every byte index to a color based on its top-level field parent
                const byteColors = new Map();
                fields.forEach((f, i) => {
                    const color = CONFIG.colors[i % CONFIG.colors.length];
                    // Map this color to all bytes in this field's range
                    for(let b = 0; b < f.length; b++) {
                        const globalIdx = f.offset + b;
                        if (globalIdx < data.length) {
                             byteColors.set(globalIdx, color);
                        }
                    }
                });

                for (let r = 0; r < displayRows; r++) {
                    const offset = r * CONFIG.bytesPerRow;
                    const y = r * CONFIG.rowHeight;
                    
                    // Row offset label
                    hexSvg += `<text x="-12" y="${y+14}" class="hex-offset" text-anchor="end">${offset.toString(16).padStart(4,'0').toUpperCase()}</text>`;

                    for (let c = 0; c < CONFIG.bytesPerRow; c++) {
                        const idx = offset + c;
                        if (idx >= data.length) break;
                        
                        const byteVal = data[idx].toString(16).padStart(2,'0').toUpperCase();
                        const color = byteColors.get(idx);
                        const x = c * 24; // slightly wider spacing for readability
                        
                        if (color) {
                            // 1. Background Glow Box (Subtle)
                            hexSvg += `<rect x="${x-2}" y="${y+2}" width="22" height="16" fill="${color}" fill-opacity="0.1" rx="2"/>`;
                            
                            // 2. Colored Byte Text (Neon)
                            hexSvg += `<text x="${x+9}" y="${y+14}" font-family="monospace" font-size="12" fill="${color}" text-anchor="middle" class="hex-active">${byteVal}</text>`;
                        } else {
                            // 3. Unmapped Byte (Gray)
                            hexSvg += `<text x="${x+9}" y="${y+14}" class="hex-byte" text-anchor="middle">${byteVal}</text>`;
                        }
                    }
                }
                
                if (displayRows < totalRows) {
                    hexSvg += `<text x="0" y="${hexHeight + 20}" fill="#505565" font-style="italic">... ${totalRows - displayRows} more rows truncated ...</text>`;
                }
                hexSvg += `</g>`;

                // 4. Render Structure Tree (Right Side)
                // Now relies on color matching instead of lines
                let treeSvg = `<g transform="translate(${CONFIG.treeX}, ${CONFIG.hexY})">`;
                let currentY = 0;

                renderList.forEach((item) => {
                    const { node, depth } = item;
                    
                    // Determine Color: Find the Top-Level Parent Index
                    const topIndex = fields.findIndex(f => node.offset >= f.offset && (node.offset + node.length) <= (f.offset + f.length));
                    const color = CONFIG.colors[Math.max(0, topIndex) % CONFIG.colors.length];
                    
                    const indent = depth * 20;
                    
                    // Row Background Strip (Very subtle)
                    treeSvg += `<rect x="0" y="${currentY}" width="540" height="24" fill="${color}" fill-opacity="${0.03}" rx="0"/>`;
                    
                    // Color Key Marker (The "Neon Bar" on the left)
                    // This explicitly links the row to the color in the hex dump
                    treeSvg += `<rect x="${indent}" y="${currentY+4}" width="3" height="16" fill="${color}" rx="1"/>`;
                    
                    // Hierarchy Lines (Dimmed)
                    if (depth > 0) {
                         // L-shape connector for nested items
                         const parentX = (depth - 1) * 20;
                         treeSvg += `<path d="M ${parentX} ${currentY-10} L ${parentX} ${currentY+12} L ${indent-5} ${currentY+12}" stroke="${color}" stroke-opacity="0.3" fill="none"/>`;
                    }

                    // Field Name (Colored)
                    treeSvg += `<text x="${indent + 10}" y="${currentY + 16}" class="tree-label" fill="${color}">${node.name}</text>`;
                    
                    // Field Value
                    let valStr = String(node.value || '');
                    if (valStr.length > 35) valStr = valStr.substring(0, 32) + '...';
                    treeSvg += `<text x="300" y="${currentY + 16}" class="tree-val">${valStr}</text>`;
                    
                    // Meta Info (Offset/Size)
                    treeSvg += `<text x="530" y="${currentY + 16}" class="tree-meta" text-anchor="end">@0x${node.offset.toString(16).toUpperCase()}</text>`;

                    currentY += 28;
                });
                treeSvg += `</g>`;

                svg += hexSvg;
                svg += treeSvg;
                svg += `</svg>`;

                return svg;
            };

            const loadSampleFile = () => {
                const sample = new Uint8Array([
                    0x50, 0x4B, 0x03, 0x04, 0x14, 0x00, 0x00, 0x00, 
                    0x08, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6C, 0x6C, 
                    0x6F, 0x20, 0x57, 0x6F, 0xDE, 0xAD, 0xBE, 0xEF
                ]);
                setFileData(sample);
                setOriginalFileData(new Uint8Array(sample));
                setHasUnsavedChanges(false);
                setFileName('sample.bin');
                setParseStatus(`>>> Sample loaded: ${sample.length} bytes`);
                setStructDef(`# Sample ZIP-like structure
format_struct = Struct(
    "magic" / Bytes(4),
    "version" / Int16ul,
    "flags" / Int16ul,
    "size" / Int32ul,
    "data" / Bytes(8),
    "checksum" / Int32ul,
)`);
            };

            if (isLoading) {
                return (
                    <div className="h-screen flex items-center justify-center" style={{ background: '#0d1117' }}>
                        <div className="text-center">
                            <div className="loading-spinner mx-auto mb-4"></div>
                            <h2 className="text-2xl font-semibold" style={{ color: '#58a6ff' }}>Initializing Python Environment</h2>
                            <p className="mt-2 text-base" style={{ color: '#8b949e' }}>Loading Pyodide and Construct library...</p>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-screen flex flex-col" style={{ background: '#0d1117' }}>
                    {editingField && (
                        <EditModal
                            field={editingField}
                            onClose={() => setEditingField(null)}
                            onSave={handleSaveEdit}
                        />
                    )}
                    
                    <header className="terminal-border p-4" style={{ background: '#161b22' }}>
                        <div className="flex items-center justify-between">
                            <div className="flex items-center space-x-4">
                                <h1 className="text-2xl font-semibold" style={{ color: '#58a6ff' }}>BinTV</h1>
                                <span className="text-sm opacity-70">Binary Structure Viewer v1.0</span>
                                {hasUnsavedChanges && (
                                    <span className="text-sm px-2 py-1 rounded" style={{ background: '#f6ad55', color: '#000' }}>‚Ä¢ Modified</span>
                                )}
                            </div>
                            
                            <div className="flex items-center space-x-2">
                                <button onClick={loadSampleFile} disabled={isLoading} className="px-4 py-2 btn-terminal rounded">Sample</button>
                                <input type="file" ref={fileInputRef} onChange={handleFileUpload} accept="*,.pcap,.pcapng" />
                                <button onClick={() => fileInputRef.current?.click()} disabled={isLoading} className="px-4 py-2 btn-terminal rounded">Open File</button>
                                <button onClick={toggleBuildMode} disabled={isLoading || isPcapFile} className="px-4 py-2 btn-terminal rounded" style={isBuildMode ? { background: '#238636', borderColor: '#2ea043', color: '#fff' } : {}} title="Build binary from template">
                                    {isBuildMode ? 'üî® Build Mode' : 'üî® Build'}
                                </button>
                                {hasUnsavedChanges && (
                                    <>
                                        <button onClick={handleResetChanges} className="px-4 py-2 btn-terminal rounded" title="Reset all changes">Reset</button>
                                        <button onClick={handleSaveFile} className="px-4 py-2 btn-terminal rounded" title="Save modified file">Save File</button>
                                    </>
                                )}
                                <button onClick={handleExportSVG} disabled={!fileData || parsedFields.length === 0 || isLoading} className="px-4 py-2 btn-terminal rounded">Export SVG</button>
                            </div>
                        </div>
                        
                        {isPcapFile && pcapPackets.length > 0 && (
                            <div className="mb-4 p-3 rounded" style={{ background: '#161b22', border: '1px solid #30363d' }}>
                                <div className="flex items-center justify-between mb-2">
                                    <div className="flex items-center gap-2">
                                        <span className="text-sm font-semibold" style={{ color: '#58a6ff' }}>üì¶ PCAP Mode</span>
                                        <span className="text-xs opacity-70">{pcapPackets.length} packets total</span>
                                    </div>
                                </div>
                                <div className="flex items-center justify-between gap-3">
                                    <div className="flex items-center gap-2">
                                        <button className="px-2 py-1 text-xs rounded btn-terminal" onClick={() => handlePacketChange(0)} disabled={currentPacketIndex === 0}>‚èÆ First</button>
                                        <button className="px-2 py-1 text-xs rounded btn-terminal" onClick={() => handlePacketChange(currentPacketIndex - 1)} disabled={currentPacketIndex === 0}>‚óÄ Prev</button>
                                        <span className="text-sm font-mono px-3" style={{ color: '#58a6ff' }}>Packet {currentPacketIndex} / {pcapPackets.length - 1}</span>
                                        <button className="px-2 py-1 text-xs rounded btn-terminal" onClick={() => handlePacketChange(currentPacketIndex + 1)} disabled={currentPacketIndex >= pcapPackets.length - 1}>Next ‚ñ∂</button>
                                        <button className="px-2 py-1 text-xs rounded btn-terminal" onClick={() => handlePacketChange(pcapPackets.length - 1)} disabled={currentPacketIndex >= pcapPackets.length - 1}>Last ‚è≠</button>
                                        <span className="text-xs opacity-50 px-2">|</span>
                                        <span className="text-xs opacity-70">Go to:</span>
                                        <input type="number" className="w-20 px-2 py-1 text-xs rounded" style={{ background: '#0d1117', border: '1px solid #30363d', color: '#c9d1d9' }} min="0" max={pcapPackets.length - 1} value={currentPacketIndex} onChange={(e) => handlePacketChange(parseInt(e.target.value) || 0)} />
                                    </div>
                                    <div className="text-xs opacity-70">Captured: {pcapPackets[currentPacketIndex].capturedLength}B ‚Ä¢ Original: {pcapPackets[currentPacketIndex].originalLength}B</div>
                                </div>
                            </div>
                        )}
                        
                        <div className="mt-2 text-sm flex items-center justify-between">
                            <div>
                                {fileName && (
                                    <>
                                        <span style={{ color: '#58a6ff' }}>File:</span>
                                        <span className="ml-2">{fileName}</span>
                                        {fileData && (
                                            <span className="ml-4">
                                                <span style={{ color: '#58a6ff' }}>Size:</span>
                                                <span className="ml-2">{fileData.length} bytes</span>
                                            </span>
                                        )}
                                    </>
                                )}
                            </div>
                            <div className="flex items-center space-x-2">
                                {isParsing && <span style={{ color: '#f6ad55' }}>Parsing...</span>}
                                {parseStatus && !isParsing && <span className="opacity-70">{parseStatus}</span>}
                            </div>
                        </div>
                    </header>

                    <div className="flex-1 flex overflow-hidden">
                        <div className="w-1/3 flex flex-col panel" style={{ borderRight: '1px solid #30363d' }}>
                            <div className="terminal-title flex items-center justify-between">
                                <span>Construct Structure Definition</span>
                                <div className="flex items-center space-x-2">
                                    {isParsing && <span style={{ color: '#f6ad55', fontSize: '12px' }}>{isBuildMode ? 'Building...' : 'Parsing...'}</span>}
                                    {!isBuildMode && (
                                        <button onClick={() => handleParse(false)} disabled={!fileData || !pyodideReady || isParsing} className="px-3 py-1 btn-terminal rounded" title="Manual parse (shows errors)">Parse</button>
                                    )}
                                </div>
                            </div>
                            
                            <div className="p-2" style={{ borderBottom: '1px solid #30363d', background: '#161b22' }}>
                                <div className="flex items-center gap-2 mb-2">
                                    <label className="text-xs" style={{ color: '#8b949e' }}>Load Template:</label>
                                    <div className="flex-1 flex items-center gap-1">
                                        <select className="flex-1 px-2 py-1 text-xs rounded" style={{ background: '#0d1117', border: '1px solid #30363d', color: '#c9d1d9', cursor: 'pointer' }} onChange={(e) => {
                                                const templateKey = e.target.value;
                                                if (templateKey && CONSTRUCT_LIBRARY[templateKey]) {
                                                    const template = CONSTRUCT_LIBRARY[templateKey];
                                                    setStructDef(template.code);
                                                    setParseStatus(`>>> Loaded: ${template.name}`);
                                                    setError(null);
                                                    e.target.value = "";
                                                }
                                            }} value="">
                                            <option value="">-- Select a template --</option>
                                            <optgroup label="üì° Network - Full Stack">
                                                <option value="full_tcp">Full TCP Packet (Eth+IP+TCP)</option>
                                                <option value="full_udp">Full UDP Packet (Eth+IP+UDP)</option>
                                                <option value="full_dns">Full DNS Packet (Eth+IP+UDP+DNS)</option>
                                                <option value="full_dhcp">Full DHCP Packet (Eth+IP+UDP+DHCP)</option>
                                                <option value="full_arp">Full ARP Packet (Eth+ARP)</option>
                                            </optgroup>
                                            <optgroup label="üìÅ Files - Executables & Archives">
                                                <option value="elf">ELF Header (64-bit)</option>
                                                <option value="pe">PE Header (Windows)</option>
                                                <option value="zip">ZIP Local File Header</option>
                                                <option value="gzip">GZIP Header</option>
                                                <option value="tar">TAR Header (POSIX)</option>
                                                <option value="png">PNG Chunk</option>
                                                <option value="jpeg">JPEG Segment</option>
                                            </optgroup>
                                            <optgroup label="üîß Firmware - Filesystems">
                                                <option value="squashfs">SquashFS Superblock</option>
                                                <option value="ext4">EXT2/3/4 Superblock</option>
                                                <option value="cpio">CPIO Archive (newc/initramfs)</option>
                                            </optgroup>
                                            <optgroup label="üí° Examples - Advanced Features">
                                                <option value="aes_encrypted">üîê AES Encrypted (EncryptedSym)</option>
                                                <option value="compressed_data">üóúÔ∏è Compressed (zlib)</option>
                                                <option value="checksummed">‚úì Checksummed (SHA256)</option>
                                                <option value="xor_encoded">üîÄ XOR Encoded (ProcessXor)</option>
                                                <option value="null_terminated">‚àÖ Null-Terminated String</option>
                                                <option value="prefixed_array">üìä Prefixed Array</option>
                                            </optgroup>
                                        </select>
                                    </div>
                                </div>
                                <div className="text-xs px-1" style={{ color: '#6e7681', lineHeight: '1.4' }}>
                                    üí° Templates support dynamic fields using <code>this.field.value</code> pattern (e.g., <code>Bytes(this.length.value)</code>)
                                </div>
                            </div>
                            
                            <div className="flex-1 flex flex-col">
                                <CodeEditor value={structDef} onChange={(e) => setStructDef(e.target.value)} placeholder="# Define Construct structure" spellCheck={false} />
                            </div>
                            
                            {error && (
                                <div className="m-2 error-box rounded">
                                    <div className="font-semibold mb-1" style={{ fontSize: '12px' }}>‚ö†Ô∏è Parse Error:</div>
                                    <pre className="whitespace-pre-wrap overflow-auto max-h-32" style={{ fontSize: '11px' }}>{error}</pre>
                                </div>
                            )}
                            
                            <div className="flex-1 overflow-hidden flex flex-col" style={{ borderTop: '1px solid #30363d' }}>
                                <div className="terminal-title">{isBuildMode ? 'üî® Build Values' : `Parsed Structure (${parsedFields.length})`}</div>
                                <div className={`flex-1 overflow-y-auto scrollbar-thin ${isBuildMode ? '' : 'p-2'}`}>
                                    {isBuildMode ? (
                                        <LiveBuilder pyodide={pyodide} structDef={structDef} onBuildComplete={(bytes, fields) => {
                                                setFileData(bytes);
                                                setParsedFields(fields);
                                                const flatten = (nodes, topIdx) => {
                                                    const list = [];
                                                    nodes.forEach(n => {
                                                        list.push({ offset: n.offset, length: n.length, topLevelIndex: topIdx });
                                                        if (n.children) list.push(...flatten(n.children, topIdx));
                                                    });
                                                    return list;
                                                };
                                                const ranges = [];
                                                fields.forEach((f, i) => ranges.push(...flatten([f], i)));
                                                setHighlightRanges(ranges);
                                            }}
                                        />
                                    ) : (
                                        <StructureTree fields={parsedFields} onFieldSelect={handleFieldSelect} selectedField={selectedField} onFieldEdit={handleFieldEdit} onFieldHover={handleFieldHover} />
                                    )}
                                </div>
                            </div>
                        </div>

                        <div className="flex-1 flex flex-col panel">
                            <div className="terminal-title">Hex Dump</div>
                            <div className="flex-1 overflow-hidden scrollbar-thin" style={{ background: '#0d1117' }}>
                                {fileData ? (
                                    <HexView data={fileData} highlightRanges={highlightRanges} selectedField={selectedField} hoveredField={hoveredField} />
                                ) : (
                                    <div className="h-full flex items-center justify-center">
                                        <div className="text-center">
                                            <div className="text-6xl mb-4" style={{ opacity: 0.3 }}>üìÅ</div>
                                            <h3 className="text-xl font-semibold mb-2" style={{ color: '#8b949e' }}>No file loaded</h3>
                                            <p style={{ color: '#6e7681', fontSize: '15px' }}>Click "Open File" or "Sample" to get started</p>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    <footer className="terminal-border p-2 text-center" style={{ background: '#161b22', opacity: 0.7, fontSize: '12px' }}>
                        <span>BinTV ‚Ä¢ Binary Structure Viewer ‚Ä¢ Powered by Pyodide &amp; Construct</span>
                    </footer>
                </div>
            );
        };

        ReactDOM.render(<BinTVApp />, document.getElementById('root'));

        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'o') {
                e.preventDefault();
                document.querySelector('input[type="file"]')?.click();
            }
        });
    </script>
</body>
</html>