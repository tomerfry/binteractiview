<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BinTV Web - Binary Structure Viewer (Focused Edition)</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap');
        
        body {
            margin: 0;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            background: #0d1117;
            color: #c9d1d9;
            overflow: hidden;
        }
        
        .terminal-border {
            border: 1px solid #30363d;
            box-shadow: 0 0 10px rgba(48, 54, 61, 0.3);
        }
        
        .terminal-glow {
            text-shadow: 0 0 2px rgba(88, 166, 255, 0.3);
        }
        
        .hex-cell {
            display: inline-block;
            padding: 2px 4px;
            margin: 0;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #8b949e;
            background: rgba(110, 118, 129, 0.05);
            font-size: 14px;
            position: relative;
        }
        
        .hex-cell:hover {
            background: rgba(88, 166, 255, 0.2);
            color: #58a6ff;
        }
        
        .hex-offset {
            color: #58a6ff;
            font-weight: 600;
            user-select: none;
            display: inline-block;
            width: 100px;
            font-size: 14px;
        }
        
        .ascii-char {
            display: inline-block;
            width: 1ch;
            text-align: center;
            color: #8b949e;
            opacity: 0.8;
            padding: 2px 1px;
            font-size: 14px;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .field-highlight-0 { 
            background: rgba(248, 81, 73, 0.4); 
            box-shadow: 0 0 8px rgba(248, 81, 73, 0.6), inset 0 0 4px rgba(248, 81, 73, 0.3);
            color: #ff9b97 !important;
        }
        .field-highlight-0.hovered {
            background: rgba(248, 81, 73, 0.7) !important;
            box-shadow: 0 0 16px rgba(248, 81, 73, 1), inset 0 0 8px rgba(248, 81, 73, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-1 { 
            background: rgba(246, 173, 85, 0.4); 
            box-shadow: 0 0 8px rgba(246, 173, 85, 0.6), inset 0 0 4px rgba(246, 173, 85, 0.3);
            color: #ffc98e !important;
        }
        .field-highlight-1.hovered {
            background: rgba(246, 173, 85, 0.7) !important;
            box-shadow: 0 0 16px rgba(246, 173, 85, 1), inset 0 0 8px rgba(246, 173, 85, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-2 { 
            background: rgba(87, 171, 90, 0.4); 
            box-shadow: 0 0 8px rgba(87, 171, 90, 0.6), inset 0 0 4px rgba(87, 171, 90, 0.3);
            color: #a0e3a3 !important;
        }
        .field-highlight-2.hovered {
            background: rgba(87, 171, 90, 0.7) !important;
            box-shadow: 0 0 16px rgba(87, 171, 90, 1), inset 0 0 8px rgba(87, 171, 90, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-3 { 
            background: rgba(88, 166, 255, 0.4); 
            box-shadow: 0 0 8px rgba(88, 166, 255, 0.6), inset 0 0 4px rgba(88, 166, 255, 0.3);
            color: #a8d4ff !important;
        }
        .field-highlight-3.hovered {
            background: rgba(88, 166, 255, 0.7) !important;
            box-shadow: 0 0 16px rgba(88, 166, 255, 1), inset 0 0 8px rgba(88, 166, 255, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-4 { 
            background: rgba(188, 128, 240, 0.4); 
            box-shadow: 0 0 8px rgba(188, 128, 240, 0.6), inset 0 0 4px rgba(188, 128, 240, 0.3);
            color: #d4b3ff !important;
        }
        .field-highlight-4.hovered {
            background: rgba(188, 128, 240, 0.7) !important;
            box-shadow: 0 0 16px rgba(188, 128, 240, 1), inset 0 0 8px rgba(188, 128, 240, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-5 { 
            background: rgba(255, 121, 198, 0.4); 
            box-shadow: 0 0 8px rgba(255, 121, 198, 0.6), inset 0 0 4px rgba(255, 121, 198, 0.3);
            color: #ffa3d9 !important;
        }
        .field-highlight-5.hovered {
            background: rgba(255, 121, 198, 0.7) !important;
            box-shadow: 0 0 16px rgba(255, 121, 198, 1), inset 0 0 8px rgba(255, 121, 198, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-6 { 
            background: rgba(121, 192, 255, 0.4); 
            box-shadow: 0 0 8px rgba(121, 192, 255, 0.6), inset 0 0 4px rgba(121, 192, 255, 0.3);
            color: #b3d9ff !important;
        }
        .field-highlight-6.hovered {
            background: rgba(121, 192, 255, 0.7) !important;
            box-shadow: 0 0 16px rgba(121, 192, 255, 1), inset 0 0 8px rgba(121, 192, 255, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-7 { 
            background: rgba(255, 158, 100, 0.4); 
            box-shadow: 0 0 8px rgba(255, 158, 100, 0.6), inset 0 0 4px rgba(255, 158, 100, 0.3);
            color: #ffb380 !important;
        }
        .field-highlight-7.hovered {
            background: rgba(255, 158, 100, 0.7) !important;
            box-shadow: 0 0 16px rgba(255, 158, 100, 1), inset 0 0 8px rgba(255, 158, 100, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        
        .tree-node {
            cursor: pointer;
            padding: 4px 6px;
            margin: 2px 0;
            transition: all 0.15s;
            user-select: none;
            border-left: 2px solid transparent;
            color: #c9d1d9;
            font-size: 13px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }
        
        .tree-node:hover {
            background: rgba(88, 166, 255, 0.1);
            border-left: 2px solid #58a6ff;
        }
        
        .tree-node:hover .edit-btn {
            opacity: 1;
        }
        
        .tree-node.selected {
            background: rgba(88, 166, 255, 0.15);
            border-left: 2px solid #58a6ff;
        }

        .tree-node.expandable::before {
            content: '▶';
            display: inline-block;
            margin-right: 4px;
            transition: transform 0.2s;
            color: #58a6ff;
        }

        .tree-node.expandable.expanded::before {
            transform: rotate(90deg);
        }
        
        .edit-btn {
            opacity: 0;
            transition: opacity 0.2s;
            padding: 2px 6px;
            font-size: 11px;
            background: #21262d;
            border: 1px solid #30363d;
            color: #58a6ff;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .edit-btn:hover {
            background: #30363d;
            border-color: #58a6ff;
        }
        
        .export-menu {
            position: absolute;
            right: 0;
            top: 100%;
            margin-top: 4px;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 4px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            min-width: 180px;
        }
        
        .export-menu button {
            display: block;
            width: 100%;
            padding: 8px 12px;
            text-align: left;
            background: transparent;
            border: none;
            color: #c9d1d9;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .export-menu button:hover {
            background: #21262d;
            color: #58a6ff;
        }
        
        .export-menu button:first-child {
            border-radius: 4px 4px 0 0;
        }
        
        .export-menu button:last-child {
            border-radius: 0 0 4px 4px;
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }
        
        .modal-content {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 20px;
            min-width: 400px;
            max-width: 600px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .modal-input {
            width: 100%;
            padding: 8px 12px;
            background: #0d1117;
            border: 1px solid #30363d;
            color: #c9d1d9;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }
        
        .modal-input:focus {
            outline: none;
            border-color: #58a6ff;
            box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.1);
        }
        
        input[type="file"] {
            display: none;
        }
        
        .scrollbar-thin::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .scrollbar-thin::-webkit-scrollbar-track {
            background: rgba(110, 118, 129, 0.1);
        }
        
        .scrollbar-thin::-webkit-scrollbar-thumb {
            background: rgba(88, 166, 255, 0.3);
            border-radius: 3px;
        }
        
        .scrollbar-thin::-webkit-scrollbar-thumb:hover {
            background: rgba(88, 166, 255, 0.5);
        }

        .code-editor {
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            background: #0d1117;
            color: #c9d1d9;
            border: 1px solid #30363d;
            font-size: 13px;
        }
        
        /* Syntax highlighting for code editor */
        .code-editor-highlighted {
            position: relative;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .code-editor-textarea {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: transparent;
            color: transparent;
            caret-color: #c9d1d9;
            resize: none;
            border: none;
            outline: none;
            padding: 12px;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
            overflow-y: auto;
            z-index: 2;
        }
        
        .code-editor-textarea::selection {
            background: rgba(88, 166, 255, 0.3);
        }
        
        .code-editor-display {
            pointer-events: none;
            white-space: pre;
            overflow-wrap: normal;
            word-break: normal;
            z-index: 1;
            color: #c9d1d9;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .code-editor-display > div {
            padding: 12px;
        }
        
        /* Python syntax highlighting colors (GitHub Dark theme) */
        .token-comment { color: #8b949e; font-style: italic; }
        .token-keyword { color: #ff7b72; font-weight: 600; }
        .token-string { color: #a5d6ff; }
        .token-number { color: #79c0ff; }
        .token-function { color: #d2a8ff; }
        .token-class { color: #ffa657; }
        .token-operator { color: #ff7b72; }
        .token-builtin { color: #79c0ff; }
        .token-variable { color: #ffa657; }

        .btn-terminal {
            background: #21262d;
            border: 1px solid #30363d;
            color: #58a6ff;
            transition: all 0.2s;
            font-weight: 500;
            font-size: 13px;
        }

        .btn-terminal:hover:not(:disabled) {
            background: #30363d;
            border-color: #58a6ff;
        }

        .btn-terminal:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .hex-line {
            display: flex;
            align-items: center;
            margin: 0;
            padding: 2px 0;
            transition: background 0.1s;
            white-space: nowrap;
        }

        .hex-line:hover {
            background: rgba(110, 118, 129, 0.05);
        }

        .loading-spinner {
            border: 2px solid rgba(88, 166, 255, 0.2);
            border-top: 2px solid #58a6ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-box {
            background: rgba(248, 81, 73, 0.1);
            border: 1px solid rgba(248, 81, 73, 0.3);
            box-shadow: 0 0 5px rgba(248, 81, 73, 0.1);
            padding: 8px;
            margin: 8px 0;
            color: #ff7b72;
            font-size: 12px;
        }

        .tree-children {
            margin-left: 15px;
            border-left: 1px solid rgba(88, 166, 255, 0.2);
            padding-left: 8px;
        }
        
        .terminal-title {
            background: #161b22;
            border-bottom: 1px solid #30363d;
            padding: 10px;
            color: #58a6ff;
            font-weight: 600;
            font-size: 13px;
        }
        
        .blink {
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .panel {
            background: #0d1117;
            border: 1px solid #30363d;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script>
        // Construct Library - Focused, Dynamic Templates
        const CONSTRUCT_LIBRARY = {
            // ===== NETWORK - Full Stack Protocols =====
            
            "full_tcp": {
                name: "Full TCP Packet (Eth+IP+TCP)",
                description: "Complete TCP packet: Ethernet + IPv4 + TCP headers",
                category: "Network",
                code: `# Full TCP Packet (Ethernet + IPv4 + TCP Headers)
format_struct = Struct(
    # Ethernet Layer
    "ethernet" / Struct(
        "dst_mac" / Bytes(6),
        "src_mac" / Bytes(6),
        "ethertype" / Int16ub,
    ),
    # IPv4 Layer (no options for simplicity, use IHL=5)
    "ipv4" / Struct(
        "version_ihl" / Int8ub,
        "dscp_ecn" / Int8ub,
        "total_length" / Int16ub,
        "identification" / Int16ub,
        "flags_fragment" / Int16ub,
        "ttl" / Int8ub,
        "protocol" / Int8ub,
        "checksum" / Int16ub,
        "src_ip" / Bytes(4),
        "dst_ip" / Bytes(4),
    ),
    # TCP Layer (no options for simplicity)
    "tcp" / Struct(
        "src_port" / Int16ub,
        "dst_port" / Int16ub,
        "seq_num" / Int32ub,
        "ack_num" / Int32ub,
        "data_offset_flags" / Int16ub,
        "window_size" / Int16ub,
        "checksum" / Int16ub,
        "urgent_pointer" / Int16ub,
    ),
    # Payload follows
)`
            },
            
            "full_udp": {
                name: "Full UDP Packet (Eth+IP+UDP)",
                description: "Complete UDP packet: Ethernet + IPv4 + UDP with payload",
                category: "Network",
                code: `# Full UDP Packet with Dynamic Payload
format_struct = Struct(
    # Ethernet Layer
    "ethernet" / Struct(
        "dst_mac" / Bytes(6),
        "src_mac" / Bytes(6),
        "ethertype" / Int16ub,
    ),
    # IPv4 Layer
    "ipv4" / Struct(
        "version_ihl" / Int8ub,
        "dscp_ecn" / Int8ub,
        "total_length" / Int16ub,
        "identification" / Int16ub,
        "flags_fragment" / Int16ub,
        "ttl" / Int8ub,
        "protocol" / Int8ub,
        "checksum" / Int16ub,
        "src_ip" / Bytes(4),
        "dst_ip" / Bytes(4),
    ),
    # UDP Layer
    "udp" / Struct(
        "src_port" / Int16ub,
        "dst_port" / Int16ub,
        "length" / Int16ub,
        "checksum" / Int16ub,
        "payload" / Bytes(this.length.value - 8),
    ),
)`
            },
            
            "full_dns": {
                name: "Full DNS Packet (Eth+IP+UDP+DNS)",
                description: "Complete DNS query/response with header",
                category: "Network",
                code: `# Full DNS Packet
format_struct = Struct(
    # Ethernet Layer
    "ethernet" / Struct(
        "dst_mac" / Bytes(6),
        "src_mac" / Bytes(6),
        "ethertype" / Int16ub,
    ),
    # IPv4 Layer
    "ipv4" / Struct(
        "version_ihl" / Int8ub,
        "dscp_ecn" / Int8ub,
        "total_length" / Int16ub,
        "identification" / Int16ub,
        "flags_fragment" / Int16ub,
        "ttl" / Int8ub,
        "protocol" / Int8ub,
        "checksum" / Int16ub,
        "src_ip" / Bytes(4),
        "dst_ip" / Bytes(4),
    ),
    # UDP Layer
    "udp" / Struct(
        "src_port" / Int16ub,
        "dst_port" / Int16ub,
        "length" / Int16ub,
        "checksum" / Int16ub,
    ),
    # DNS Layer
    "dns" / Struct(
        "transaction_id" / Int16ub,
        "flags" / Int16ub,
        "questions" / Int16ub,
        "answer_rrs" / Int16ub,
        "authority_rrs" / Int16ub,
        "additional_rrs" / Int16ub,
        # Questions/Answers follow (variable length DNS names)
    ),
)`
            },
            
            "full_dhcp": {
                name: "Full DHCP Packet (Eth+IP+UDP+DHCP)",
                description: "Complete DHCP message with dynamic hardware address",
                category: "Network",
                code: `# Full DHCP Packet
format_struct = Struct(
    # Ethernet Layer
    "ethernet" / Struct(
        "dst_mac" / Bytes(6),
        "src_mac" / Bytes(6),
        "ethertype" / Int16ub,
    ),
    # IPv4 Layer
    "ipv4" / Struct(
        "version_ihl" / Int8ub,
        "dscp_ecn" / Int8ub,
        "total_length" / Int16ub,
        "identification" / Int16ub,
        "flags_fragment" / Int16ub,
        "ttl" / Int8ub,
        "protocol" / Int8ub,
        "checksum" / Int16ub,
        "src_ip" / Bytes(4),
        "dst_ip" / Bytes(4),
    ),
    # UDP Layer
    "udp" / Struct(
        "src_port" / Int16ub,
        "dst_port" / Int16ub,
        "length" / Int16ub,
        "checksum" / Int16ub,
    ),
    # DHCP Layer
    "dhcp" / Struct(
        "op" / Int8ub,
        "htype" / Int8ub,
        "hlen" / Int8ub,
        "hops" / Int8ub,
        "xid" / Int32ub,
        "secs" / Int16ub,
        "flags" / Int16ub,
        "ciaddr" / Bytes(4),
        "yiaddr" / Bytes(4),
        "siaddr" / Bytes(4),
        "giaddr" / Bytes(4),
        "chaddr" / Bytes(this.hlen.value),
        "chaddr_padding" / Bytes(16 - this.hlen.value),
        "sname" / Bytes(64),
        "file" / Bytes(128),
        "magic_cookie" / Bytes(4),
        # DHCP options follow (TLV: type-length-value)
    ),
)`
            },
            
            "full_arp": {
                name: "Full ARP Packet (Eth+ARP)",
                description: "Complete ARP request/reply with dynamic addresses",
                category: "Network",
                code: `# Full ARP Packet
format_struct = Struct(
    # Ethernet Layer
    "ethernet" / Struct(
        "dst_mac" / Bytes(6),
        "src_mac" / Bytes(6),
        "ethertype" / Int16ub,
    ),
    # ARP Layer
    "arp" / Struct(
        "htype" / Int16ub,
        "ptype" / Int16ub,
        "hlen" / Int8ub,
        "plen" / Int8ub,
        "operation" / Int16ub,
        "sender_mac" / Bytes(this.hlen.value),
        "sender_ip" / Bytes(this.plen.value),
        "target_mac" / Bytes(this.hlen.value),
        "target_ip" / Bytes(this.plen.value),
    ),
)`
            },
            
            // ===== FILES - Executables & Archives =====
            
            "elf": {
                name: "ELF Header (64-bit)",
                description: "ELF executable/library header with program headers",
                category: "Files",
                code: `# ELF 64-bit Header
format_struct = Struct(
    "magic" / Bytes(4),
    "class" / Int8ub,
    "endian" / Int8ub,
    "version" / Int8ub,
    "osabi" / Int8ub,
    "abiversion" / Int8ub,
    "padding" / Bytes(7),
    "type" / Int16ul,
    "machine" / Int16ul,
    "version2" / Int32ul,
    "entry" / Int64ul,
    "phoff" / Int64ul,
    "shoff" / Int64ul,
    "flags" / Int32ul,
    "ehsize" / Int16ul,
    "phentsize" / Int16ul,
    "phnum" / Int16ul,
    "shentsize" / Int16ul,
    "shnum" / Int16ul,
    "shstrndx" / Int16ul,
)`
            },
            
            "pe": {
                name: "PE Header (Windows)",
                description: "PE/COFF executable header (DOS + PE)",
                category: "Files",
                code: `# PE Header (DOS Stub + PE Signature)
format_struct = Struct(
    # DOS Header
    "dos_magic" / Bytes(2),
    "dos_lastsize" / Int16ul,
    "dos_nblocks" / Int16ul,
    "dos_nreloc" / Int16ul,
    "dos_hdrsize" / Int16ul,
    "dos_minalloc" / Int16ul,
    "dos_maxalloc" / Int16ul,
    "dos_ss" / Int16ul,
    "dos_sp" / Int16ul,
    "dos_checksum" / Int16ul,
    "dos_ip" / Int16ul,
    "dos_cs" / Int16ul,
    "dos_lfarlc" / Int16ul,
    "dos_ovno" / Int16ul,
    "dos_res" / Bytes(8),
    "dos_oemid" / Int16ul,
    "dos_oeminfo" / Int16ul,
    "dos_res2" / Bytes(20),
    "pe_offset" / Int32ul,
)`
            },
            
            "zip": {
                name: "ZIP Local File Header",
                description: "ZIP archive local file header with dynamic filename and extra fields",
                category: "Files",
                code: `# ZIP Local File Header (Dynamic)
format_struct = Struct(
    "signature" / Bytes(4),
    "version" / Int16ul,
    "flags" / Int16ul,
    "compression" / Int16ul,
    "mod_time" / Int16ul,
    "mod_date" / Int16ul,
    "crc32" / Int32ul,
    "compressed_size" / Int32ul,
    "uncompressed_size" / Int32ul,
    "filename_length" / Int16ul,
    "extra_length" / Int16ul,
    "filename" / Bytes(this.filename_length.value),
    "extra_field" / Bytes(this.extra_length.value),
    # Compressed data follows
)`
            },
            
            "gzip": {
                name: "GZIP Header",
                description: "GZIP compression header with dynamic filename/comment",
                category: "Files",
                code: `# GZIP Header (Dynamic)
format_struct = Struct(
    "magic" / Bytes(2),
    "method" / Int8ub,
    "flags" / Int8ub,
    "mtime" / Int32ul,
    "extra_flags" / Int8ub,
    "os" / Int8ub,
    # If flags & 0x04: extra field follows (2-byte length + data)
    # If flags & 0x08: null-terminated filename follows
    # If flags & 0x10: null-terminated comment follows
)`
            },
            
            "tar": {
                name: "TAR Header (POSIX)",
                description: "POSIX TAR archive header with filename and metadata",
                category: "Files",
                code: `# TAR Header (POSIX/ustar)
format_struct = Struct(
    "name" / Bytes(100),
    "mode" / Bytes(8),
    "uid" / Bytes(8),
    "gid" / Bytes(8),
    "size" / Bytes(12),
    "mtime" / Bytes(12),
    "checksum" / Bytes(8),
    "typeflag" / Bytes(1),
    "linkname" / Bytes(100),
    "magic" / Bytes(6),
    "version" / Bytes(2),
    "uname" / Bytes(32),
    "gname" / Bytes(32),
    "devmajor" / Bytes(8),
    "devminor" / Bytes(8),
    "prefix" / Bytes(155),
    "padding" / Bytes(12),
    # File data follows (size field indicates length)
)`
            },
            
            "png": {
                name: "PNG Chunk",
                description: "PNG image chunk with dynamic data field",
                category: "Files",
                code: `# PNG Chunk (Dynamic)
format_struct = Struct(
    "length" / Int32ub,
    "type" / Bytes(4),
    "data" / Bytes(this.length.value),
    "crc" / Int32ub,
)`
            },
            
            "jpeg": {
                name: "JPEG Segment",
                description: "JPEG image segment with dynamic data",
                category: "Files",
                code: `# JPEG Segment (Dynamic)
format_struct = Struct(
    "marker" / Bytes(2),
    "length" / Int16ub,
    "data" / Bytes(this.length.value - 2),
)`
            },
            
            // ===== FIRMWARE - Filesystems & Images =====
            
            "squashfs": {
                name: "SquashFS Superblock",
                description: "SquashFS compressed filesystem superblock",
                category: "Firmware",
                code: `# SquashFS Superblock
format_struct = Struct(
    "magic" / Bytes(4),
    "inode_count" / Int32ul,
    "mtime" / Int32ul,
    "block_size" / Int32ul,
    "fragment_count" / Int32ul,
    "compression" / Int16ul,
    "block_log" / Int16ul,
    "flags" / Int16ul,
    "id_count" / Int16ul,
    "version_major" / Int16ul,
    "version_minor" / Int16ul,
    "root_inode" / Int64ul,
    "bytes_used" / Int64ul,
    "id_table_start" / Int64ul,
    "xattr_table_start" / Int64ul,
    "inode_table_start" / Int64ul,
    "directory_table_start" / Int64ul,
    "fragment_table_start" / Int64ul,
    "lookup_table_start" / Int64ul,
)`
            },
            
            "ext4": {
                name: "EXT2/3/4 Superblock",
                description: "EXT filesystem superblock (compatible with ext2/ext3/ext4)",
                category: "Firmware",
                code: `# EXT2/3/4 Superblock
format_struct = Struct(
    "inodes_count" / Int32ul,
    "blocks_count" / Int32ul,
    "r_blocks_count" / Int32ul,
    "free_blocks_count" / Int32ul,
    "free_inodes_count" / Int32ul,
    "first_data_block" / Int32ul,
    "log_block_size" / Int32ul,
    "log_frag_size" / Int32ul,
    "blocks_per_group" / Int32ul,
    "frags_per_group" / Int32ul,
    "inodes_per_group" / Int32ul,
    "mtime" / Int32ul,
    "wtime" / Int32ul,
    "mnt_count" / Int16ul,
    "max_mnt_count" / Int16ul,
    "magic" / Int16ul,
    "state" / Int16ul,
    "errors" / Int16ul,
    "minor_rev_level" / Int16ul,
    "lastcheck" / Int32ul,
    "checkinterval" / Int32ul,
    "creator_os" / Int32ul,
    "rev_level" / Int32ul,
    "def_resuid" / Int16ul,
    "def_resgid" / Int16ul,
)`
            },
            
            "cpio": {
                name: "CPIO Archive (newc)",
                description: "CPIO archive header (newc format, common in initramfs)",
                category: "Firmware",
                code: `# CPIO Archive Header (newc format)
format_struct = Struct(
    "magic" / Bytes(6),
    "ino" / Bytes(8),
    "mode" / Bytes(8),
    "uid" / Bytes(8),
    "gid" / Bytes(8),
    "nlink" / Bytes(8),
    "mtime" / Bytes(8),
    "filesize" / Bytes(8),
    "devmajor" / Bytes(8),
    "devminor" / Bytes(8),
    "rdevmajor" / Bytes(8),
    "rdevminor" / Bytes(8),
    "namesize" / Bytes(8),
    "check" / Bytes(8),
    # Filename follows (namesize bytes)
    # File data follows (filesize bytes)
)`
            },
            
            // ===== EXAMPLES - Advanced Construct Features =====
            
            "aes_encrypted": {
                name: "AES Encrypted Data",
                description: "AES-CBC encrypted structure (EncryptedSym)",
                category: "Examples",
                code: `# AES Encrypted Structure Example
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

format_struct = Struct(
    "key" / Bytes(32),  # AES-256 key
    "iv" / Bytes(16),   # Initialization vector
    "enc_data" / EncryptedSym(
        Aligned(16,
            Struct(
                "width" / Int16ul,
                "height" / Int16ul,
                "format" / Int32ul,
            )
        ),
        lambda ctx: Cipher(
            algorithms.AES(ctx.key.value), 
            modes.CBC(ctx.iv.value),
            backend=default_backend()
        )
    )
)

# Build Mode: fill key (32 bytes), iv (16 bytes), width, height, format
# The inner struct will be automatically encrypted!
# Note: Use ctx.field.value due to RawCopy wrapper for offset tracking
`
            },
            
            "compressed_data": {
                name: "Compressed Data (zlib)",
                description: "Zlib compressed payload with length prefix (Compressed)",
                category: "Examples",
                code: `# Compressed Data Example
format_struct = Struct(
    "magic" / Const(b"COMP"),
    "compressed" / Prefixed(Int32ul, 
        Compressed(GreedyBytes, "zlib")
    )
)

# Build Mode: just provide the magic
# For compressed field, provide raw uncompressed data as hex
# It will be automatically compressed during build!
`
            },
            
            "checksummed": {
                name: "Checksummed Data",
                description: "Data with SHA256 checksum (Checksum + RawCopy)",
                category: "Examples",
                code: `# Checksummed Data Example
import hashlib

format_struct = Struct(
    "fields" / RawCopy(Struct(
        "version" / Int32ul,
        "length" / Int32ul,
        "data" / Bytes(16),
    )),
    "checksum" / Checksum(Bytes(32),
        lambda data: hashlib.sha256(data).digest(),
        this.fields.data
    ),
)

# Build Mode: provide version, length, data
# Checksum will be auto-calculated from the raw bytes!
`
            },
            
            "xor_encoded": {
                name: "XOR Encoded Data",
                description: "XOR obfuscated payload (ProcessXor)",
                category: "Examples",
                code: `# XOR Encoded Data Example
format_struct = Struct(
    "xor_key" / Int8ul,
    "encoded" / ProcessXor(
        this.xor_key.value,
        Struct(
            "secret_id" / Int32ul,
            "secret_value" / Int32ul,
        )
    )
)

# Build Mode: provide xor_key (e.g., 0xAB), secret_id, secret_value
# Data will be XORed automatically during build!
# Note: Use this.field.value due to RawCopy wrapper for offset tracking
`
            },
            
            "null_terminated": {
                name: "Null-Terminated String",
                description: "C-style null-terminated string (NullTerminated)",
                category: "Examples",
                code: `# Null-Terminated String Example
format_struct = Struct(
    "name" / NullTerminated(GreedyBytes),
    "age" / Int8ul,
)

# Build Mode: provide name as hex (e.g., "48656c6c6f" for "Hello")
# Null terminator will be added automatically!
`
            },
            
            "prefixed_array": {
                name: "Prefixed Array",
                description: "Length-prefixed array of items (PrefixedArray)",
                category: "Examples",
                code: `# Prefixed Array Example
format_struct = Struct(
    "magic" / Const(b"PARR"),
    "items" / PrefixedArray(Int16ul, 
        Struct(
            "id" / Int32ul,
            "value" / Int32ul,
        )
    ),
)

# Note: PrefixedArray requires array input during build
# This is better demonstrated with parsing existing data
`
            },
        };
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Utility functions
        const formatHex = (byte) => byte.toString(16).padStart(2, '0').toUpperCase();
        
        const formatAscii = (byte) => {
            return (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
        };

        // Python/Construct integration
        let pyodide = null;
        let pyodideReady = false;

        const initPyodide = async () => {
            if (pyodideReady) return pyodide;
            
            console.log('Loading Pyodide...');
            pyodide = await loadPyodide({
                indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
            });
            
            console.log('Installing construct and cryptography...');
            await pyodide.loadPackage(['micropip']);
            const micropip = pyodide.pyimport('micropip');
            await micropip.install('construct');
            
            // Load cryptography for EncryptedSym support
            try {
                await pyodide.loadPackage('cryptography');
                console.log('Cryptography loaded successfully');
            } catch (err) {
                console.warn('Cryptography not available:', err);
            }
            
            console.log('Pyodide ready!');
            pyodideReady = true;
            return pyodide;
        };

        const parseWithConstruct = async (data, structCode) => {
            if (!pyodideReady) {
                throw new Error('Pyodide not ready');
            }

            console.log('parseWithConstruct called with data length:', data.length);
            console.log('Struct code:', structCode);

            try {
                // Convert Uint8Array to Python bytes properly
                const dataArray = Array.from(data);
                console.log('Converted to array, length:', dataArray.length);
                
                const dataBytes = pyodide.toPy(dataArray);
                console.log('Created Python object');
                
                // Create Python code to parse the structure
                const pythonCode = `
import json
import traceback
from construct import *

# --- 1. Instrumentation Core ---

# Global side-channel to store the UI tree
_ui_roots = []
_ui_stack = []

class InstrumentedWrapper(Subconstruct):
    """
    A transparent wrapper that records parsing metadata (offsets, lengths)
    into a global tree structure without modifying the data passing through.
    """
    def __init__(self, subcon, name):
        super().__init__(subcon)
        self.name = name

    def _parse(self, stream, context, path):
        # 1. Create a node for this field
        node = {
            "name": self.name,
            "children": [],
            "value": None,
            "offset": 0,
            "length": 0,
            "rawValue": None
        }

        # 2. Attach to parent (if exists) or root
        if _ui_stack:
            _ui_stack[-1]['children'].append(node)
        else:
            _ui_roots.append(node)

        # 3. Push self to stack (so children attach to me)
        _ui_stack.append(node)

        # 4. Record Start Offset
        start_offset = stream.tell()

        try:
            # 5. Run the actual parse (Transparent!)
            obj = self.subcon._parse(stream, context, path)
            
            # 6. Record End & Value
            end_offset = stream.tell()
            node['offset'] = start_offset
            node['length'] = end_offset - start_offset
            node['rawValue'] = obj
            
            # Format value for UI display
            node['value'] = self._format_value(obj, node['length'])
            
            return obj
            
        except Exception as e:
            node['error'] = str(e)
            raise e
        finally:
            # 7. Pop self from stack
            _ui_stack.pop()
            
    def _build(self, obj, stream, context, path):
        return self.subcon._build(obj, stream, context, path)

    def _format_value(self, val, length):
        if isinstance(val, bytes):
            if len(val) > 16:
                return f"{val[:8].hex().upper()}... ({len(val)} bytes)"
            return val.hex().upper()
        if isinstance(val, int):
            if length == 1: return f"0x{val:02X} ({val})"
            if length == 2: return f"0x{val:04X} ({val})"
            if length == 4: return f"0x{val:08X} ({val})"
            return f"0x{val:X} ({val})"
        if isinstance(val, str):
            return f'"{val}"'
        return str(val)

def instrument_structure(sc, name=""):
    if isinstance(sc, Renamed):
        return instrument_structure(sc.subcon, sc.name)
    if isinstance(sc, Struct):
        new_subcons = [instrument_structure(sub, sub.name) for sub in sc.subcons]
        return InstrumentedWrapper(Struct(*new_subcons), name or "Struct")
    elif isinstance(sc, Array):
        inner = instrument_structure(sc.subcon, "")
        return InstrumentedWrapper(Array(sc.count, inner), name or "Array")
    else:
        field_name = name or getattr(sc, "name", None) or type(sc).__name__
        return InstrumentedWrapper(sc, field_name)

# --- 2. User Code Injection ---
# We execute this in the Global Scope so indentation doesn't matter!
${structCode}

# --- 3. Parse Logic ---

def parse_structure(data_list):
    global _ui_roots, _ui_stack
    
    try:
        # 1. Find the user's structure (it's now in globals)
        struct_obj = None
        for name in ['format_struct', 'struct', 'packet', 'header']:
            if name in globals() and isinstance(globals()[name], Construct):
                struct_obj = globals()[name]
                break
                
        if not struct_obj:
            return {"error": "No structure found. Define 'format_struct = Struct(...)'"}

        # 2. Reset Side-Channel
        _ui_roots = []
        _ui_stack = []
        
        # 3. Instrument the structure (Wrap it!)
        instrumented = instrument_structure(struct_obj, "root")
        
        # 4. Parse
        data_bytes = bytes(data_list)
        instrumented.parse(data_bytes)
        
        # 5. Clean up the UI tree for JSON
        def clean_node(n):
            return {
                "name": n['name'],
                "value": n['value'],
                "offset": n['offset'],
                "length": n['length'],
                "rawValue": n['rawValue'] if isinstance(n['rawValue'], (int, str, bool, type(None))) else None,
                "children": [clean_node(c) for c in n['children']]
            }
            
        final_fields = [clean_node(n) for n in _ui_roots]
        
        if len(final_fields) == 1 and final_fields[0]['name'] == 'root':
             final_fields = final_fields[0]['children']

        return {"fields": final_fields}

    except Exception as e:
        return {"error": str(e), "traceback": traceback.format_exc()}

# Execute
result = parse_structure(data_list)
json.dumps(result)
`;
                // Set the data in Python environment
                pyodide.globals.set('data_list', dataBytes);
                console.log('Set data_list in Python globals');
                
                // Run the code
                console.log('Running Python code...');
                const result = await pyodide.runPythonAsync(pythonCode);
                console.log('Python execution complete, result:', result);
                
                const parsed = JSON.parse(result);
                console.log('Parsed JSON:', parsed);
                
                if (parsed.error) {
                    throw new Error(parsed.error + '\n' + (parsed.traceback || ''));
                }
                
                return parsed.fields || [];
                
            } catch (error) {
                console.error('Parse error:', error);
                throw error;
            }
        };

        // Hex View Component with Virtual Scrolling
        const HexView = ({ data, highlightRanges = [], onByteClick, selectedField, hoveredField }) => {
            const [scrollTop, setScrollTop] = useState(0);
            const containerRef = useRef(null);
            
            const bytesPerLine = 16;
            const lineHeight = 24; // pixels per line
            const overscan = 10; // render extra lines above/below viewport
            
            const totalLines = Math.ceil(data.length / bytesPerLine);
            const totalHeight = totalLines * lineHeight;
            
            // Calculate visible range
            const containerHeight = containerRef.current?.clientHeight || 600;
            const visibleLines = Math.ceil(containerHeight / lineHeight);
            const startLine = Math.max(0, Math.floor(scrollTop / lineHeight) - overscan);
            const endLine = Math.min(totalLines, startLine + visibleLines + overscan * 2);
            
            const handleScroll = (e) => {
                setScrollTop(e.target.scrollTop);
            };

            const getHighlightClass = (byteIndex) => {
                // Check if this byte is in the hovered field
                const isHovered = hoveredField && 
                                  byteIndex >= hoveredField.offset && 
                                  byteIndex < hoveredField.offset + hoveredField.length;
                
                for (let i = 0; i < highlightRanges.length; i++) {
                    const range = highlightRanges[i];
                    if (byteIndex >= range.offset && byteIndex < range.offset + range.length) {
                        // Use topLevelIndex for color instead of range index
                        const baseClass = `field-highlight-${range.topLevelIndex % 8}`;
                        return isHovered ? `${baseClass} hovered` : baseClass;
                    }
                }
                return '';
            };
            
            // Only render visible lines
            const visibleLineElements = [];
            for (let lineIdx = startLine; lineIdx < endLine; lineIdx++) {
                const offset = lineIdx * bytesPerLine;
                const lineData = data.slice(offset, Math.min(offset + bytesPerLine, data.length));
                const y = lineIdx * lineHeight;
                
                visibleLineElements.push(
                    <div 
                        key={lineIdx} 
                        className="hex-line" 
                        style={{ 
                            position: 'absolute', 
                            top: `${y}px`,
                            left: 0,
                            right: 0,
                            height: `${lineHeight}px`
                        }}
                    >
                        <span className="hex-offset">
                            {offset.toString(16).padStart(8, '0').toUpperCase()}
                        </span>
                        <span className="mx-4">
                            {Array.from(lineData).map((byte, byteIdx) => {
                                const globalIdx = offset + byteIdx;
                                const highlightClass = getHighlightClass(globalIdx);
                                return (
                                    <span
                                        key={byteIdx}
                                        className={`hex-cell ${highlightClass}`}
                                        onClick={() => onByteClick && onByteClick(globalIdx)}
                                        title={`Offset: 0x${globalIdx.toString(16)}, Value: 0x${formatHex(byte)} (${byte})`}
                                    >
                                        {formatHex(byte)}
                                    </span>
                                );
                            })}
                            {Array(bytesPerLine - lineData.length).fill(0).map((_, i) => (
                                <span key={`pad-${i}`} className="hex-cell opacity-30">··</span>
                            ))}
                        </span>
                        <span className="ml-4 border-l border-gray-700 pl-4">
                            {Array.from(lineData).map((byte, byteIdx) => {
                                const globalIdx = offset + byteIdx;
                                const highlightClass = getHighlightClass(globalIdx);
                                return (
                                    <span 
                                        key={byteIdx} 
                                        className={`ascii-char ${highlightClass}`}
                                        title={`Offset: 0x${globalIdx.toString(16)}`}
                                    >
                                        {formatAscii(byte)}
                                    </span>
                                );
                            })}
                        </span>
                    </div>
                );
            }

            return (
                <div 
                    ref={containerRef}
                    className="font-mono text-sm"
                    style={{ 
                        height: '100%', 
                        overflow: 'auto',
                        position: 'relative'
                    }}
                    onScroll={handleScroll}
                >
                    <div style={{ height: `${totalHeight}px`, position: 'relative' }}>
                        {visibleLineElements}
                    </div>
                </div>
            );
        };

        // Edit Modal Component
        const EditModal = ({ field, onClose, onSave }) => {
            const [value, setValue] = useState('');
            const [error, setError] = useState('');
            const [inputMode, setInputMode] = useState('auto'); // 'hex' or 'int' or 'string' or 'auto'
            
            useEffect(() => {
                // Determine if this is a Bytes field (not an integer field)
                // Check if the value display format indicates bytes (shows hex string without decimal)
                const isBytesField = field.value && field.value.match(/^[0-9A-F]+$/) && field.length >= 4;
                const isIntField = field.rawValue !== null && field.rawValue !== undefined && typeof field.rawValue === 'number';
                
                // Set initial value and mode based on field type
                if (isIntField && field.length <= 4) {
                    // Integer field (Int8, Int16, Int32)
                    setValue(field.rawValue.toString());
                    setInputMode('int');
                } else if (field.value) {
                    // Extract value from display string
                    const match = field.value.match(/^([0-9A-F]+)/);
                    if (match) {
                        // Format with spaces for bytes
                        const hexStr = match[1];
                        let formatted = '';
                        for (let i = 0; i < hexStr.length; i += 2) {
                            if (i > 0) formatted += ' ';
                            formatted += hexStr.substring(i, i + 2);
                        }
                        setValue(formatted);
                        setInputMode('hex');
                    } else {
                        setValue(field.value.replace(/['"]/g, ''));
                        setInputMode('string');
                    }
                } else {
                    setInputMode('hex');
                }
                
                // For Bytes fields (4+ bytes that aren't integers), force hex mode
                if (isBytesField || (field.length >= 4 && !isIntField)) {
                    setInputMode('hex');
                }
            }, [field]);
            
            const inputRef = useRef(null);
            
            const formatHexWithSpaces = (hexStr) => {
                // Add spaces every 2 characters (after each byte)
                let formatted = '';
                for (let i = 0; i < hexStr.length; i += 2) {
                    if (i > 0) formatted += ' ';
                    formatted += hexStr.substring(i, i + 2);
                }
                return formatted;
            };
            
            const handleInputChange = (e) => {
                const input = e.target.value;
                
                // For hex mode (byte arrays), handle in-place nibble editing
                if (inputMode === 'hex') {
                    // Remove spaces to get raw hex
                    const newHex = input.replace(/\s/g, '').toUpperCase();
                    const oldHex = value.replace(/\s/g, '');
                    
                    // Ensure we don't exceed field length
                    const maxChars = field.length * 2;
                    if (newHex.length > maxChars) {
                        return; // Don't allow more than field size
                    }
                    
                    // Pad with original bytes if user deleted some
                    let finalHex = newHex;
                    if (finalHex.length < maxChars) {
                        // Pad with zeros to maintain field length
                        finalHex = finalHex.padEnd(maxChars, '0');
                    }
                    
                    setValue(formatHexWithSpaces(finalHex));
                } else if (inputMode === 'int') {
                    // Allow only digits, 'x', and 'X' for hex prefix
                    if (/^(0x)?[0-9A-Fa-fXx]*$/.test(input)) {
                        setValue(input);
                    }
                } else {
                    setValue(input);
                }
            };
            
            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    handleSave();
                    return;
                } else if (e.key === 'Escape') {
                    onClose();
                    return;
                }
                
                // For hex input mode, handle nibble-by-nibble editing
                if (inputMode === 'hex' && !e.ctrlKey && !e.metaKey) {
                    const input = e.target;
                    const cursorPos = input.selectionStart;
                    const currentValue = value.replace(/\s/g, ''); // Remove spaces
                    
                    // Check if it's a hex character
                    const isHexChar = /^[0-9A-Fa-f]$/.test(e.key);
                    
                    if (isHexChar) {
                        e.preventDefault();
                        
                        // Calculate position in hex string (without spaces)
                        let hexPos = 0;
                        let visualPos = 0;
                        for (let i = 0; i < value.length && visualPos < cursorPos; i++) {
                            if (value[i] !== ' ') {
                                hexPos++;
                            }
                            visualPos++;
                        }
                        
                        // Replace character at cursor position (overwrite mode)
                        const newHex = currentValue.substring(0, hexPos) + 
                                      e.key.toUpperCase() + 
                                      currentValue.substring(hexPos + 1);
                        
                        const formatted = formatHexWithSpaces(newHex);
                        setValue(formatted);
                        
                        // Move cursor forward
                        setTimeout(() => {
                            // Calculate new cursor position (accounting for spaces)
                            let newVisualPos = 0;
                            let hexCount = 0;
                            for (let i = 0; i < formatted.length; i++) {
                                if (formatted[i] !== ' ') {
                                    hexCount++;
                                }
                                newVisualPos = i + 1;
                                if (hexCount > hexPos) {
                                    break;
                                }
                            }
                            input.setSelectionRange(newVisualPos, newVisualPos);
                        }, 0);
                        
                        return;
                    }
                    
                    // Handle backspace
                    if (e.key === 'Backspace') {
                        e.preventDefault();
                        
                        if (cursorPos === 0) return;
                        
                        // Calculate position in hex string
                        let hexPos = 0;
                        let visualPos = 0;
                        for (let i = 0; i < value.length && visualPos < cursorPos; i++) {
                            if (value[i] !== ' ') {
                                hexPos++;
                            }
                            visualPos++;
                        }
                        
                        if (hexPos > 0) {
                            // Replace with 0 instead of deleting
                            const newHex = currentValue.substring(0, hexPos - 1) + 
                                          '0' + 
                                          currentValue.substring(hexPos);
                            
                            const formatted = formatHexWithSpaces(newHex);
                            setValue(formatted);
                            
                            // Move cursor back
                            setTimeout(() => {
                                let newVisualPos = 0;
                                let hexCount = 0;
                                for (let i = 0; i < formatted.length; i++) {
                                    if (formatted[i] !== ' ') {
                                        hexCount++;
                                    }
                                    if (hexCount >= hexPos - 1) {
                                        newVisualPos = i;
                                        break;
                                    }
                                }
                                input.setSelectionRange(newVisualPos, newVisualPos);
                            }, 0);
                        }
                        
                        return;
                    }
                    
                    // Handle delete
                    if (e.key === 'Delete') {
                        e.preventDefault();
                        
                        // Calculate position in hex string
                        let hexPos = 0;
                        let visualPos = 0;
                        for (let i = 0; i < value.length && visualPos < cursorPos; i++) {
                            if (value[i] !== ' ') {
                                hexPos++;
                            }
                            visualPos++;
                        }
                        
                        if (hexPos < currentValue.length) {
                            // Replace with 0 instead of deleting
                            const newHex = currentValue.substring(0, hexPos) + 
                                          '0' + 
                                          currentValue.substring(hexPos + 1);
                            
                            setValue(formatHexWithSpaces(newHex));
                        }
                        
                        return;
                    }
                    
                    // Allow navigation keys
                    const allowedKeys = ['ArrowLeft', 'ArrowRight', 'Tab', 'Home', 'End'];
                    if (!allowedKeys.includes(e.key)) {
                        e.preventDefault();
                    }
                }
            };
            
            const handleSave = () => {
                setError('');
                
                try {
                    let newBytes;
                    
                    // Check if we're in hex mode (for byte arrays)
                    if (inputMode === 'hex') {
                        // Hex byte array
                        const hexStr = value.replace(/\s/g, '');
                        if (hexStr.length % 2 !== 0) {
                            throw new Error('Hex string must have even number of characters');
                        }
                        const numBytes = hexStr.length / 2;
                        if (numBytes > field.length) {
                            throw new Error(`Too many bytes. Max ${field.length} bytes allowed.`);
                        }
                        // Create array with exact bytes needed
                        newBytes = new Uint8Array(field.length);
                        for (let i = 0; i < numBytes; i++) {
                            const byteVal = parseInt(hexStr.substr(i * 2, 2), 16);
                            if (isNaN(byteVal)) {
                                throw new Error('Invalid hex value');
                            }
                            newBytes[i] = byteVal;
                        }
                        // Note: Remaining bytes stay as 0 if not specified
                    } else if (inputMode === 'int') {
                        // Integer field
                        if (field.length === 1) {
                            let val = value.startsWith('0x') ? parseInt(value, 16) : parseInt(value, 10);
                            if (isNaN(val) || val < 0 || val > 255) {
                                throw new Error('Value must be between 0 and 255');
                            }
                            newBytes = new Uint8Array([val]);
                        } else if (field.length === 2) {
                            let val = value.startsWith('0x') ? parseInt(value, 16) : parseInt(value, 10);
                            if (isNaN(val) || val < 0 || val > 65535) {
                                throw new Error('Value must be between 0 and 65535');
                            }
                            newBytes = new Uint8Array([val & 0xFF, (val >> 8) & 0xFF]);
                        } else if (field.length === 4) {
                            let val = value.startsWith('0x') ? parseInt(value, 16) : parseInt(value, 10);
                            if (isNaN(val) || val < 0 || val > 4294967295) {
                                throw new Error('Value must be between 0 and 4294967295');
                            }
                            newBytes = new Uint8Array([
                                val & 0xFF,
                                (val >> 8) & 0xFF,
                                (val >> 16) & 0xFF,
                                (val >> 24) & 0xFF
                            ]);
                        }
                    } else {
                        // String mode
                        const encoder = new TextEncoder();
                        const encoded = encoder.encode(value);
                        if (encoded.length > field.length) {
                            throw new Error(`String too long. Max ${field.length} bytes.`);
                        }
                        // Pad with zeros if string is shorter
                        newBytes = new Uint8Array(field.length);
                        newBytes.set(encoded);
                    }
                    
                    onSave(field.offset, newBytes);
                    onClose();
                } catch (err) {
                    setError(err.message);
                }
            };
            
            const getInputHelp = () => {
                if (inputMode === 'hex') {
                    return `Enter ${field.length} hex bytes (auto-spaced)`;
                } else if (inputMode === 'int') {
                    if (field.length === 1) {
                        return 'Enter decimal (0-255) or hex (0xFF)';
                    } else if (field.length === 2) {
                        return 'Enter decimal (0-65535) or hex (0xFFFF)';
                    } else if (field.length === 4) {
                        return 'Enter decimal or hex (0xFFFFFFFF)';
                    }
                } else {
                    return 'Enter ASCII string';
                }
            };
            
            const getPlaceholder = () => {
                if (inputMode === 'hex') {
                    // Show hex byte pattern
                    return Array(Math.min(field.length, 4)).fill('00').join(' ') + 
                           (field.length > 4 ? ' ...' : '');
                } else if (inputMode === 'int') {
                    if (field.length === 1) {
                        return '0xFF or 255';
                    } else if (field.length === 2) {
                        return '0x1234 or 4660';
                    } else if (field.length === 4) {
                        return '0xDEADBEEF or 3735928559';
                    }
                } else {
                    return 'Enter text...';
                }
            };
            
            const toggleInputMode = () => {
                if (inputMode === 'hex') {
                    setInputMode('string');
                    setValue('');
                } else {
                    setInputMode('hex');
                    setValue('');
                }
            };
            
            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content" onClick={(e) => e.stopPropagation()}>
                        <h2 className="text-lg font-semibold mb-4" style={{ color: '#58a6ff' }}>
                            Edit Field: {field.name}
                        </h2>
                        
                        <div className="mb-4">
                            <div className="text-sm mb-2" style={{ color: '#8b949e' }}>
                                <div>Offset: 0x{field.offset.toString(16).padStart(4, '0')}</div>
                                <div>Size: {field.length} bytes</div>
                                <div className="mt-1 flex items-center justify-between">
                                    <span style={{ color: '#6e7681', fontSize: '12px' }}>
                                        {getInputHelp()}
                                    </span>
                                    {inputMode !== 'int' && (
                                        <button
                                            onClick={toggleInputMode}
                                            className="px-2 py-1 text-xs rounded"
                                            style={{
                                                background: '#21262d',
                                                border: '1px solid #30363d',
                                                color: '#58a6ff'
                                            }}
                                        >
                                            {inputMode === 'hex' ? 'Switch to ASCII' : 'Switch to Hex'}
                                        </button>
                                    )}
                                </div>
                            </div>
                            
                            <input
                                ref={inputRef}
                                type="text"
                                className="modal-input"
                                value={value}
                                onChange={handleInputChange}
                                onKeyDown={handleKeyDown}
                                placeholder={getPlaceholder()}
                                autoFocus
                                style={{
                                    fontFamily: inputMode === 'hex' ? 'JetBrains Mono, monospace' : 'inherit',
                                    letterSpacing: inputMode === 'hex' ? '0.05em' : 'normal'
                                }}
                            />
                            
                            {inputMode === 'hex' && (
                                <div className="mt-2 text-xs" style={{ color: '#6e7681' }}>
                                    💡 Tip: Type hex digits to overwrite nibbles in-place. Use arrow keys to navigate.
                                </div>
                            )}
                            
                            {error && (
                                <div className="mt-2 text-sm" style={{ color: '#ff7b72' }}>
                                    {error}
                                </div>
                            )}
                        </div>
                        
                        <div className="flex justify-end space-x-2">
                            <button
                                onClick={onClose}
                                className="px-4 py-2 btn-terminal rounded"
                            >
                                Cancel
                            </button>
                            <button
                                onClick={handleSave}
                                className="px-4 py-2 rounded"
                                style={{
                                    background: '#238636',
                                    border: '1px solid #2ea043',
                                    color: '#fff'
                                }}
                            >
                                Save
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Syntax Highlighter Component
        const CodeEditor = ({ value, onChange, placeholder, spellCheck = false }) => {
            const textareaRef = useRef(null);
            const displayRef = useRef(null);
            const contentRef = useRef(null);
            
            const handleScroll = (e) => {
                // Sync scroll position using transform (more reliable than scrollTop)
                if (contentRef.current) {
                    contentRef.current.style.transform = `translate(${-e.target.scrollLeft}px, ${-e.target.scrollTop}px)`;
                }
            };
            
            const handleKeyDown = (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    
                    const textarea = e.target;
                    const start = textarea.selectionStart;
                    const end = textarea.selectionEnd;
                    
                    // Insert 4 spaces
                    const newValue = value.substring(0, start) + '    ' + value.substring(end);
                    onChange({ target: { value: newValue } });
                    
                    // Set cursor position after the inserted spaces
                    setTimeout(() => {
                        textarea.selectionStart = textarea.selectionEnd = start + 4;
                    }, 0);
                }
            };
            
            const highlightSyntax = (code) => {
                if (!code) return '';
                
                // Escape HTML
                const escapeHtml = (text) => text
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                
                // Token patterns (order matters - most specific first!)
                const patterns = [
                    { regex: /#[^\n]*/g, className: 'token-comment' },
                    { regex: /b"(?:[^"\\]|\\.)*"|b'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'/g, className: 'token-string' },
                    { regex: /\b(import|from|def|class|if|else|elif|for|while|return|lambda|try|except|with|as|in|True|False|None)\b/g, className: 'token-keyword' },
                    { regex: /\b(Struct|Bytes|Int8ub|Int8ul|Int8sb|Int8sl|Int16ub|Int16ul|Int16sb|Int16sl|Int32ub|Int32ul|Int32sb|Int32sl|Int64ub|Int64ul|Int64sb|Int64sl|Float32l|Float32b|Float64l|Float64b|Array|Aligned|Default|EncryptedSym|Compressed|Prefixed|PrefixedArray|Computed|Rebuild|Enum|FlagsEnum|Switch|Const|Padding|Padded|Container|Cipher|algorithms|modes|AES|CBC|RawCopy|Checksum|ProcessXor|NullTerminated|GreedyBytes|GreedyRange|VarInt|CString|PascalString|Bitwise|BitsInteger|Bit|Nibble|Octet|Flag|ExprAdapter|Validator|Hex|HexDump|Probe|Debugger|Peek|IfThenElse|Pass|Terminated|Tell|Seek|Pointer|default_backend|hashlib|sha256|md5)\b/g, className: 'token-class' },
                    { regex: /\b(os|this|ctx|obj|_)\b/g, className: 'token-builtin' },
                    { regex: /\b(0x[0-9A-Fa-f]+|\d+)\b/g, className: 'token-number' },
                    { regex: /[\/=]/g, className: 'token-operator' },
                ];
                
                // Find all matches across all patterns
                const allMatches = [];
                patterns.forEach(pattern => {
                    let match;
                    const regex = new RegExp(pattern.regex.source, pattern.regex.flags);
                    while ((match = regex.exec(code)) !== null) {
                        allMatches.push({
                            start: match.index,
                            end: match.index + match[0].length,
                            text: match[0],
                            className: pattern.className
                        });
                    }
                });
                
                // Sort by position
                allMatches.sort((a, b) => a.start - b.start);
                
                // Remove overlapping matches (keep first match)
                const nonOverlapping = [];
                let lastEnd = 0;
                for (const match of allMatches) {
                    if (match.start >= lastEnd) {
                        nonOverlapping.push(match);
                        lastEnd = match.end;
                    }
                }
                
                // Build highlighted output
                let result = '';
                let pos = 0;
                
                for (const match of nonOverlapping) {
                    // Add text before match (unformatted)
                    if (pos < match.start) {
                        result += escapeHtml(code.substring(pos, match.start));
                    }
                    
                    // Add highlighted match
                    result += `<span class="${match.className}">${escapeHtml(match.text)}</span>`;
                    pos = match.end;
                }
                
                // Add remaining text
                if (pos < code.length) {
                    result += escapeHtml(code.substring(pos));
                }
                
                return result;
            };
            
            return (
                <div className="code-editor-highlighted flex-1" style={{ position: 'relative', background: '#0d1117', overflow: 'hidden' }}>
                    <div 
                        ref={displayRef}
                        className="code-editor-display"
                        style={{ 
                            position: 'absolute',
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0,
                            overflow: 'hidden',
                            pointerEvents: 'none'
                        }}
                    >
                        <div 
                            ref={contentRef}
                            style={{ willChange: 'transform' }}
                            dangerouslySetInnerHTML={{ __html: highlightSyntax(value) }}
                        />
                    </div>
                    <textarea
                        ref={textareaRef}
                        className="code-editor-textarea"
                        value={value}
                        onChange={onChange}
                        onKeyDown={handleKeyDown}
                        onScroll={handleScroll}
                        placeholder={placeholder}
                        spellCheck={spellCheck}
                    />
                </div>
            );
        };

        // Build Form Component
        const BuildForm = ({ structDef, buildValues, onValueChange, onBuild, isParsing }) => {
            const [fields, setFields] = useState([]);
            
            useEffect(() => {
                // Extract field definitions from struct
                const extractFields = () => {
                    const fieldDefs = [];
                    const lines = structDef.split('\n');
                    
                    for (const line of lines) {
                        // Match: "field_name" / Type
                        const match = line.match(/^\s*"([^"]+)"\s*\/\s*(\w+)(\(([^)]+)\))?/);
                        if (match) {
                            const [, name, type, , args] = match;
                            fieldDefs.push({
                                name,
                                type,
                                args: args || '',
                                placeholder: getPlaceholder(type, args)
                            });
                        }
                    }
                    
                    return fieldDefs;
                };
                
                setFields(extractFields());
            }, [structDef]);
            
            const getPlaceholder = (type, args) => {
                if (type === 'Bytes') {
                    const size = args || '4';
                    return 'FF EE DD CC'.substring(0, parseInt(size) * 3 - 1);
                } else if (type.startsWith('Int')) {
                    if (type.includes('8')) return '255';
                    if (type.includes('16')) return '65535';
                    if (type.includes('32')) return '4294967295';
                    return '0';
                } else {
                    return 'value';
                }
            };
            
            return (
                <div className="p-4 h-full overflow-auto scrollbar-thin">
                    <div className="mb-4">
                        <h3 className="text-lg font-semibold mb-2" style={{ color: '#58a6ff' }}>
                            🔨 Build Binary from Template
                        </h3>
                        <p className="text-sm opacity-70 mb-2">
                            Fill in values for each field. Full Construct support including encryption, compression, and dynamic defaults.
                        </p>
                        <div className="text-xs p-2 rounded mb-3" style={{ background: 'rgba(87, 171, 90, 0.1)', border: '1px solid rgba(87, 171, 90, 0.3)', color: '#57ab5a' }}>
                            ✅ <strong>Full Support:</strong> All Construct types supported (EncryptedSym, Compressed, Default, etc.).
                            {fields.some(f => f.name === 'key' || f.name === 'iv') && (
                                <div className="mt-2 pt-2 border-t border-current">
                                    🔐 <strong>Encryption Tip:</strong> For encrypted structures, provide key/iv as hex bytes. 
                                    The inner encrypted fields (width, height, etc.) will be automatically encrypted during build.
                                </div>
                            )}
                        </div>
                    </div>
                    
                    {fields.length === 0 ? (
                        <div className="text-center py-8 opacity-50">
                            <p>No fields detected in structure.</p>
                            <p className="text-xs mt-2">Make sure your Construct definition is valid.</p>
                        </div>
                    ) : (
                        <div className="space-y-3">
                            {fields.map((field) => (
                                <div key={field.name} className="flex flex-col gap-1">
                                    <label className="text-sm font-semibold" style={{ color: '#8b949e' }}>
                                        {field.name}
                                        <span className="ml-2 text-xs opacity-60">({field.type})</span>
                                    </label>
                                    <input
                                        type="text"
                                        className="px-3 py-2 rounded font-mono text-sm"
                                        style={{
                                            background: '#0d1117',
                                            border: '1px solid #30363d',
                                            color: '#c9d1d9'
                                        }}
                                        placeholder={field.placeholder}
                                        value={buildValues[field.name] || ''}
                                        onChange={(e) => onValueChange(field.name, e.target.value)}
                                    />
                                </div>
                            ))}
                            <div className="text-xs opacity-50 mt-2">
                                💡 Tip: For hex values use space-separated bytes (FF EE DD CC). For encryption, inner fields are auto-encrypted.
                            </div>
                        </div>
                    )}
                    
                    <div className="mt-6 flex gap-2">
                        <button
                            onClick={onBuild}
                            disabled={isParsing || fields.length === 0}
                            className="px-6 py-2 rounded font-semibold"
                            style={{
                                background: '#238636',
                                border: '1px solid #2ea043',
                                color: '#fff'
                            }}
                        >
                            {isParsing ? 'Building...' : '🔨 Build Binary'}
                        </button>
                        <div className="text-xs opacity-50 flex items-center">
                            Press Build to create binary from your values
                        </div>
                    </div>
                </div>
            );
        };

        // Structure Tree Component
        const TreeNode = ({ node, depth = 0, onSelect, selectedPath, currentPath = [], onEdit, onHover }) => {
            const [expanded, setExpanded] = useState(true);
            const hasChildren = node.children && node.children.length > 0;
            const isSelected = JSON.stringify(currentPath) === JSON.stringify(selectedPath);
            const canEdit = !hasChildren && node.length > 0;
            
            // Format the size display
            const sizeDisplay = node.length === 1 ? '1 byte' : `${node.length} bytes`;
            
            return (
                <div>
                    <div
                        className={`tree-node ${hasChildren ? 'expandable' : ''} ${expanded ? 'expanded' : ''} ${isSelected ? 'selected' : ''}`}
                        onMouseEnter={() => onHover && onHover(node)}
                        onMouseLeave={() => onHover && onHover(null)}
                    >
                        <div
                            onClick={(e) => {
                                e.stopPropagation();
                                if (hasChildren) {
                                    setExpanded(!expanded);
                                }
                                onSelect(node, currentPath);
                            }}
                            style={{ flex: 1, display: 'flex', flexDirection: 'column' }}
                        >
                            <div className="flex items-center justify-between">
                                <span className="font-semibold text-blue-400">{node.name}</span>
                                <span className="text-xs text-gray-500">
                                    @0x{node.offset.toString(16).padStart(4, '0')} ({sizeDisplay})
                                </span>
                            </div>
                            {node.value !== null && node.value !== undefined && (
                                <div className="text-sm text-gray-300 mt-1 ml-4">
                                    {node.value}
                                </div>
                            )}
                        </div>
                        
                        {canEdit && (
                            <div style={{ display: 'flex', gap: '4px', position: 'relative' }}>
                                <button
                                    className="edit-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        onEdit(node);
                                    }}
                                    title="Edit field value"
                                >
                                    ✏️ Edit
                                </button>
                                <button
                                    className="edit-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        // Toggle export menu
                                        const menu = e.currentTarget.nextElementSibling;
                                        if (menu) {
                                            // Close all other menus first
                                            document.querySelectorAll('.export-menu').forEach(m => {
                                                if (m !== menu) m.style.display = 'none';
                                            });
                                            menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
                                        }
                                    }}
                                    title="Export field data"
                                >
                                    💾
                                </button>
                                <div 
                                    className="export-menu"
                                    style={{ display: 'none' }}
                                    onClick={(e) => e.stopPropagation()}
                                >
                                    <button onClick={(e) => {
                                        e.stopPropagation();
                                        e.currentTarget.parentElement.style.display = 'none';
                                        if (window.onExportField) {
                                            window.onExportField(node, 'python');
                                        }
                                    }}>📋 Copy Python bytes</button>
                                    <button onClick={(e) => {
                                        e.stopPropagation();
                                        e.currentTarget.parentElement.style.display = 'none';
                                        if (window.onExportField) {
                                            window.onExportField(node, 'file');
                                        }
                                    }}>💾 Save as file</button>
                                </div>
                            </div>
                        )}
                    </div>
                    {hasChildren && expanded && (
                        <div className="tree-children">
                            {node.children.map((child, idx) => (
                                <TreeNode
                                    key={idx}
                                    node={child}
                                    depth={depth + 1}
                                    onSelect={onSelect}
                                    selectedPath={selectedPath}
                                    currentPath={[...currentPath, idx]}
                                    onEdit={onEdit}
                                    onHover={onHover}
                                />
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const StructureTree = ({ fields, onFieldSelect, selectedField, onFieldEdit, onFieldHover }) => {
            const [selectedPath, setSelectedPath] = useState(null);
            
            const handleSelect = (node, path) => {
                setSelectedPath(path);
                onFieldSelect(node);
            };
            
            return (
                <div className="space-y-1">
                    {fields.length === 0 ? (
                        <div className="text-gray-500 p-4 text-center">
                            No structure parsed yet. Define a Construct structure and click Parse.
                        </div>
                    ) : (
                        fields.map((field, idx) => (
                            <TreeNode
                                key={idx}
                                node={field}
                                onSelect={handleSelect}
                                selectedPath={selectedPath}
                                currentPath={[idx]}
                                onEdit={onFieldEdit}
                                onHover={onFieldHover}
                            />
                        ))
                    )}
                </div>
            );
        };

        // Main App Component
        const BinTVApp = () => {
            const [fileData, setFileData] = useState(null);
            const [originalFileData, setOriginalFileData] = useState(null);
            const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
            const [fileName, setFileName] = useState('');
            const [structDef, setStructDef] = useState(`# Define your Construct structure here
# Example:
format_struct = Struct(
    "magic" / Bytes(4),
    "version" / Int16ul,
    "size" / Int32ul,
    "data" / Bytes(8),
    "checksum" / Int32ul,
)`);
            const [parsedFields, setParsedFields] = useState([]);
            const [selectedField, setSelectedField] = useState(null);
            const [hoveredField, setHoveredField] = useState(null);
            const [highlightRanges, setHighlightRanges] = useState([]);
            const [isLoading, setIsLoading] = useState(true);
            const [isParsing, setIsParsing] = useState(false);
            const [error, setError] = useState(null);
            const [parseStatus, setParseStatus] = useState('');
            const [editingField, setEditingField] = useState(null);
            
            // Build mode state
            const [isBuildMode, setIsBuildMode] = useState(false);
            const [buildValues, setBuildValues] = useState({});
            
            // PCAP-specific state
            const [isPcapFile, setIsPcapFile] = useState(false);
            const [pcapPackets, setPcapPackets] = useState([]);
            const [currentPacketIndex, setCurrentPacketIndex] = useState(0);
            const [originalPcapData, setOriginalPcapData] = useState(null);
            
            const fileInputRef = useRef(null);
            const parseTimeoutRef = useRef(null);

            useEffect(() => {
                initPyodide().then(() => {
                    setIsLoading(false);
                    setParseStatus('>>> Python environment ready');
                    
                    // Template library diagnostics
                    console.log('📚 CONSTRUCT_LIBRARY loaded with', Object.keys(CONSTRUCT_LIBRARY).length, 'templates');
                    console.log('Available templates:', Object.keys(CONSTRUCT_LIBRARY).sort().join(', '));
                    
                    // Check URL parameters for template
                    const urlParams = new URLSearchParams(window.location.search);
                    const template = urlParams.get('template');
                    if (template && CONSTRUCT_LIBRARY[template]) {
                        setStructDef(CONSTRUCT_LIBRARY[template].code);
                        setParseStatus(`>>> Loaded template: ${CONSTRUCT_LIBRARY[template].name}`);
                    } else if (template) {
                        console.error('Template from URL not found:', template);
                        setParseStatus(`>>> Error: Template "${template}" not found`);
                    }
                }).catch(err => {
                    setError('Failed to initialize Pyodide: ' + err.message);
                    setIsLoading(false);
                });
            }, []);

            // Reactive parsing with debounce
            useEffect(() => {
                if (!fileData || !pyodideReady) return;
                
                // Check if structDef has actual content (not just comments)
                const hasRealContent = structDef.split('\n').some(line => {
                    const trimmed = line.trim();
                    return trimmed && !trimmed.startsWith('#');
                });
                
                if (!hasRealContent) return;
                
                // For PCAP files, parse immediately when packet changes (no debounce)
                if (isPcapFile) {
                    handleParse();
                    return;
                }
                
                // For regular files, use debounced parsing
                // Clear previous timeout
                if (parseTimeoutRef.current) {
                    clearTimeout(parseTimeoutRef.current);
                }
                
                // Set new timeout for debounced parsing
                parseTimeoutRef.current = setTimeout(() => {
                    handleParse();
                }, 500); // Parse 500ms after user stops typing
                
                return () => {
                    if (parseTimeoutRef.current) {
                        clearTimeout(parseTimeoutRef.current);
                    }
                };
            }, [structDef, fileData, pyodideReady, isPcapFile]);

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                setFileName(file.name);
                setParseStatus(`>>> Loading file: ${file.name}`);
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    const arrayBuffer = e.target.result;
                    const uint8Array = new Uint8Array(arrayBuffer);
                    
                    // Check if it's a PCAP file by magic number (more reliable than extension)
                    let isPcap = false;
                    if (uint8Array.length >= 4) {
                        const view = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
                        const magic = view.getUint32(0, true);  // Try little-endian
                        const magicBE = view.getUint32(0, false); // Try big-endian
                        
                        // PCAP: 0xa1b2c3d4 (LE) or 0xd4c3b2a1 (BE)
                        // PCAPNG: 0x0A0D0D0A
                        isPcap = (magic === 0xa1b2c3d4 || magicBE === 0xd4c3b2a1 || magic === 0x0A0D0D0A);
                        
                        if (!isPcap) {
                            // Also check file extension as fallback
                            const fileName = file.name.toLowerCase();
                            isPcap = fileName.endsWith('.pcap') || fileName.endsWith('.pcapng');
                        }
                    }
                    
                    if (isPcap) {
                        try {
                            const packets = parsePcap(uint8Array);
                            setIsPcapFile(true);
                            setPcapPackets(packets);
                            setOriginalPcapData(uint8Array);
                            setCurrentPacketIndex(0);
                            
                            // Load first packet
                            if (packets.length > 0) {
                                setFileData(packets[0].data);
                                setOriginalFileData(new Uint8Array(packets[0].data));
                                setParseStatus(`>>> PCAP loaded: ${packets.length} packets, showing packet 0 (${packets[0].data.length} bytes)`);
                            } else {
                                setParseStatus(`>>> PCAP loaded but contains no packets`);
                            }
                        } catch (err) {
                            console.error('PCAP parsing error:', err);
                            setParseStatus(`>>> PCAP parse error: ${err.message}`);
                            // Fall back to loading as regular binary
                            setIsPcapFile(false);
                            setFileData(uint8Array);
                            setOriginalFileData(new Uint8Array(uint8Array));
                        }
                    } else {
                        // Regular binary file
                        setIsPcapFile(false);
                        setPcapPackets([]);
                        setFileData(uint8Array);
                        setOriginalFileData(new Uint8Array(uint8Array));
                        setHasUnsavedChanges(false);
                        setParseStatus(`>>> File loaded: ${uint8Array.length} bytes`);
                    }
                };
                
                reader.readAsArrayBuffer(file);
            };
            
            // PCAP parsing function (supports both PCAP and PCAPNG)
            const parsePcap = (data) => {
                const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
                const packets = [];
                
                // Check magic number to determine format
                const magic = view.getUint32(0, true);
                const magicBE = view.getUint32(0, false);
                
                // PCAPNG format: 0x0A0D0D0A (Section Header Block)
                if (magic === 0x0A0D0D0A) {
                    console.log('PCAPNG format detected');
                    return parsePcapNG(data, view);
                }
                
                // PCAP format: 0xa1b2c3d4 (LE) or 0xd4c3b2a1 (BE)
                const isLittleEndian = magic === 0xa1b2c3d4;
                const isBigEndian = magicBE === 0xd4c3b2a1;
                
                if (!isLittleEndian && !isBigEndian) {
                    throw new Error('Not a valid PCAP/PCAPNG file (invalid magic number)');
                }
                
                console.log(`PCAP file detected, endianness: ${isLittleEndian ? 'little' : 'big'}`);
                
                // PCAP Global Header is 24 bytes
                let offset = 24;
                let packetNum = 0;
                
                while (offset + 16 <= data.length) {
                    // Packet Header (16 bytes):
                    const ts_sec = view.getUint32(offset, isLittleEndian);
                    const ts_usec = view.getUint32(offset + 4, isLittleEndian);
                    const incl_len = view.getUint32(offset + 8, isLittleEndian);
                    const orig_len = view.getUint32(offset + 12, isLittleEndian);
                    
                    offset += 16;
                    
                    if (offset + incl_len > data.length) {
                        console.warn(`Packet ${packetNum} truncated`);
                        break;
                    }
                    
                    const packetData = new Uint8Array(data.buffer, data.byteOffset + offset, incl_len);
                    
                    packets.push({
                        index: packetNum,
                        timestamp: ts_sec + ts_usec / 1000000,
                        capturedLength: incl_len,
                        originalLength: orig_len,
                        data: packetData,
                        offset: offset
                    });
                    
                    offset += incl_len;
                    packetNum++;
                }
                
                console.log(`Parsed ${packets.length} packets from PCAP`);
                return packets;
            };
            
            // PCAPNG parsing function (simplified - only extracts Enhanced Packet Blocks)
            const parsePcapNG = (data, view) => {
                const packets = [];
                let offset = 0;
                let packetNum = 0;
                
                while (offset + 12 <= data.length) {
                    // Block type (4 bytes) + Block total length (4 bytes)
                    const blockType = view.getUint32(offset, true);
                    const blockLen = view.getUint32(offset + 4, true);
                    
                    if (blockLen < 12 || offset + blockLen > data.length) {
                        console.warn(`Invalid block at offset ${offset}`);
                        break;
                    }
                    
                    // Enhanced Packet Block (type 0x00000006) or Simple Packet Block (type 0x00000003)
                    if (blockType === 0x00000006) {
                        // Enhanced Packet Block
                        // Skip: interface ID (4), timestamp high (4), timestamp low (4)
                        const capturedLen = view.getUint32(offset + 20, true);
                        const originalLen = view.getUint32(offset + 24, true);
                        
                        const dataOffset = offset + 28; // After EPB header
                        
                        if (dataOffset + capturedLen <= offset + blockLen) {
                            const packetData = new Uint8Array(data.buffer, data.byteOffset + dataOffset, capturedLen);
                            
                            const tsHigh = view.getUint32(offset + 12, true);
                            const tsLow = view.getUint32(offset + 16, true);
                            const timestamp = (tsHigh * 0x100000000 + tsLow) / 1000000; // Microseconds to seconds
                            
                            packets.push({
                                index: packetNum,
                                timestamp: timestamp,
                                capturedLength: capturedLen,
                                originalLength: originalLen,
                                data: packetData,
                                offset: dataOffset
                            });
                            
                            packetNum++;
                        }
                    } else if (blockType === 0x00000003) {
                        // Simple Packet Block (older format)
                        const originalLen = view.getUint32(offset + 8, true);
                        const capturedLen = Math.min(originalLen, blockLen - 16);
                        
                        const dataOffset = offset + 12;
                        
                        if (dataOffset + capturedLen <= offset + blockLen) {
                            const packetData = new Uint8Array(data.buffer, data.byteOffset + dataOffset, capturedLen);
                            
                            packets.push({
                                index: packetNum,
                                timestamp: 0,
                                capturedLength: capturedLen,
                                originalLength: originalLen,
                                data: packetData,
                                offset: dataOffset
                            });
                            
                            packetNum++;
                        }
                    }
                    
                    offset += blockLen;
                }
                
                console.log(`Parsed ${packets.length} packets from PCAPNG`);
                return packets;
            };
            
            const handlePacketChange = (newIndex) => {
                if (!isPcapFile || newIndex < 0 || newIndex >= pcapPackets.length) return;
                
                const packet = pcapPackets[newIndex];
                console.log(`📦 Switching to packet ${newIndex}, size: ${packet.data.length} bytes`);
                console.log(`📦 First 16 bytes: ${Array.from(packet.data.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
                
                setCurrentPacketIndex(newIndex);
                setFileData(packet.data);
                setOriginalFileData(new Uint8Array(packet.data));
                setHasUnsavedChanges(false);
                setParseStatus(`>>> Showing packet ${newIndex} of ${pcapPackets.length - 1} (${packet.data.length} bytes)`);
                
                // Parse will be triggered automatically by useEffect when fileData changes
            };

            const flattenFields = (fields, list = []) => {
                fields.forEach((field, topLevelIndex) => {
                    // For top-level fields, add them with their index
                    list.push({
                        offset: field.offset,
                        length: field.length,
                        topLevelIndex: topLevelIndex,  // Track which top-level struct this belongs to
                        name: field.name,
                        value: field.value
                    });
                    // For nested children, inherit the parent's top-level index
                    if (field.children) {
                        flattenFieldsNested(field.children, list, topLevelIndex, field.name);
                    }
                });
                return list;
            };
            
            const flattenFieldsNested = (fields, list, topLevelIndex, parentName) => {
                fields.forEach(field => {
                    list.push({
                        offset: field.offset,
                        length: field.length,
                        topLevelIndex: topLevelIndex,  // Inherit parent's top-level index
                        name: parentName + '.' + field.name,
                        value: field.value
                    });
                    if (field.children) {
                        flattenFieldsNested(field.children, list, topLevelIndex, parentName + '.' + field.name);
                    }
                });
            };

            const handleParse = async () => {
                if (!fileData || !pyodideReady) {
                    console.log('Parse skipped: fileData=', !!fileData, 'pyodideReady=', pyodideReady);
                    return;
                }
                
                console.log('Starting parse with', fileData.length, 'bytes');
                setIsParsing(true);
                setError(null);
                setParseStatus('>>> Parsing structure...');
                
                try {
                    const fields = await parseWithConstruct(fileData, structDef);
                    console.log('Parse result:', fields);
                    setParsedFields(fields);
                    setHighlightRanges(flattenFields(fields));
                    setParseStatus(`>>> Parse complete: ${fields.length} fields`);
                } catch (err) {
                    console.error('Parse error:', err);
                    setError(err.message);
                    setParsedFields([]);
                    setHighlightRanges([]);
                    setParseStatus('>>> Parse error');
                } finally {
                    setIsParsing(false);
                }
            };

            const handleFieldSelect = (field) => {
                setSelectedField(field);
            };
            
            const handleFieldHover = (field) => {
                setHoveredField(field);
            };
            
            const handleFieldEdit = (field) => {
                setEditingField(field);
            };
            
            const handleExportField = (field, format) => {
                if (!fileData || !field || field.length === 0) return;
                
                // Extract the field's bytes from fileData
                const fieldBytes = fileData.slice(field.offset, field.offset + field.length);
                
                if (format === 'python') {
                    // Generate Python bytes literal
                    const hexBytes = Array.from(fieldBytes)
                        .map(b => '\\x' + b.toString(16).padStart(2, '0'))
                        .join('');
                    const pythonCode = `b"${hexBytes}"`;
                    
                    // Copy to clipboard
                    navigator.clipboard.writeText(pythonCode).then(() => {
                        setParseStatus(`>>> Copied ${field.name} as Python bytes (${field.length} bytes)`);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        // Fallback: show in alert
                        alert(`Python bytes:\n${pythonCode}`);
                    });
                } else if (format === 'file') {
                    // Save as binary file
                    const blob = new Blob([fieldBytes], { type: 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    
                    // Generate safe filename
                    const safeFieldName = field.name.replace(/[^a-zA-Z0-9_-]/g, '_');
                    const baseFileName = fileName.replace(/\.[^.]+$/, '');
                    a.download = `${baseFileName}_${safeFieldName}.bin`;
                    
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    setParseStatus(`>>> Exported ${field.name} to file (${field.length} bytes)`);
                }
            };
            
            // Expose to window for menu callbacks
            useEffect(() => {
                window.onExportField = handleExportField;
                
                // Close all export menus when clicking outside
                const handleClickOutside = (e) => {
                    if (!e.target.closest('.export-menu') && !e.target.closest('.edit-btn')) {
                        document.querySelectorAll('.export-menu').forEach(menu => {
                            menu.style.display = 'none';
                        });
                    }
                };
                
                document.addEventListener('click', handleClickOutside);
                
                return () => {
                    delete window.onExportField;
                    document.removeEventListener('click', handleClickOutside);
                };
            }, [fileData, fileName]);
            
            const handleSaveEdit = (offset, newBytes) => {
                // Create a new array with the edited bytes
                const newData = new Uint8Array(fileData);
                newData.set(newBytes, offset);
                setFileData(newData);
                setHasUnsavedChanges(true);
                setParseStatus(`>>> Field edited at 0x${offset.toString(16)}`);
                
                // Re-parse to update the display
                setTimeout(() => handleParse(), 100);
            };
            
            const handleSaveFile = () => {
                if (!fileData) return;
                
                const blob = new Blob([fileData], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName.replace(/(\.[^.]+)?$/, '_modified$1');
                a.click();
                URL.revokeObjectURL(url);
                
                setHasUnsavedChanges(false);
                setOriginalFileData(new Uint8Array(fileData));
                setParseStatus('>>> File saved');
            };
            
            const handleResetChanges = () => {
                if (originalFileData) {
                    setFileData(new Uint8Array(originalFileData));
                    setHasUnsavedChanges(false);
                    setParseStatus('>>> Changes reset');
                    setTimeout(() => handleParse(), 100);
                }
            };
            
            const toggleBuildMode = () => {
                const newMode = !isBuildMode;
                setIsBuildMode(newMode);
                
                if (newMode) {
                    // Entering build mode
                    setParseStatus('>>> 🔨 Build Mode: Create binary from template');
                    setBuildValues({});
                } else {
                    // Leaving build mode  
                    setParseStatus('>>> Parse Mode');
                }
            };
            
            const handleBuildValueChange = (fieldPath, value) => {
                setBuildValues(prev => ({
                    ...prev,
                    [fieldPath]: value
                }));
            };
            
            const handleBuildFromTemplate = async () => {
                if (!pyodideReady) return;
                
                setIsParsing(true);
                setError(null);
                setParseStatus('>>> Building binary...');
                
                try {
                    const valuesJson = JSON.stringify(buildValues);
                    
                    const pythonCode = `
import json
import os
from construct import *

# Import cryptography if available for EncryptedSym
try:
    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
    from cryptography.hazmat.primitives.ciphers import aead
    from cryptography.hazmat.backends import default_backend
except ImportError:
    pass

# Import compression libraries
try:
    import zlib, gzip, bz2, lzma
except ImportError:
    pass

# User's structure definition (with full support)
${structDef}

# Find structure
struct_obj = None
for name in ['format_struct', 'fomrst_struct', 'struct', 'format', 'packet', 'header']:
    if name in globals() and isinstance(globals()[name], Construct):
        struct_obj = globals()[name]
        break

if not struct_obj:
    raise Exception("No Construct structure found. Define format_struct = Struct(...)")

values_dict = json.loads('''${valuesJson}''')

# Build container from values
container = Container()

for key, value in values_dict.items():
    if isinstance(value, str):
        # Try to parse as hex
        clean_value = value.replace(' ', '').replace('\\n', '').strip()
        if all(c in '0123456789ABCDEFabcdef' for c in clean_value) and len(clean_value) % 2 == 0:
            # Hex string
            container[key] = bytes.fromhex(clean_value)
        else:
            # Try as number first
            try:
                # Check if it looks like a number
                if clean_value.isdigit() or (clean_value.startswith('-') and clean_value[1:].isdigit()):
                    container[key] = int(value)
                else:
                    # Keep as string bytes
                    container[key] = value.encode('utf-8') if isinstance(value, str) else value
            except ValueError:
                # Keep as string
                container[key] = value.encode('utf-8') if isinstance(value, str) else value
    else:
        container[key] = value

# Build binary with context support
# Note: For encryption, the key/iv are read from the container itself during build
binary_data = struct_obj.build(container)
binary_data.hex()
`;

                    const hexResult = await pyodide.runPythonAsync(pythonCode);
                    
                    // Convert hex to bytes
                    const bytes = [];
                    for (let i = 0; i < hexResult.length; i += 2) {
                        bytes.push(parseInt(hexResult.substr(i, 2), 16));
                    }
                    
                    const builtData = new Uint8Array(bytes);
                    setFileData(builtData);
                    setOriginalFileData(new Uint8Array(builtData));
                    setFileName('built.bin');
                    setHasUnsavedChanges(true);
                    setParseStatus(`>>> ✅ Built ${builtData.length} bytes`);
                    
                    // Auto-parse the built data
                    setTimeout(() => handleParse(), 100);
                    
                } catch (err) {
                    console.error('Build error:', err);
                    
                    // Extract meaningful error message
                    let errorMsg = err.message;
                    if (errorMsg.includes('PythonError:')) {
                        // Try to extract the actual error
                        const lines = errorMsg.split('\n');
                        for (let i = lines.length - 1; i >= 0; i--) {
                            if (lines[i].trim() && !lines[i].includes('File ') && !lines[i].includes('at ')) {
                                errorMsg = lines[i].trim();
                                break;
                            }
                        }
                    }
                    
                    setError('Build failed: ' + errorMsg);
                    setParseStatus('>>> ❌ Build failed');
                } finally {
                    setIsParsing(false);
                }
            };

            const handleExportSVG = () => {
                if (!fileData || parsedFields.length === 0) {
                    alert('Please load a file and parse it first!');
                    return;
                }
                
                // Generate SVG
                const svg = generateSVG(fileData, parsedFields);
                
                // Create blob and download
                const blob = new Blob([svg], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${fileName}_structure.svg`;
                a.click();
                URL.revokeObjectURL(url);
                
                setParseStatus('>>> SVG exported successfully');
            };
            
            const generateSVG = (data, fields) => {
                const bytesPerLine = 16;
                const lineHeight = 20;
                const charWidth = 10;
                const offsetWidth = 100;
                const hexWidth = bytesPerLine * charWidth * 3;
                const margin = 20;
                const headerHeight = 60;
                
                // Color palette (matches CSS)
                const colors = [
                    '#f85149', '#f6ad55', '#57ab5a', '#58a6ff',
                    '#bc80f0', '#ff79c6', '#79c0ff', '#ff9e64'
                ];
                
                // Build the flattened list with top-level tracking
                const flattenedRanges = flattenFields(fields);
                
                // Group ranges by top-level index for legend
                const topLevelGroups = [];
                fields.forEach((field, idx) => {
                    const groupRanges = flattenedRanges.filter(r => r.topLevelIndex === idx);
                    if (groupRanges.length > 0) {
                        topLevelGroups.push({
                            name: field.name,
                            color: colors[idx % colors.length],
                            ranges: groupRanges
                        });
                    }
                });
                
                // Calculate SVG dimensions
                const numLines = Math.ceil(data.length / bytesPerLine);
                const hexViewHeight = numLines * lineHeight + headerHeight;
                
                // Legend height based on number of ranges (not groups)
                const legendHeight = flattenedRanges.length * 25 + 40;
                const totalHeight = hexViewHeight + legendHeight + margin * 3;
                const totalWidth = offsetWidth + hexWidth + margin * 4;
                
                console.log(`SVG Export: ${flattenedRanges.length} ranges in ${topLevelGroups.length} top-level groups`);
                
                let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${totalWidth}" height="${totalHeight}" viewBox="0 0 ${totalWidth} ${totalHeight}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      text { font-family: 'JetBrains Mono', 'Courier New', monospace; font-size: 12px; }
      .offset { fill: #58a6ff; font-weight: 600; }
      .hex { fill: #8b949e; }
      .title { fill: #c9d1d9; font-size: 18px; font-weight: 600; }
      .subtitle { fill: #8b949e; font-size: 12px; }
      .field-name { fill: #c9d1d9; font-weight: 500; }
      .field-value { fill: #8b949e; font-size: 11px; }
    </style>
  </defs>
  
  <!-- Background -->
  <rect width="${totalWidth}" height="${totalHeight}" fill="#0d1117"/>
  
  <!-- Header -->
  <text x="${margin}" y="${margin + 20}" class="title">Binary Structure Visualization</text>
  <text x="${margin}" y="${margin + 38}" class="subtitle">File: ${fileName} (${data.length} bytes)</text>
  
  <!-- Hex Dump -->
  <g transform="translate(${margin}, ${headerHeight})">
`;
                
                // Draw hex dump with highlights using top-level coloring
                for (let i = 0; i < data.length; i += bytesPerLine) {
                    const lineNum = Math.floor(i / bytesPerLine);
                    const y = lineNum * lineHeight + 20;
                    
                    // Offset
                    svg += `    <text x="0" y="${y}" class="offset">${i.toString(16).padStart(8, '0').toUpperCase()}</text>\n`;
                    
                    // Hex bytes
                    for (let j = 0; j < bytesPerLine && i + j < data.length; j++) {
                        const byte = data[i + j];
                        const x = offsetWidth + j * charWidth * 3;
                        const byteIndex = i + j;
                        
                        // Find which range this byte belongs to
                        let rangeColor = null;
                        for (let r = 0; r < flattenedRanges.length; r++) {
                            const range = flattenedRanges[r];
                            if (byteIndex >= range.offset && byteIndex < range.offset + range.length) {
                                rangeColor = colors[range.topLevelIndex % colors.length];
                                break;
                            }
                        }
                        
                        if (rangeColor) {
                            svg += `    <rect x="${x - 2}" y="${y - 14}" width="${charWidth * 2.5}" height="16" fill="${rangeColor}" opacity="0.3" rx="2"/>\n`;
                        }
                        
                        svg += `    <text x="${x}" y="${y}" class="hex">${byte.toString(16).padStart(2, '0').toUpperCase()}</text>\n`;
                    }
                }
                
                svg += `  </g>\n`;
                
                // Legend - grouped by top-level structure
                const legendY = hexViewHeight + margin * 2;
                svg += `  <g transform="translate(${margin}, ${legendY})">
    <text x="0" y="0" class="title" font-size="14">Parsed Fields (Colored by Top-Level Structure)</text>
`;
                
                let currentY = 10;
                topLevelGroups.forEach((group) => {
                    // Group header
                    currentY += 25;
                    svg += `    <rect x="0" y="${currentY - 12}" width="12" height="12" fill="${group.color}" opacity="0.6" rx="2"/>\n`;
                    svg += `    <text x="18" y="${currentY}" class="field-name" font-weight="600">${group.name}</text>\n`;
                    
                    // Group members (indented)
                    group.ranges.forEach((range) => {
                        currentY += 20;
                        const fieldValue = range.value || '';
                        
                        svg += `    <rect x="20" y="${currentY - 10}" width="8" height="8" fill="${group.color}" opacity="0.4" rx="1"/>\n`;
                        svg += `    <text x="35" y="${currentY}" class="field-value" font-size="11">${range.name}</text>\n`;
                        svg += `    <text x="250" y="${currentY}" class="field-value">@0x${range.offset.toString(16).padStart(4, '0')} (${range.length} bytes)</text>\n`;
                        if (fieldValue) {
                            const displayValue = fieldValue.length > 30 ? fieldValue.substring(0, 30) + '...' : fieldValue;
                            svg += `    <text x="450" y="${currentY}" class="field-value">${displayValue}</text>\n`;
                        }
                    });
                });
                
                svg += `  </g>\n`;
                svg += `</svg>`;
                
                return svg;
            };

            const loadSampleFile = () => {
                // Create a sample binary file (ZIP header-like)
                // 4 + 2 + 2 + 4 + 8 + 4 = 24 bytes total
                const sample = new Uint8Array([
                    0x50, 0x4B, 0x03, 0x04,                         // Magic: PK (ZIP signature) - 4 bytes
                    0x14, 0x00,                                     // Version: 20 (0x0014) - 2 bytes  
                    0x00, 0x00,                                     // Flags: 0 - 2 bytes
                    0x08, 0x00, 0x00, 0x00,                         // Size: 8 - 4 bytes
                    0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x57, 0x6F, // Data: "Hello Wo" - 8 bytes
                    0xDE, 0xAD, 0xBE, 0xEF                          // Checksum: 0xEFBEADDE - 4 bytes
                ]);
                
                setFileData(sample);
                setOriginalFileData(new Uint8Array(sample));
                setHasUnsavedChanges(false);
                setFileName('sample.bin');
                setParseStatus(`>>> Sample loaded: ${sample.length} bytes`);
                
                // Set sample structure
                setStructDef(`# Sample ZIP-like structure
format_struct = Struct(
    "magic" / Bytes(4),
    "version" / Int16ul,
    "flags" / Int16ul,
    "size" / Int32ul,
    "data" / Bytes(8),
    "checksum" / Int32ul,
)`);
            };

            if (isLoading) {
                return (
                    <div className="h-screen flex items-center justify-center" style={{ background: '#0d1117' }}>
                        <div className="text-center">
                            <div className="loading-spinner mx-auto mb-4"></div>
                            <h2 className="text-2xl font-semibold" style={{ color: '#58a6ff' }}>Initializing Python Environment</h2>
                            <p className="mt-2 text-base" style={{ color: '#8b949e' }}>Loading Pyodide and Construct library...</p>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-screen flex flex-col" style={{ background: '#0d1117' }}>
                    {editingField && (
                        <EditModal
                            field={editingField}
                            onClose={() => setEditingField(null)}
                            onSave={handleSaveEdit}
                        />
                    )}
                    
                    {/* Header */}
                    <header className="terminal-border p-4" style={{ background: '#161b22' }}>
                        <div className="flex items-center justify-between">
                            <div className="flex items-center space-x-4">
                                <h1 className="text-2xl font-semibold" style={{ color: '#58a6ff' }}>
                                    BinTV
                                </h1>
                                <span className="text-sm opacity-70">Binary Structure Viewer v1.0</span>
                                {hasUnsavedChanges && (
                                    <span className="text-sm px-2 py-1 rounded" style={{ background: '#f6ad55', color: '#000' }}>
                                        • Modified
                                    </span>
                                )}
                            </div>
                            
                            <div className="flex items-center space-x-2">
                                <button
                                    onClick={loadSampleFile}
                                    disabled={isLoading}
                                    className="px-4 py-2 btn-terminal rounded"
                                >
                                    Sample
                                </button>
                                <input
                                    type="file"
                                    ref={fileInputRef}
                                    onChange={handleFileUpload}
                                    accept="*,.pcap,.pcapng"
                                />
                                <button
                                    onClick={() => fileInputRef.current?.click()}
                                    disabled={isLoading}
                                    className="px-4 py-2 btn-terminal rounded"
                                >
                                    Open File
                                </button>
                                <button
                                    onClick={toggleBuildMode}
                                    disabled={isLoading || isPcapFile}
                                    className="px-4 py-2 btn-terminal rounded"
                                    style={isBuildMode ? { background: '#238636', borderColor: '#2ea043', color: '#fff' } : {}}
                                    title="Build binary from template"
                                >
                                    {isBuildMode ? '🔨 Build Mode' : '🔨 Build'}
                                </button>
                                {hasUnsavedChanges && (
                                    <>
                                        <button
                                            onClick={handleResetChanges}
                                            className="px-4 py-2 btn-terminal rounded"
                                            title="Reset all changes"
                                        >
                                            Reset
                                        </button>
                                        <button
                                            onClick={handleSaveFile}
                                            className="px-4 py-2 btn-terminal rounded"
                                            title="Save modified file"
                                        >
                                            Save File
                                        </button>
                                    </>
                                )}
                                <button
                                    onClick={handleExportSVG}
                                    disabled={!fileData || parsedFields.length === 0 || isLoading}
                                    className="px-4 py-2 btn-terminal rounded"
                                >
                                    Export SVG
                                </button>
                            </div>
                        </div>
                        
                        {/* PCAP Packet Navigation Bar */}
                        {isPcapFile && pcapPackets.length > 0 && (
                            <div className="mb-4 p-3 rounded" style={{ background: '#161b22', border: '1px solid #30363d' }}>
                                <div className="flex items-center justify-between mb-2">
                                    <div className="flex items-center gap-2">
                                        <span className="text-sm font-semibold" style={{ color: '#58a6ff' }}>📦 PCAP Mode</span>
                                        <span className="text-xs opacity-70">{pcapPackets.length} packets total</span>
                                    </div>
                                </div>
                                <div className="flex items-center justify-between gap-3">
                                    <div className="flex items-center gap-2">
                                        <button
                                            className="px-2 py-1 text-xs rounded btn-terminal"
                                            onClick={() => handlePacketChange(0)}
                                            disabled={currentPacketIndex === 0}
                                        >
                                            ⏮ First
                                        </button>
                                        <button
                                            className="px-2 py-1 text-xs rounded btn-terminal"
                                            onClick={() => handlePacketChange(currentPacketIndex - 1)}
                                            disabled={currentPacketIndex === 0}
                                        >
                                            ◀ Prev
                                        </button>
                                        <span className="text-sm font-mono px-3" style={{ color: '#58a6ff' }}>
                                            Packet {currentPacketIndex} / {pcapPackets.length - 1}
                                        </span>
                                        <button
                                            className="px-2 py-1 text-xs rounded btn-terminal"
                                            onClick={() => handlePacketChange(currentPacketIndex + 1)}
                                            disabled={currentPacketIndex >= pcapPackets.length - 1}
                                        >
                                            Next ▶
                                        </button>
                                        <button
                                            className="px-2 py-1 text-xs rounded btn-terminal"
                                            onClick={() => handlePacketChange(pcapPackets.length - 1)}
                                            disabled={currentPacketIndex >= pcapPackets.length - 1}
                                        >
                                            Last ⏭
                                        </button>
                                        <span className="text-xs opacity-50 px-2">|</span>
                                        <span className="text-xs opacity-70">Go to:</span>
                                        <input
                                            type="number"
                                            className="w-20 px-2 py-1 text-xs rounded"
                                            style={{ background: '#0d1117', border: '1px solid #30363d', color: '#c9d1d9' }}
                                            min="0"
                                            max={pcapPackets.length - 1}
                                            value={currentPacketIndex}
                                            onChange={(e) => handlePacketChange(parseInt(e.target.value) || 0)}
                                        />
                                    </div>
                                    <div className="text-xs opacity-70">
                                        Captured: {pcapPackets[currentPacketIndex].capturedLength}B • 
                                        Original: {pcapPackets[currentPacketIndex].originalLength}B
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        <div className="mt-2 text-sm flex items-center justify-between">
                            <div>
                                {fileName && (
                                    <>
                                        <span style={{ color: '#58a6ff' }}>File:</span>
                                        <span className="ml-2">{fileName}</span>
                                        {fileData && (
                                            <span className="ml-4">
                                                <span style={{ color: '#58a6ff' }}>Size:</span>
                                                <span className="ml-2">{fileData.length} bytes</span>
                                            </span>
                                        )}
                                    </>
                                )}
                            </div>
                            <div className="flex items-center space-x-2">
                                {isParsing && (
                                    <span style={{ color: '#f6ad55' }}>
                                        Parsing...
                                    </span>
                                )}
                                {parseStatus && !isParsing && (
                                    <span className="opacity-70">{parseStatus}</span>
                                )}
                            </div>
                        </div>
                    </header>

                    {/* Main Content */}
                    <div className="flex-1 flex overflow-hidden">
                        {/* Left Panel - Structure Editor */}
                        <div className="w-1/3 flex flex-col panel" style={{ borderRight: '1px solid #30363d' }}>
                            <div className="terminal-title flex items-center justify-between">
                                <span>Construct Structure Definition</span>
                                <div className="flex items-center space-x-2">
                                    {isParsing && <span style={{ color: '#f6ad55', fontSize: '12px' }}>
                                        {isBuildMode ? 'Building...' : 'Parsing...'}
                                    </span>}
                                    {!isBuildMode && (
                                        <button
                                            onClick={handleParse}
                                            disabled={!fileData || !pyodideReady || isParsing}
                                            className="px-3 py-1 btn-terminal rounded"
                                            title="Manual parse (or auto-parses on edit)"
                                        >
                                            Parse
                                        </button>
                                    )}
                                </div>
                            </div>
                            
                            {/* Template Selector */}
                            <div className="p-2" style={{ borderBottom: '1px solid #30363d', background: '#161b22' }}>
                                <div className="flex items-center gap-2 mb-2">
                                    <label className="text-xs" style={{ color: '#8b949e' }}>Load Template:</label>
                                    <div className="flex-1 flex items-center gap-1">
                                        <select
                                            className="flex-1 px-2 py-1 text-xs rounded"
                                            style={{ 
                                                background: '#0d1117', 
                                                border: '1px solid #30363d', 
                                                color: '#c9d1d9',
                                                cursor: 'pointer'
                                            }}
                                            onChange={(e) => {
                                                const templateKey = e.target.value;
                                                console.log('📋 Template selected:', templateKey);
                                                
                                                if (templateKey && CONSTRUCT_LIBRARY[templateKey]) {
                                                    const template = CONSTRUCT_LIBRARY[templateKey];
                                                    console.log('✅ Loading template:', template.name);
                                                    setStructDef(template.code);
                                                    setParseStatus(`>>> Loaded: ${template.name}`);
                                                    setError(null); // Clear any previous errors
                                                    // Reset dropdown to allow re-selection
                                                    e.target.value = "";
                                                } else if (templateKey) {
                                                    console.error('❌ Template not found in library:', templateKey);
                                                    console.log('Available templates:', Object.keys(CONSTRUCT_LIBRARY).sort());
                                                    setParseStatus(`>>> Error: Template "${templateKey}" not found in library`);
                                                    setError(`Template "${templateKey}" exists in dropdown but not in CONSTRUCT_LIBRARY. This is a bug.`);
                                                }
                                            }}
                                            value=""
                                        >
                                            <option value="">-- Select a template --</option>
                                            <optgroup label="📡 Network - Full Stack">
                                                <option value="full_tcp">Full TCP Packet (Eth+IP+TCP)</option>
                                                <option value="full_udp">Full UDP Packet (Eth+IP+UDP)</option>
                                                <option value="full_dns">Full DNS Packet (Eth+IP+UDP+DNS)</option>
                                                <option value="full_dhcp">Full DHCP Packet (Eth+IP+UDP+DHCP)</option>
                                                <option value="full_arp">Full ARP Packet (Eth+ARP)</option>
                                            </optgroup>
                                            <optgroup label="📁 Files - Executables & Archives">
                                                <option value="elf">ELF Header (64-bit)</option>
                                                <option value="pe">PE Header (Windows)</option>
                                                <option value="zip">ZIP Local File Header</option>
                                                <option value="gzip">GZIP Header</option>
                                                <option value="tar">TAR Header (POSIX)</option>
                                                <option value="png">PNG Chunk</option>
                                                <option value="jpeg">JPEG Segment</option>
                                            </optgroup>
                                            <optgroup label="🔧 Firmware - Filesystems">
                                                <option value="squashfs">SquashFS Superblock</option>
                                                <option value="ext4">EXT2/3/4 Superblock</option>
                                                <option value="cpio">CPIO Archive (newc/initramfs)</option>
                                            </optgroup>
                                            <optgroup label="💡 Examples - Advanced Features">
                                                <option value="aes_encrypted">🔐 AES Encrypted (EncryptedSym)</option>
                                                <option value="compressed_data">🗜️ Compressed (zlib)</option>
                                                <option value="checksummed">✓ Checksummed (SHA256)</option>
                                                <option value="xor_encoded">🔀 XOR Encoded (ProcessXor)</option>
                                                <option value="null_terminated">∅ Null-Terminated String</option>
                                                <option value="prefixed_array">📊 Prefixed Array</option>
                                            </optgroup>
                                        </select>
                                    </div>
                                </div>
                                <div className="text-xs px-1" style={{ color: '#6e7681', lineHeight: '1.4' }}>
                                    💡 Templates support dynamic fields using <code>this.field.value</code> pattern (e.g., <code>Bytes(this.length.value)</code>)
                                </div>
                            </div>
                            
                            <div className="flex-1 flex flex-col">
                                <CodeEditor
                                    value={structDef}
                                    onChange={(e) => setStructDef(e.target.value)}
                                    placeholder="# Define Construct structure"
                                    spellCheck={false}
                                />
                            </div>
                            
                            {error && (
                                <div className="m-2 error-box rounded">
                                    <div className="font-semibold mb-1" style={{ fontSize: '12px' }}>⚠️ Parse Error:</div>
                                    <pre className="whitespace-pre-wrap overflow-auto max-h-32" style={{ fontSize: '11px' }}>
                                        {error}
                                    </pre>
                                    {error.includes('this.') && (
                                        <div className="mt-2 p-2 rounded" style={{ background: 'rgba(246, 173, 85, 0.1)', border: '1px solid rgba(246, 173, 85, 0.3)' }}>
                                            <div className="text-xs" style={{ color: '#f6ad55' }}>
                                                💡 <strong>Hint:</strong> Dynamic fields need <code>.value</code> when wrapped with RawCopy. 
                                                Use <code>this.field.value</code> instead of <code>this.field</code>.
                                                <br/>
                                                Example: <code>Bytes(this.length.value)</code>
                                            </div>
                                        </div>
                                    )}
                                    {error.includes('not enough bytes') && (
                                        <div className="mt-2 p-2 rounded" style={{ background: 'rgba(246, 173, 85, 0.1)', border: '1px solid rgba(246, 173, 85, 0.3)' }}>
                                            <div className="text-xs" style={{ color: '#f6ad55' }}>
                                                💡 <strong>Hint:</strong> The file is too small for this structure. This template expects more bytes than available.
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}
                            
                            <div className="flex-1 overflow-hidden flex flex-col" style={{ borderTop: '1px solid #30363d' }}>
                                <div className="terminal-title">
                                    {isBuildMode ? '🔨 Build Values' : `Parsed Structure (${parsedFields.length})`}
                                </div>
                                <div className={`flex-1 overflow-y-auto scrollbar-thin ${isBuildMode ? '' : 'p-2'}`}>
                                    {isBuildMode ? (
                                        <BuildForm
                                            structDef={structDef}
                                            buildValues={buildValues}
                                            onValueChange={handleBuildValueChange}
                                            onBuild={handleBuildFromTemplate}
                                            isParsing={isParsing}
                                        />
                                    ) : (
                                        <StructureTree
                                            fields={parsedFields}
                                            onFieldSelect={handleFieldSelect}
                                            selectedField={selectedField}
                                            onFieldEdit={handleFieldEdit}
                                            onFieldHover={handleFieldHover}
                                        />
                                    )}
                                </div>
                            </div>
                        </div>

                        {/* Right Panel - Hex View */}
                        <div className="flex-1 flex flex-col panel">
                            <div className="terminal-title">
                                Hex Dump
                            </div>
                            
                            <div className="flex-1 overflow-hidden scrollbar-thin" style={{ background: '#0d1117' }}>
                                {fileData ? (
                                    <HexView
                                        data={fileData}
                                        highlightRanges={highlightRanges}
                                        selectedField={selectedField}
                                        hoveredField={hoveredField}
                                    />
                                ) : (
                                    <div className="h-full flex items-center justify-center">
                                        <div className="text-center">
                                            <div className="text-6xl mb-4" style={{ opacity: 0.3 }}>📁</div>
                                            <h3 className="text-xl font-semibold mb-2" style={{ color: '#8b949e' }}>
                                                No file loaded
                                            </h3>
                                            <p style={{ color: '#6e7681', fontSize: '15px' }}>
                                                Click "Open File" or "Sample" to get started
                                            </p>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* Footer */}
                    <footer className="terminal-border p-2 text-center" style={{ background: '#161b22', opacity: 0.7, fontSize: '12px' }}>
                        <span>BinTV • Binary Structure Viewer • Powered by Pyodide &amp; Construct</span>
                    </footer>
                </div>
            );
        };

        // Render app
        ReactDOM.render(<BinTVApp />, document.getElementById('root'));

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'o') {
                e.preventDefault();
                document.querySelector('input[type="file"]')?.click();
            }
        });
    </script>
</body>
</html>