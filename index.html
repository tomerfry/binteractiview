<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BinTV Web - Binary Structure Viewer (Focused Edition)</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap');
        
        body {
            margin: 0;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            background: #0d1117;
            color: #c9d1d9;
            overflow: hidden;
        }
        
        .terminal-border {
            border: 1px solid #30363d;
            box-shadow: 0 0 10px rgba(48, 54, 61, 0.3);
        }
        
        .terminal-glow {
            text-shadow: 0 0 2px rgba(88, 166, 255, 0.3);
        }
        
        .hex-cell {
            display: inline-block;
            padding: 2px 4px;
            margin: 0;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #8b949e;
            background: rgba(110, 118, 129, 0.05);
            font-size: 14px;
            position: relative;
        }
        
        .hex-cell:hover {
            background: rgba(88, 166, 255, 0.2);
            color: #58a6ff;
        }
        
        .hex-offset {
            color: #58a6ff;
            font-weight: 600;
            user-select: none;
            display: inline-block;
            width: 100px;
            font-size: 14px;
        }
        
        .ascii-char {
            display: inline-block;
            width: 1ch;
            text-align: center;
            color: #8b949e;
            opacity: 0.8;
            padding: 2px 1px;
            font-size: 14px;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .field-highlight-0 { 
            background: rgba(248, 81, 73, 0.4); 
            box-shadow: 0 0 8px rgba(248, 81, 73, 0.6), inset 0 0 4px rgba(248, 81, 73, 0.3);
            color: #ff9b97 !important;
        }
        .field-highlight-0.hovered {
            background: rgba(248, 81, 73, 0.7) !important;
            box-shadow: 0 0 16px rgba(248, 81, 73, 1), inset 0 0 8px rgba(248, 81, 73, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-1 { 
            background: rgba(246, 173, 85, 0.4); 
            box-shadow: 0 0 8px rgba(246, 173, 85, 0.6), inset 0 0 4px rgba(246, 173, 85, 0.3);
            color: #ffc98e !important;
        }
        .field-highlight-1.hovered {
            background: rgba(246, 173, 85, 0.7) !important;
            box-shadow: 0 0 16px rgba(246, 173, 85, 1), inset 0 0 8px rgba(246, 173, 85, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-2 { 
            background: rgba(87, 171, 90, 0.4); 
            box-shadow: 0 0 8px rgba(87, 171, 90, 0.6), inset 0 0 4px rgba(87, 171, 90, 0.3);
            color: #a0e3a3 !important;
        }
        .field-highlight-2.hovered {
            background: rgba(87, 171, 90, 0.7) !important;
            box-shadow: 0 0 16px rgba(87, 171, 90, 1), inset 0 0 8px rgba(87, 171, 90, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-3 { 
            background: rgba(88, 166, 255, 0.4); 
            box-shadow: 0 0 8px rgba(88, 166, 255, 0.6), inset 0 0 4px rgba(88, 166, 255, 0.3);
            color: #a8d4ff !important;
        }
        .field-highlight-3.hovered {
            background: rgba(88, 166, 255, 0.7) !important;
            box-shadow: 0 0 16px rgba(88, 166, 255, 1), inset 0 0 8px rgba(88, 166, 255, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-4 { 
            background: rgba(188, 128, 240, 0.4); 
            box-shadow: 0 0 8px rgba(188, 128, 240, 0.6), inset 0 0 4px rgba(188, 128, 240, 0.3);
            color: #d4b3ff !important;
        }
        .field-highlight-4.hovered {
            background: rgba(188, 128, 240, 0.7) !important;
            box-shadow: 0 0 16px rgba(188, 128, 240, 1), inset 0 0 8px rgba(188, 128, 240, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-5 { 
            background: rgba(255, 121, 198, 0.4); 
            box-shadow: 0 0 8px rgba(255, 121, 198, 0.6), inset 0 0 4px rgba(255, 121, 198, 0.3);
            color: #ffa3d9 !important;
        }
        .field-highlight-5.hovered {
            background: rgba(255, 121, 198, 0.7) !important;
            box-shadow: 0 0 16px rgba(255, 121, 198, 1), inset 0 0 8px rgba(255, 121, 198, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-6 { 
            background: rgba(121, 192, 255, 0.4); 
            box-shadow: 0 0 8px rgba(121, 192, 255, 0.6), inset 0 0 4px rgba(121, 192, 255, 0.3);
            color: #b3d9ff !important;
        }
        .field-highlight-6.hovered {
            background: rgba(121, 192, 255, 0.7) !important;
            box-shadow: 0 0 16px rgba(121, 192, 255, 1), inset 0 0 8px rgba(121, 192, 255, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        .field-highlight-7 { 
            background: rgba(255, 158, 100, 0.4); 
            box-shadow: 0 0 8px rgba(255, 158, 100, 0.6), inset 0 0 4px rgba(255, 158, 100, 0.3);
            color: #ffb380 !important;
        }
        .field-highlight-7.hovered {
            background: rgba(255, 158, 100, 0.7) !important;
            box-shadow: 0 0 16px rgba(255, 158, 100, 1), inset 0 0 8px rgba(255, 158, 100, 0.6) !important;
            color: #fff !important;
            font-weight: 700 !important;
            transform: scale(1.05);
            z-index: 10;
        }
        
        .tree-node {
            cursor: pointer;
            padding: 4px 6px;
            margin: 2px 0;
            transition: all 0.15s;
            user-select: none;
            border-left: 2px solid transparent;
            color: #c9d1d9;
            font-size: 13px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }
        
        .tree-node:hover {
            background: rgba(88, 166, 255, 0.1);
            border-left: 2px solid #58a6ff;
        }
        
        .tree-node:hover .edit-btn {
            opacity: 1;
        }
        
        .tree-node.selected {
            background: rgba(88, 166, 255, 0.15);
            border-left: 2px solid #58a6ff;
        }

        .tree-node.expandable::before {
            content: '▶';
            display: inline-block;
            margin-right: 4px;
            transition: transform 0.2s;
            color: #58a6ff;
        }

        .tree-node.expandable.expanded::before {
            transform: rotate(90deg);
        }
        
        .edit-btn {
            opacity: 0;
            transition: opacity 0.2s;
            padding: 2px 6px;
            font-size: 11px;
            background: #21262d;
            border: 1px solid #30363d;
            color: #58a6ff;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .edit-btn:hover {
            background: #30363d;
            border-color: #58a6ff;
        }
        
        .export-menu {
            position: absolute;
            right: 0;
            top: 100%;
            margin-top: 4px;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 4px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            min-width: 180px;
        }
        
        .export-menu button {
            display: block;
            width: 100%;
            padding: 8px 12px;
            text-align: left;
            background: transparent;
            border: none;
            color: #c9d1d9;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .export-menu button:hover {
            background: #21262d;
            color: #58a6ff;
        }
        
        .export-menu button:first-child {
            border-radius: 4px 4px 0 0;
        }
        
        .export-menu button:last-child {
            border-radius: 0 0 4px 4px;
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }
        
        .modal-content {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 20px;
            min-width: 400px;
            max-width: 600px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .modal-input {
            width: 100%;
            padding: 8px 12px;
            background: #0d1117;
            border: 1px solid #30363d;
            color: #c9d1d9;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }
        
        .modal-input:focus {
            outline: none;
            border-color: #58a6ff;
            box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.1);
        }
        
        input[type="file"] {
            display: none;
        }
        
        .scrollbar-thin::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .scrollbar-thin::-webkit-scrollbar-track {
            background: rgba(110, 118, 129, 0.1);
        }
        
        .scrollbar-thin::-webkit-scrollbar-thumb {
            background: rgba(88, 166, 255, 0.3);
            border-radius: 3px;
        }
        
        .scrollbar-thin::-webkit-scrollbar-thumb:hover {
            background: rgba(88, 166, 255, 0.5);
        }

        .code-editor {
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            background: #0d1117;
            color: #c9d1d9;
            border: 1px solid #30363d;
            font-size: 13px;
        }

        .btn-terminal {
            background: #21262d;
            border: 1px solid #30363d;
            color: #58a6ff;
            transition: all 0.2s;
            font-weight: 500;
            font-size: 13px;
        }

        .btn-terminal:hover:not(:disabled) {
            background: #30363d;
            border-color: #58a6ff;
        }

        .btn-terminal:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .hex-line {
            display: flex;
            align-items: center;
            margin: 0;
            padding: 2px 0;
            transition: background 0.1s;
            white-space: nowrap;
        }

        .hex-line:hover {
            background: rgba(110, 118, 129, 0.05);
        }

        .loading-spinner {
            border: 2px solid rgba(88, 166, 255, 0.2);
            border-top: 2px solid #58a6ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-box {
            background: rgba(248, 81, 73, 0.1);
            border: 1px solid rgba(248, 81, 73, 0.3);
            box-shadow: 0 0 5px rgba(248, 81, 73, 0.1);
            padding: 8px;
            margin: 8px 0;
            color: #ff7b72;
            font-size: 12px;
        }

        .tree-children {
            margin-left: 15px;
            border-left: 1px solid rgba(88, 166, 255, 0.2);
            padding-left: 8px;
        }
        
        .terminal-title {
            background: #161b22;
            border-bottom: 1px solid #30363d;
            padding: 10px;
            color: #58a6ff;
            font-weight: 600;
            font-size: 13px;
        }
        
        .blink {
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .panel {
            background: #0d1117;
            border: 1px solid #30363d;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script>
        // Construct Library - Focused, Dynamic Templates
        const CONSTRUCT_LIBRARY = {
            // ===== NETWORK - Full Stack Protocols =====
            
            "full_tcp": {
                name: "Full TCP Packet (Eth+IP+TCP)",
                description: "Complete TCP packet: Ethernet + IPv4 + TCP headers",
                category: "Network",
                code: `# Full TCP Packet (Ethernet + IPv4 + TCP Headers)
format_struct = Struct(
    # Ethernet Layer
    "ethernet" / Struct(
        "dst_mac" / Bytes(6),
        "src_mac" / Bytes(6),
        "ethertype" / Int16ub,
    ),
    # IPv4 Layer (no options for simplicity, use IHL=5)
    "ipv4" / Struct(
        "version_ihl" / Int8ub,
        "dscp_ecn" / Int8ub,
        "total_length" / Int16ub,
        "identification" / Int16ub,
        "flags_fragment" / Int16ub,
        "ttl" / Int8ub,
        "protocol" / Int8ub,
        "checksum" / Int16ub,
        "src_ip" / Bytes(4),
        "dst_ip" / Bytes(4),
    ),
    # TCP Layer (no options for simplicity)
    "tcp" / Struct(
        "src_port" / Int16ub,
        "dst_port" / Int16ub,
        "seq_num" / Int32ub,
        "ack_num" / Int32ub,
        "data_offset_flags" / Int16ub,
        "window_size" / Int16ub,
        "checksum" / Int16ub,
        "urgent_pointer" / Int16ub,
    ),
    # Payload follows
)`
            },
            
            "full_udp": {
                name: "Full UDP Packet (Eth+IP+UDP)",
                description: "Complete UDP packet: Ethernet + IPv4 + UDP with payload",
                category: "Network",
                code: `# Full UDP Packet with Dynamic Payload
format_struct = Struct(
    # Ethernet Layer
    "ethernet" / Struct(
        "dst_mac" / Bytes(6),
        "src_mac" / Bytes(6),
        "ethertype" / Int16ub,
    ),
    # IPv4 Layer
    "ipv4" / Struct(
        "version_ihl" / Int8ub,
        "dscp_ecn" / Int8ub,
        "total_length" / Int16ub,
        "identification" / Int16ub,
        "flags_fragment" / Int16ub,
        "ttl" / Int8ub,
        "protocol" / Int8ub,
        "checksum" / Int16ub,
        "src_ip" / Bytes(4),
        "dst_ip" / Bytes(4),
    ),
    # UDP Layer
    "udp" / Struct(
        "src_port" / Int16ub,
        "dst_port" / Int16ub,
        "length" / Int16ub,
        "checksum" / Int16ub,
        "payload" / Bytes(this.length.value - 8),
    ),
)`
            },
            
            "full_dns": {
                name: "Full DNS Packet (Eth+IP+UDP+DNS)",
                description: "Complete DNS query/response with header",
                category: "Network",
                code: `# Full DNS Packet
format_struct = Struct(
    # Ethernet Layer
    "ethernet" / Struct(
        "dst_mac" / Bytes(6),
        "src_mac" / Bytes(6),
        "ethertype" / Int16ub,
    ),
    # IPv4 Layer
    "ipv4" / Struct(
        "version_ihl" / Int8ub,
        "dscp_ecn" / Int8ub,
        "total_length" / Int16ub,
        "identification" / Int16ub,
        "flags_fragment" / Int16ub,
        "ttl" / Int8ub,
        "protocol" / Int8ub,
        "checksum" / Int16ub,
        "src_ip" / Bytes(4),
        "dst_ip" / Bytes(4),
    ),
    # UDP Layer
    "udp" / Struct(
        "src_port" / Int16ub,
        "dst_port" / Int16ub,
        "length" / Int16ub,
        "checksum" / Int16ub,
    ),
    # DNS Layer
    "dns" / Struct(
        "transaction_id" / Int16ub,
        "flags" / Int16ub,
        "questions" / Int16ub,
        "answer_rrs" / Int16ub,
        "authority_rrs" / Int16ub,
        "additional_rrs" / Int16ub,
        # Questions/Answers follow (variable length DNS names)
    ),
)`
            },
            
            "full_dhcp": {
                name: "Full DHCP Packet (Eth+IP+UDP+DHCP)",
                description: "Complete DHCP message with dynamic hardware address",
                category: "Network",
                code: `# Full DHCP Packet
format_struct = Struct(
    # Ethernet Layer
    "ethernet" / Struct(
        "dst_mac" / Bytes(6),
        "src_mac" / Bytes(6),
        "ethertype" / Int16ub,
    ),
    # IPv4 Layer
    "ipv4" / Struct(
        "version_ihl" / Int8ub,
        "dscp_ecn" / Int8ub,
        "total_length" / Int16ub,
        "identification" / Int16ub,
        "flags_fragment" / Int16ub,
        "ttl" / Int8ub,
        "protocol" / Int8ub,
        "checksum" / Int16ub,
        "src_ip" / Bytes(4),
        "dst_ip" / Bytes(4),
    ),
    # UDP Layer
    "udp" / Struct(
        "src_port" / Int16ub,
        "dst_port" / Int16ub,
        "length" / Int16ub,
        "checksum" / Int16ub,
    ),
    # DHCP Layer
    "dhcp" / Struct(
        "op" / Int8ub,
        "htype" / Int8ub,
        "hlen" / Int8ub,
        "hops" / Int8ub,
        "xid" / Int32ub,
        "secs" / Int16ub,
        "flags" / Int16ub,
        "ciaddr" / Bytes(4),
        "yiaddr" / Bytes(4),
        "siaddr" / Bytes(4),
        "giaddr" / Bytes(4),
        "chaddr" / Bytes(this.hlen.value),
        "chaddr_padding" / Bytes(16 - this.hlen.value),
        "sname" / Bytes(64),
        "file" / Bytes(128),
        "magic_cookie" / Bytes(4),
        # DHCP options follow (TLV: type-length-value)
    ),
)`
            },
            
            "full_arp": {
                name: "Full ARP Packet (Eth+ARP)",
                description: "Complete ARP request/reply with dynamic addresses",
                category: "Network",
                code: `# Full ARP Packet
format_struct = Struct(
    # Ethernet Layer
    "ethernet" / Struct(
        "dst_mac" / Bytes(6),
        "src_mac" / Bytes(6),
        "ethertype" / Int16ub,
    ),
    # ARP Layer
    "arp" / Struct(
        "htype" / Int16ub,
        "ptype" / Int16ub,
        "hlen" / Int8ub,
        "plen" / Int8ub,
        "operation" / Int16ub,
        "sender_mac" / Bytes(this.hlen.value),
        "sender_ip" / Bytes(this.plen.value),
        "target_mac" / Bytes(this.hlen.value),
        "target_ip" / Bytes(this.plen.value),
    ),
)`
            },
            
            // ===== FILES - Executables & Archives =====
            
            "elf": {
                name: "ELF Header (64-bit)",
                description: "ELF executable/library header with program headers",
                category: "Files",
                code: `# ELF 64-bit Header
format_struct = Struct(
    "magic" / Bytes(4),
    "class" / Int8ub,
    "endian" / Int8ub,
    "version" / Int8ub,
    "osabi" / Int8ub,
    "abiversion" / Int8ub,
    "padding" / Bytes(7),
    "type" / Int16ul,
    "machine" / Int16ul,
    "version2" / Int32ul,
    "entry" / Int64ul,
    "phoff" / Int64ul,
    "shoff" / Int64ul,
    "flags" / Int32ul,
    "ehsize" / Int16ul,
    "phentsize" / Int16ul,
    "phnum" / Int16ul,
    "shentsize" / Int16ul,
    "shnum" / Int16ul,
    "shstrndx" / Int16ul,
)`
            },
            
            "pe": {
                name: "PE Header (Windows)",
                description: "PE/COFF executable header (DOS + PE)",
                category: "Files",
                code: `# PE Header (DOS Stub + PE Signature)
format_struct = Struct(
    # DOS Header
    "dos_magic" / Bytes(2),
    "dos_lastsize" / Int16ul,
    "dos_nblocks" / Int16ul,
    "dos_nreloc" / Int16ul,
    "dos_hdrsize" / Int16ul,
    "dos_minalloc" / Int16ul,
    "dos_maxalloc" / Int16ul,
    "dos_ss" / Int16ul,
    "dos_sp" / Int16ul,
    "dos_checksum" / Int16ul,
    "dos_ip" / Int16ul,
    "dos_cs" / Int16ul,
    "dos_lfarlc" / Int16ul,
    "dos_ovno" / Int16ul,
    "dos_res" / Bytes(8),
    "dos_oemid" / Int16ul,
    "dos_oeminfo" / Int16ul,
    "dos_res2" / Bytes(20),
    "pe_offset" / Int32ul,
)`
            },
            
            "zip": {
                name: "ZIP Local File Header",
                description: "ZIP archive local file header with dynamic filename and extra fields",
                category: "Files",
                code: `# ZIP Local File Header (Dynamic)
format_struct = Struct(
    "signature" / Bytes(4),
    "version" / Int16ul,
    "flags" / Int16ul,
    "compression" / Int16ul,
    "mod_time" / Int16ul,
    "mod_date" / Int16ul,
    "crc32" / Int32ul,
    "compressed_size" / Int32ul,
    "uncompressed_size" / Int32ul,
    "filename_length" / Int16ul,
    "extra_length" / Int16ul,
    "filename" / Bytes(this.filename_length.value),
    "extra_field" / Bytes(this.extra_length.value),
    # Compressed data follows
)`
            },
            
            "gzip": {
                name: "GZIP Header",
                description: "GZIP compression header with dynamic filename/comment",
                category: "Files",
                code: `# GZIP Header (Dynamic)
format_struct = Struct(
    "magic" / Bytes(2),
    "method" / Int8ub,
    "flags" / Int8ub,
    "mtime" / Int32ul,
    "extra_flags" / Int8ub,
    "os" / Int8ub,
    # If flags & 0x04: extra field follows (2-byte length + data)
    # If flags & 0x08: null-terminated filename follows
    # If flags & 0x10: null-terminated comment follows
)`
            },
            
            "tar": {
                name: "TAR Header (POSIX)",
                description: "POSIX TAR archive header with filename and metadata",
                category: "Files",
                code: `# TAR Header (POSIX/ustar)
format_struct = Struct(
    "name" / Bytes(100),
    "mode" / Bytes(8),
    "uid" / Bytes(8),
    "gid" / Bytes(8),
    "size" / Bytes(12),
    "mtime" / Bytes(12),
    "checksum" / Bytes(8),
    "typeflag" / Bytes(1),
    "linkname" / Bytes(100),
    "magic" / Bytes(6),
    "version" / Bytes(2),
    "uname" / Bytes(32),
    "gname" / Bytes(32),
    "devmajor" / Bytes(8),
    "devminor" / Bytes(8),
    "prefix" / Bytes(155),
    "padding" / Bytes(12),
    # File data follows (size field indicates length)
)`
            },
            
            "png": {
                name: "PNG Chunk",
                description: "PNG image chunk with dynamic data field",
                category: "Files",
                code: `# PNG Chunk (Dynamic)
format_struct = Struct(
    "length" / Int32ub,
    "type" / Bytes(4),
    "data" / Bytes(this.length.value),
    "crc" / Int32ub,
)`
            },
            
            "jpeg": {
                name: "JPEG Segment",
                description: "JPEG image segment with dynamic data",
                category: "Files",
                code: `# JPEG Segment (Dynamic)
format_struct = Struct(
    "marker" / Bytes(2),
    "length" / Int16ub,
    "data" / Bytes(this.length.value - 2),
)`
            },
            
            // ===== FIRMWARE - Filesystems & Images =====
            
            "squashfs": {
                name: "SquashFS Superblock",
                description: "SquashFS compressed filesystem superblock",
                category: "Firmware",
                code: `# SquashFS Superblock
format_struct = Struct(
    "magic" / Bytes(4),
    "inode_count" / Int32ul,
    "mtime" / Int32ul,
    "block_size" / Int32ul,
    "fragment_count" / Int32ul,
    "compression" / Int16ul,
    "block_log" / Int16ul,
    "flags" / Int16ul,
    "id_count" / Int16ul,
    "version_major" / Int16ul,
    "version_minor" / Int16ul,
    "root_inode" / Int64ul,
    "bytes_used" / Int64ul,
    "id_table_start" / Int64ul,
    "xattr_table_start" / Int64ul,
    "inode_table_start" / Int64ul,
    "directory_table_start" / Int64ul,
    "fragment_table_start" / Int64ul,
    "lookup_table_start" / Int64ul,
)`
            },
            
            "ext4": {
                name: "EXT2/3/4 Superblock",
                description: "EXT filesystem superblock (compatible with ext2/ext3/ext4)",
                category: "Firmware",
                code: `# EXT2/3/4 Superblock
format_struct = Struct(
    "inodes_count" / Int32ul,
    "blocks_count" / Int32ul,
    "r_blocks_count" / Int32ul,
    "free_blocks_count" / Int32ul,
    "free_inodes_count" / Int32ul,
    "first_data_block" / Int32ul,
    "log_block_size" / Int32ul,
    "log_frag_size" / Int32ul,
    "blocks_per_group" / Int32ul,
    "frags_per_group" / Int32ul,
    "inodes_per_group" / Int32ul,
    "mtime" / Int32ul,
    "wtime" / Int32ul,
    "mnt_count" / Int16ul,
    "max_mnt_count" / Int16ul,
    "magic" / Int16ul,
    "state" / Int16ul,
    "errors" / Int16ul,
    "minor_rev_level" / Int16ul,
    "lastcheck" / Int32ul,
    "checkinterval" / Int32ul,
    "creator_os" / Int32ul,
    "rev_level" / Int32ul,
    "def_resuid" / Int16ul,
    "def_resgid" / Int16ul,
)`
            },
            
            "cpio": {
                name: "CPIO Archive (newc)",
                description: "CPIO archive header (newc format, common in initramfs)",
                category: "Firmware",
                code: `# CPIO Archive Header (newc format)
format_struct = Struct(
    "magic" / Bytes(6),
    "ino" / Bytes(8),
    "mode" / Bytes(8),
    "uid" / Bytes(8),
    "gid" / Bytes(8),
    "nlink" / Bytes(8),
    "mtime" / Bytes(8),
    "filesize" / Bytes(8),
    "devmajor" / Bytes(8),
    "devminor" / Bytes(8),
    "rdevmajor" / Bytes(8),
    "rdevminor" / Bytes(8),
    "namesize" / Bytes(8),
    "check" / Bytes(8),
    # Filename follows (namesize bytes)
    # File data follows (filesize bytes)
)`
            },
        };
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Utility functions
        const formatHex = (byte) => byte.toString(16).padStart(2, '0').toUpperCase();
        
        const formatAscii = (byte) => {
            return (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
        };

        // Python/Construct integration
        let pyodide = null;
        let pyodideReady = false;

        const initPyodide = async () => {
            if (pyodideReady) return pyodide;
            
            console.log('Loading Pyodide...');
            pyodide = await loadPyodide({
                indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
            });
            
            console.log('Installing construct...');
            await pyodide.loadPackage(['micropip']);
            const micropip = pyodide.pyimport('micropip');
            await micropip.install('construct');
            
            console.log('Pyodide ready!');
            pyodideReady = true;
            return pyodide;
        };

        const parseWithConstruct = async (data, structCode) => {
            if (!pyodideReady) {
                throw new Error('Pyodide not ready');
            }

            console.log('parseWithConstruct called with data length:', data.length);
            console.log('Struct code:', structCode);

            try {
                // Convert Uint8Array to Python bytes properly
                const dataArray = Array.from(data);
                console.log('Converted to array, length:', dataArray.length);
                
                const dataBytes = pyodide.toPy(dataArray);
                console.log('Created Python object');
                
                // Create Python code to parse the structure
                const pythonCode = `
import json
from construct import *

# Store the built-in construct names before user code
_builtin_constructs = set(dir())

# User's structure definition
${structCode}

# Get new names added by user code
_user_constructs = set(dir()) - _builtin_constructs

# Helper function to wrap all fields in RawCopy
def wrap_with_rawcopy(construct_obj):
    """Recursively wrap all fields with RawCopy to capture offset information."""
    if isinstance(construct_obj, Struct):
        new_subcons = {}
        for subcon in construct_obj.subcons:
            # Each subcon has a 'name' attribute
            field_name = subcon.name
            # Wrap each field with RawCopy
            if isinstance(subcon.subcon, (Struct, Array)):
                # Recursively wrap nested structures
                wrapped = RawCopy(wrap_with_rawcopy(subcon.subcon))
            else:
                wrapped = RawCopy(subcon.subcon)
            # Store with the original name
            new_subcons[field_name] = wrapped
        # Return new Struct with wrapped fields
        return Struct(**new_subcons)
    elif isinstance(construct_obj, Array):
        # Wrap the subcon of the array
        if isinstance(construct_obj.subcon, Struct):
            wrapped_subcon = wrap_with_rawcopy(construct_obj.subcon)
        else:
            wrapped_subcon = RawCopy(construct_obj.subcon)
        return Array(construct_obj.count, wrapped_subcon)
    else:
        return RawCopy(construct_obj)

# Parse the data
def parse_structure(data_list):
    try:
        # Convert list to bytes
        data_bytes = bytes(data_list)
        print(f"Data bytes length: {len(data_bytes)}")
        
        # Try to find a Struct/Construct object defined by the user
        struct_obj = None
        
        # First, try common naming conventions
        for name in ['format_struct', 'struct', 'format', 'packet', 'header']:
            if name in globals() and isinstance(globals()[name], Construct):
                struct_obj = globals()[name]
                print(f"Found structure by name: {name}")
                break
        
        # If not found, look in user-defined constructs
        if struct_obj is None:
            for name in _user_constructs:
                obj = globals().get(name)
                if isinstance(obj, Construct) and isinstance(obj, Struct):
                    struct_obj = obj
                    print(f"Found user structure: {name}")
                    break
        
        if struct_obj is None:
            return {"error": "No Construct structure found. Define a structure (e.g., format_struct = Struct(...))"}
        
        # Wrap the structure with RawCopy for offset tracking
        wrapped_struct = wrap_with_rawcopy(struct_obj)
        
        # Parse the data
        print("Parsing data with RawCopy wrapper...")
        parsed = wrapped_struct.parse(data_bytes)
        print(f"Parse complete, result type: {type(parsed)}")
        print(f"Parsed container keys: {list(parsed.keys()) if hasattr(parsed, 'keys') else 'N/A'}")
        print(f"Parsed container items: {[(k, type(v)) for k, v in parsed.items()] if hasattr(parsed, 'items') else 'N/A'}")
        
        # Convert to JSON-serializable format using RawCopy offset information
        def to_dict(obj, parent_name="", depth=0):
            result = []
            
            if isinstance(obj, Container):
                for key, value in obj.items():
                    if key.startswith('_'):
                        continue
                    
                    print(f"{'  ' * depth}Processing field: {key} = {type(value)}")
                    
                    # Check if this is a RawCopy result (has 'data', 'value', 'offset1', 'offset2')
                    if isinstance(value, Container) and hasattr(value, 'offset1') and hasattr(value, 'offset2'):
                        offset = value.offset1
                        length = value.offset2 - value.offset1
                        actual_value = value.value
                        
                        print(f"{'  ' * depth}  RawCopy field: offset={offset}, length={length}, value_type={type(actual_value)}")
                        
                        # Handle different value types
                        if isinstance(actual_value, ListContainer):
                            # Array of items
                            children = []
                            for idx, item in enumerate(actual_value):
                                # Check if item is a Container with nested RawCopy fields
                                if isinstance(item, Container):
                                    # This is a Struct in the array - need to process its fields
                                    nested_fields = to_dict(item, f"[{idx}]", depth + 2)
                                    
                                    if nested_fields:
                                        # Calculate total size from nested fields
                                        if len(nested_fields) > 0:
                                            first_offset = nested_fields[0]['offset']
                                            last_field = nested_fields[-1]
                                            last_offset = last_field['offset'] + last_field['length']
                                            item_size = last_offset - first_offset
                                            
                                            children.append({
                                                'name': f'[{idx}]',
                                                'value': None,
                                                'offset': first_offset,
                                                'length': item_size,
                                                'children': nested_fields
                                            })
                                    else:
                                        print(f"{'  ' * depth}    WARNING: Array item [{idx}] produced no nested fields")
                                elif hasattr(item, 'offset1') and hasattr(item, 'offset2'):
                                    # Direct RawCopy wrapped value (shouldn't happen for Struct in Array)
                                    child_offset = item.offset1
                                    child_length = item.offset2 - item.offset1
                                    child_value = item.value
                                    
                                    display_value = format_value(child_value, child_length)
                                    children.append({
                                        'name': f'[{idx}]',
                                        'value': display_value,
                                        'offset': child_offset,
                                        'length': child_length,
                                        'rawValue': child_value if isinstance(child_value, (int, str, bool, type(None))) else None
                                    })
                                else:
                                    # Fallback - shouldn't reach here
                                    print(f"{'  ' * depth}    WARNING: Array item [{idx}] is not properly wrapped: {type(item)}")
                                    children.append({
                                        'name': f'[{idx}]',
                                        'value': str(item),
                                        'offset': offset + idx,
                                        'length': 1,
                                        'rawValue': None
                                    })
                            
                            result.append({
                                'name': key,
                                'value': f'Array[{len(actual_value)}]',
                                'offset': offset,
                                'length': length,
                                'children': children
                            })
                        elif isinstance(actual_value, Container):
                            # Nested structure
                            nested_children = to_dict(actual_value, key, depth + 1)
                            result.append({
                                'name': key,
                                'value': None,
                                'offset': offset,
                                'length': length,
                                'children': nested_children
                            })
                        else:
                            # Simple field
                            display_value = format_value(actual_value, length)
                            result.append({
                                'name': key,
                                'value': display_value,
                                'offset': offset,
                                'length': length,
                                'rawValue': actual_value if isinstance(actual_value, (int, str, bool, type(None))) else None
                            })
                    else:
                        # Not a RawCopy result - this shouldn't happen with our wrapper
                        print(f"{'  ' * depth}  WARNING: Field {key} is not RawCopy wrapped")
                        if isinstance(value, Container):
                            nested = to_dict(value, key, depth + 1)
                            if nested:
                                result.append({
                                    'name': key,
                                    'value': None,
                                    'offset': 0,
                                    'length': 0,
                                    'children': nested
                                })
                        else:
                            result.append({
                                'name': key,
                                'value': str(value),
                                'offset': 0,
                                'length': 0,
                                'rawValue': value if isinstance(value, (int, str, bool, type(None))) else None
                            })
            
            print(f"{'  ' * depth}Returning {len(result)} fields")
            return result
        
        def format_value(value, length):
            """Format a value for display."""
            if isinstance(value, bytes):
                return value.hex().upper() if len(value) <= 16 else f"{value[:8].hex().upper()}... ({len(value)} bytes)"
            elif isinstance(value, int):
                if length == 1:
                    return f"0x{value:02X} ({value})"
                elif length == 2:
                    return f"0x{value:04X} ({value})"
                elif length == 4:
                    return f"0x{value:08X} ({value})"
                else:
                    return f"0x{value:X} ({value})"
            elif isinstance(value, str):
                return f'"{value}"'
            else:
                return str(value)
        
        result = to_dict(parsed)
        print(f"Final result: {len(result)} top-level fields")
        return {"fields": result}
        
    except Exception as e:
        import traceback
        print(f"Error: {e}")
        print(traceback.format_exc())
        return {"error": str(e), "traceback": traceback.format_exc()}

# Execute parsing
result = parse_structure(data_list)
json.dumps(result)
`;

                // Set the data in Python environment
                pyodide.globals.set('data_list', dataBytes);
                console.log('Set data_list in Python globals');
                
                // Run the code
                console.log('Running Python code...');
                const result = await pyodide.runPythonAsync(pythonCode);
                console.log('Python execution complete, result:', result);
                
                const parsed = JSON.parse(result);
                console.log('Parsed JSON:', parsed);
                
                if (parsed.error) {
                    throw new Error(parsed.error + '\n' + (parsed.traceback || ''));
                }
                
                return parsed.fields || [];
                
            } catch (error) {
                console.error('Parse error:', error);
                throw error;
            }
        };

        // Hex View Component with Virtual Scrolling
        const HexView = ({ data, highlightRanges = [], onByteClick, selectedField, hoveredField }) => {
            const [scrollTop, setScrollTop] = useState(0);
            const containerRef = useRef(null);
            
            const bytesPerLine = 16;
            const lineHeight = 24; // pixels per line
            const overscan = 10; // render extra lines above/below viewport
            
            const totalLines = Math.ceil(data.length / bytesPerLine);
            const totalHeight = totalLines * lineHeight;
            
            // Calculate visible range
            const containerHeight = containerRef.current?.clientHeight || 600;
            const visibleLines = Math.ceil(containerHeight / lineHeight);
            const startLine = Math.max(0, Math.floor(scrollTop / lineHeight) - overscan);
            const endLine = Math.min(totalLines, startLine + visibleLines + overscan * 2);
            
            const handleScroll = (e) => {
                setScrollTop(e.target.scrollTop);
            };

            const getHighlightClass = (byteIndex) => {
                // Check if this byte is in the hovered field
                const isHovered = hoveredField && 
                                  byteIndex >= hoveredField.offset && 
                                  byteIndex < hoveredField.offset + hoveredField.length;
                
                for (let i = 0; i < highlightRanges.length; i++) {
                    const range = highlightRanges[i];
                    if (byteIndex >= range.offset && byteIndex < range.offset + range.length) {
                        // Use topLevelIndex for color instead of range index
                        const baseClass = `field-highlight-${range.topLevelIndex % 8}`;
                        return isHovered ? `${baseClass} hovered` : baseClass;
                    }
                }
                return '';
            };
            
            // Only render visible lines
            const visibleLineElements = [];
            for (let lineIdx = startLine; lineIdx < endLine; lineIdx++) {
                const offset = lineIdx * bytesPerLine;
                const lineData = data.slice(offset, Math.min(offset + bytesPerLine, data.length));
                const y = lineIdx * lineHeight;
                
                visibleLineElements.push(
                    <div 
                        key={lineIdx} 
                        className="hex-line" 
                        style={{ 
                            position: 'absolute', 
                            top: `${y}px`,
                            left: 0,
                            right: 0,
                            height: `${lineHeight}px`
                        }}
                    >
                        <span className="hex-offset">
                            {offset.toString(16).padStart(8, '0').toUpperCase()}
                        </span>
                        <span className="mx-4">
                            {Array.from(lineData).map((byte, byteIdx) => {
                                const globalIdx = offset + byteIdx;
                                const highlightClass = getHighlightClass(globalIdx);
                                return (
                                    <span
                                        key={byteIdx}
                                        className={`hex-cell ${highlightClass}`}
                                        onClick={() => onByteClick && onByteClick(globalIdx)}
                                        title={`Offset: 0x${globalIdx.toString(16)}, Value: 0x${formatHex(byte)} (${byte})`}
                                    >
                                        {formatHex(byte)}
                                    </span>
                                );
                            })}
                            {Array(bytesPerLine - lineData.length).fill(0).map((_, i) => (
                                <span key={`pad-${i}`} className="hex-cell opacity-30">··</span>
                            ))}
                        </span>
                        <span className="ml-4 border-l border-gray-700 pl-4">
                            {Array.from(lineData).map((byte, byteIdx) => {
                                const globalIdx = offset + byteIdx;
                                const highlightClass = getHighlightClass(globalIdx);
                                return (
                                    <span 
                                        key={byteIdx} 
                                        className={`ascii-char ${highlightClass}`}
                                        title={`Offset: 0x${globalIdx.toString(16)}`}
                                    >
                                        {formatAscii(byte)}
                                    </span>
                                );
                            })}
                        </span>
                    </div>
                );
            }

            return (
                <div 
                    ref={containerRef}
                    className="font-mono text-sm"
                    style={{ 
                        height: '100%', 
                        overflow: 'auto',
                        position: 'relative'
                    }}
                    onScroll={handleScroll}
                >
                    <div style={{ height: `${totalHeight}px`, position: 'relative' }}>
                        {visibleLineElements}
                    </div>
                </div>
            );
        };

        // Edit Modal Component
        const EditModal = ({ field, onClose, onSave }) => {
            const [value, setValue] = useState('');
            const [error, setError] = useState('');
            const [inputMode, setInputMode] = useState('auto'); // 'hex' or 'int' or 'string' or 'auto'
            
            useEffect(() => {
                // Determine if this is a Bytes field (not an integer field)
                // Check if the value display format indicates bytes (shows hex string without decimal)
                const isBytesField = field.value && field.value.match(/^[0-9A-F]+$/) && field.length >= 4;
                const isIntField = field.rawValue !== null && field.rawValue !== undefined && typeof field.rawValue === 'number';
                
                // Set initial value and mode based on field type
                if (isIntField && field.length <= 4) {
                    // Integer field (Int8, Int16, Int32)
                    setValue(field.rawValue.toString());
                    setInputMode('int');
                } else if (field.value) {
                    // Extract value from display string
                    const match = field.value.match(/^([0-9A-F]+)/);
                    if (match) {
                        // Format with spaces for bytes
                        const hexStr = match[1];
                        let formatted = '';
                        for (let i = 0; i < hexStr.length; i += 2) {
                            if (i > 0) formatted += ' ';
                            formatted += hexStr.substring(i, i + 2);
                        }
                        setValue(formatted);
                        setInputMode('hex');
                    } else {
                        setValue(field.value.replace(/['"]/g, ''));
                        setInputMode('string');
                    }
                } else {
                    setInputMode('hex');
                }
                
                // For Bytes fields (4+ bytes that aren't integers), force hex mode
                if (isBytesField || (field.length >= 4 && !isIntField)) {
                    setInputMode('hex');
                }
            }, [field]);
            
            const inputRef = useRef(null);
            
            const formatHexWithSpaces = (hexStr) => {
                // Add spaces every 2 characters (after each byte)
                let formatted = '';
                for (let i = 0; i < hexStr.length; i += 2) {
                    if (i > 0) formatted += ' ';
                    formatted += hexStr.substring(i, i + 2);
                }
                return formatted;
            };
            
            const handleInputChange = (e) => {
                const input = e.target.value;
                
                // For hex mode (byte arrays), handle in-place nibble editing
                if (inputMode === 'hex') {
                    // Remove spaces to get raw hex
                    const newHex = input.replace(/\s/g, '').toUpperCase();
                    const oldHex = value.replace(/\s/g, '');
                    
                    // Ensure we don't exceed field length
                    const maxChars = field.length * 2;
                    if (newHex.length > maxChars) {
                        return; // Don't allow more than field size
                    }
                    
                    // Pad with original bytes if user deleted some
                    let finalHex = newHex;
                    if (finalHex.length < maxChars) {
                        // Pad with zeros to maintain field length
                        finalHex = finalHex.padEnd(maxChars, '0');
                    }
                    
                    setValue(formatHexWithSpaces(finalHex));
                } else if (inputMode === 'int') {
                    // Allow only digits, 'x', and 'X' for hex prefix
                    if (/^(0x)?[0-9A-Fa-fXx]*$/.test(input)) {
                        setValue(input);
                    }
                } else {
                    setValue(input);
                }
            };
            
            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    handleSave();
                    return;
                } else if (e.key === 'Escape') {
                    onClose();
                    return;
                }
                
                // For hex input mode, handle nibble-by-nibble editing
                if (inputMode === 'hex' && !e.ctrlKey && !e.metaKey) {
                    const input = e.target;
                    const cursorPos = input.selectionStart;
                    const currentValue = value.replace(/\s/g, ''); // Remove spaces
                    
                    // Check if it's a hex character
                    const isHexChar = /^[0-9A-Fa-f]$/.test(e.key);
                    
                    if (isHexChar) {
                        e.preventDefault();
                        
                        // Calculate position in hex string (without spaces)
                        let hexPos = 0;
                        let visualPos = 0;
                        for (let i = 0; i < value.length && visualPos < cursorPos; i++) {
                            if (value[i] !== ' ') {
                                hexPos++;
                            }
                            visualPos++;
                        }
                        
                        // Replace character at cursor position (overwrite mode)
                        const newHex = currentValue.substring(0, hexPos) + 
                                      e.key.toUpperCase() + 
                                      currentValue.substring(hexPos + 1);
                        
                        const formatted = formatHexWithSpaces(newHex);
                        setValue(formatted);
                        
                        // Move cursor forward
                        setTimeout(() => {
                            // Calculate new cursor position (accounting for spaces)
                            let newVisualPos = 0;
                            let hexCount = 0;
                            for (let i = 0; i < formatted.length; i++) {
                                if (formatted[i] !== ' ') {
                                    hexCount++;
                                }
                                newVisualPos = i + 1;
                                if (hexCount > hexPos) {
                                    break;
                                }
                            }
                            input.setSelectionRange(newVisualPos, newVisualPos);
                        }, 0);
                        
                        return;
                    }
                    
                    // Handle backspace
                    if (e.key === 'Backspace') {
                        e.preventDefault();
                        
                        if (cursorPos === 0) return;
                        
                        // Calculate position in hex string
                        let hexPos = 0;
                        let visualPos = 0;
                        for (let i = 0; i < value.length && visualPos < cursorPos; i++) {
                            if (value[i] !== ' ') {
                                hexPos++;
                            }
                            visualPos++;
                        }
                        
                        if (hexPos > 0) {
                            // Replace with 0 instead of deleting
                            const newHex = currentValue.substring(0, hexPos - 1) + 
                                          '0' + 
                                          currentValue.substring(hexPos);
                            
                            const formatted = formatHexWithSpaces(newHex);
                            setValue(formatted);
                            
                            // Move cursor back
                            setTimeout(() => {
                                let newVisualPos = 0;
                                let hexCount = 0;
                                for (let i = 0; i < formatted.length; i++) {
                                    if (formatted[i] !== ' ') {
                                        hexCount++;
                                    }
                                    if (hexCount >= hexPos - 1) {
                                        newVisualPos = i;
                                        break;
                                    }
                                }
                                input.setSelectionRange(newVisualPos, newVisualPos);
                            }, 0);
                        }
                        
                        return;
                    }
                    
                    // Handle delete
                    if (e.key === 'Delete') {
                        e.preventDefault();
                        
                        // Calculate position in hex string
                        let hexPos = 0;
                        let visualPos = 0;
                        for (let i = 0; i < value.length && visualPos < cursorPos; i++) {
                            if (value[i] !== ' ') {
                                hexPos++;
                            }
                            visualPos++;
                        }
                        
                        if (hexPos < currentValue.length) {
                            // Replace with 0 instead of deleting
                            const newHex = currentValue.substring(0, hexPos) + 
                                          '0' + 
                                          currentValue.substring(hexPos + 1);
                            
                            setValue(formatHexWithSpaces(newHex));
                        }
                        
                        return;
                    }
                    
                    // Allow navigation keys
                    const allowedKeys = ['ArrowLeft', 'ArrowRight', 'Tab', 'Home', 'End'];
                    if (!allowedKeys.includes(e.key)) {
                        e.preventDefault();
                    }
                }
            };
            
            const handleSave = () => {
                setError('');
                
                try {
                    let newBytes;
                    
                    // Check if we're in hex mode (for byte arrays)
                    if (inputMode === 'hex') {
                        // Hex byte array
                        const hexStr = value.replace(/\s/g, '');
                        if (hexStr.length % 2 !== 0) {
                            throw new Error('Hex string must have even number of characters');
                        }
                        const numBytes = hexStr.length / 2;
                        if (numBytes > field.length) {
                            throw new Error(`Too many bytes. Max ${field.length} bytes allowed.`);
                        }
                        // Create array with exact bytes needed
                        newBytes = new Uint8Array(field.length);
                        for (let i = 0; i < numBytes; i++) {
                            const byteVal = parseInt(hexStr.substr(i * 2, 2), 16);
                            if (isNaN(byteVal)) {
                                throw new Error('Invalid hex value');
                            }
                            newBytes[i] = byteVal;
                        }
                        // Note: Remaining bytes stay as 0 if not specified
                    } else if (inputMode === 'int') {
                        // Integer field
                        if (field.length === 1) {
                            let val = value.startsWith('0x') ? parseInt(value, 16) : parseInt(value, 10);
                            if (isNaN(val) || val < 0 || val > 255) {
                                throw new Error('Value must be between 0 and 255');
                            }
                            newBytes = new Uint8Array([val]);
                        } else if (field.length === 2) {
                            let val = value.startsWith('0x') ? parseInt(value, 16) : parseInt(value, 10);
                            if (isNaN(val) || val < 0 || val > 65535) {
                                throw new Error('Value must be between 0 and 65535');
                            }
                            newBytes = new Uint8Array([val & 0xFF, (val >> 8) & 0xFF]);
                        } else if (field.length === 4) {
                            let val = value.startsWith('0x') ? parseInt(value, 16) : parseInt(value, 10);
                            if (isNaN(val) || val < 0 || val > 4294967295) {
                                throw new Error('Value must be between 0 and 4294967295');
                            }
                            newBytes = new Uint8Array([
                                val & 0xFF,
                                (val >> 8) & 0xFF,
                                (val >> 16) & 0xFF,
                                (val >> 24) & 0xFF
                            ]);
                        }
                    } else {
                        // String mode
                        const encoder = new TextEncoder();
                        const encoded = encoder.encode(value);
                        if (encoded.length > field.length) {
                            throw new Error(`String too long. Max ${field.length} bytes.`);
                        }
                        // Pad with zeros if string is shorter
                        newBytes = new Uint8Array(field.length);
                        newBytes.set(encoded);
                    }
                    
                    onSave(field.offset, newBytes);
                    onClose();
                } catch (err) {
                    setError(err.message);
                }
            };
            
            const getInputHelp = () => {
                if (inputMode === 'hex') {
                    return `Enter ${field.length} hex bytes (auto-spaced)`;
                } else if (inputMode === 'int') {
                    if (field.length === 1) {
                        return 'Enter decimal (0-255) or hex (0xFF)';
                    } else if (field.length === 2) {
                        return 'Enter decimal (0-65535) or hex (0xFFFF)';
                    } else if (field.length === 4) {
                        return 'Enter decimal or hex (0xFFFFFFFF)';
                    }
                } else {
                    return 'Enter ASCII string';
                }
            };
            
            const getPlaceholder = () => {
                if (inputMode === 'hex') {
                    // Show hex byte pattern
                    return Array(Math.min(field.length, 4)).fill('00').join(' ') + 
                           (field.length > 4 ? ' ...' : '');
                } else if (inputMode === 'int') {
                    if (field.length === 1) {
                        return '0xFF or 255';
                    } else if (field.length === 2) {
                        return '0x1234 or 4660';
                    } else if (field.length === 4) {
                        return '0xDEADBEEF or 3735928559';
                    }
                } else {
                    return 'Enter text...';
                }
            };
            
            const toggleInputMode = () => {
                if (inputMode === 'hex') {
                    setInputMode('string');
                    setValue('');
                } else {
                    setInputMode('hex');
                    setValue('');
                }
            };
            
            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content" onClick={(e) => e.stopPropagation()}>
                        <h2 className="text-lg font-semibold mb-4" style={{ color: '#58a6ff' }}>
                            Edit Field: {field.name}
                        </h2>
                        
                        <div className="mb-4">
                            <div className="text-sm mb-2" style={{ color: '#8b949e' }}>
                                <div>Offset: 0x{field.offset.toString(16).padStart(4, '0')}</div>
                                <div>Size: {field.length} bytes</div>
                                <div className="mt-1 flex items-center justify-between">
                                    <span style={{ color: '#6e7681', fontSize: '12px' }}>
                                        {getInputHelp()}
                                    </span>
                                    {inputMode !== 'int' && (
                                        <button
                                            onClick={toggleInputMode}
                                            className="px-2 py-1 text-xs rounded"
                                            style={{
                                                background: '#21262d',
                                                border: '1px solid #30363d',
                                                color: '#58a6ff'
                                            }}
                                        >
                                            {inputMode === 'hex' ? 'Switch to ASCII' : 'Switch to Hex'}
                                        </button>
                                    )}
                                </div>
                            </div>
                            
                            <input
                                ref={inputRef}
                                type="text"
                                className="modal-input"
                                value={value}
                                onChange={handleInputChange}
                                onKeyDown={handleKeyDown}
                                placeholder={getPlaceholder()}
                                autoFocus
                                style={{
                                    fontFamily: inputMode === 'hex' ? 'JetBrains Mono, monospace' : 'inherit',
                                    letterSpacing: inputMode === 'hex' ? '0.05em' : 'normal'
                                }}
                            />
                            
                            {inputMode === 'hex' && (
                                <div className="mt-2 text-xs" style={{ color: '#6e7681' }}>
                                    💡 Tip: Type hex digits to overwrite nibbles in-place. Use arrow keys to navigate.
                                </div>
                            )}
                            
                            {error && (
                                <div className="mt-2 text-sm" style={{ color: '#ff7b72' }}>
                                    {error}
                                </div>
                            )}
                        </div>
                        
                        <div className="flex justify-end space-x-2">
                            <button
                                onClick={onClose}
                                className="px-4 py-2 btn-terminal rounded"
                            >
                                Cancel
                            </button>
                            <button
                                onClick={handleSave}
                                className="px-4 py-2 rounded"
                                style={{
                                    background: '#238636',
                                    border: '1px solid #2ea043',
                                    color: '#fff'
                                }}
                            >
                                Save
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Structure Tree Component
        const TreeNode = ({ node, depth = 0, onSelect, selectedPath, currentPath = [], onEdit, onHover }) => {
            const [expanded, setExpanded] = useState(true);
            const hasChildren = node.children && node.children.length > 0;
            const isSelected = JSON.stringify(currentPath) === JSON.stringify(selectedPath);
            const canEdit = !hasChildren && node.length > 0;
            
            // Format the size display
            const sizeDisplay = node.length === 1 ? '1 byte' : `${node.length} bytes`;
            
            return (
                <div>
                    <div
                        className={`tree-node ${hasChildren ? 'expandable' : ''} ${expanded ? 'expanded' : ''} ${isSelected ? 'selected' : ''}`}
                        onMouseEnter={() => onHover && onHover(node)}
                        onMouseLeave={() => onHover && onHover(null)}
                    >
                        <div
                            onClick={(e) => {
                                e.stopPropagation();
                                if (hasChildren) {
                                    setExpanded(!expanded);
                                }
                                onSelect(node, currentPath);
                            }}
                            style={{ flex: 1, display: 'flex', flexDirection: 'column' }}
                        >
                            <div className="flex items-center justify-between">
                                <span className="font-semibold text-blue-400">{node.name}</span>
                                <span className="text-xs text-gray-500">
                                    @0x{node.offset.toString(16).padStart(4, '0')} ({sizeDisplay})
                                </span>
                            </div>
                            {node.value !== null && node.value !== undefined && (
                                <div className="text-sm text-gray-300 mt-1 ml-4">
                                    {node.value}
                                </div>
                            )}
                        </div>
                        
                        {canEdit && (
                            <div style={{ display: 'flex', gap: '4px', position: 'relative' }}>
                                <button
                                    className="edit-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        onEdit(node);
                                    }}
                                    title="Edit field value"
                                >
                                    ✏️ Edit
                                </button>
                                <button
                                    className="edit-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        // Toggle export menu
                                        const menu = e.currentTarget.nextElementSibling;
                                        if (menu) {
                                            // Close all other menus first
                                            document.querySelectorAll('.export-menu').forEach(m => {
                                                if (m !== menu) m.style.display = 'none';
                                            });
                                            menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
                                        }
                                    }}
                                    title="Export field data"
                                >
                                    💾
                                </button>
                                <div 
                                    className="export-menu"
                                    style={{ display: 'none' }}
                                    onClick={(e) => e.stopPropagation()}
                                >
                                    <button onClick={(e) => {
                                        e.stopPropagation();
                                        e.currentTarget.parentElement.style.display = 'none';
                                        if (window.onExportField) {
                                            window.onExportField(node, 'python');
                                        }
                                    }}>📋 Copy Python bytes</button>
                                    <button onClick={(e) => {
                                        e.stopPropagation();
                                        e.currentTarget.parentElement.style.display = 'none';
                                        if (window.onExportField) {
                                            window.onExportField(node, 'file');
                                        }
                                    }}>💾 Save as file</button>
                                </div>
                            </div>
                        )}
                    </div>
                    {hasChildren && expanded && (
                        <div className="tree-children">
                            {node.children.map((child, idx) => (
                                <TreeNode
                                    key={idx}
                                    node={child}
                                    depth={depth + 1}
                                    onSelect={onSelect}
                                    selectedPath={selectedPath}
                                    currentPath={[...currentPath, idx]}
                                    onEdit={onEdit}
                                    onHover={onHover}
                                />
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const StructureTree = ({ fields, onFieldSelect, selectedField, onFieldEdit, onFieldHover }) => {
            const [selectedPath, setSelectedPath] = useState(null);
            
            const handleSelect = (node, path) => {
                setSelectedPath(path);
                onFieldSelect(node);
            };
            
            return (
                <div className="space-y-1">
                    {fields.length === 0 ? (
                        <div className="text-gray-500 p-4 text-center">
                            No structure parsed yet. Define a Construct structure and click Parse.
                        </div>
                    ) : (
                        fields.map((field, idx) => (
                            <TreeNode
                                key={idx}
                                node={field}
                                onSelect={handleSelect}
                                selectedPath={selectedPath}
                                currentPath={[idx]}
                                onEdit={onFieldEdit}
                                onHover={onFieldHover}
                            />
                        ))
                    )}
                </div>
            );
        };

        // Main App Component
        const BinTVApp = () => {
            const [fileData, setFileData] = useState(null);
            const [originalFileData, setOriginalFileData] = useState(null);
            const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
            const [fileName, setFileName] = useState('');
            const [structDef, setStructDef] = useState(`# Define your Construct structure here
# Example:
format_struct = Struct(
    "magic" / Bytes(4),
    "version" / Int16ul,
    "size" / Int32ul,
    "data" / Bytes(8),
    "checksum" / Int32ul,
)`);
            const [parsedFields, setParsedFields] = useState([]);
            const [selectedField, setSelectedField] = useState(null);
            const [hoveredField, setHoveredField] = useState(null);
            const [highlightRanges, setHighlightRanges] = useState([]);
            const [isLoading, setIsLoading] = useState(true);
            const [isParsing, setIsParsing] = useState(false);
            const [error, setError] = useState(null);
            const [parseStatus, setParseStatus] = useState('');
            const [editingField, setEditingField] = useState(null);
            
            // PCAP-specific state
            const [isPcapFile, setIsPcapFile] = useState(false);
            const [pcapPackets, setPcapPackets] = useState([]);
            const [currentPacketIndex, setCurrentPacketIndex] = useState(0);
            const [originalPcapData, setOriginalPcapData] = useState(null);
            
            const fileInputRef = useRef(null);
            const parseTimeoutRef = useRef(null);

            useEffect(() => {
                initPyodide().then(() => {
                    setIsLoading(false);
                    setParseStatus('>>> Python environment ready');
                    
                    // Template library diagnostics
                    console.log('📚 CONSTRUCT_LIBRARY loaded with', Object.keys(CONSTRUCT_LIBRARY).length, 'templates');
                    console.log('Available templates:', Object.keys(CONSTRUCT_LIBRARY).sort().join(', '));
                    
                    // Check URL parameters for template
                    const urlParams = new URLSearchParams(window.location.search);
                    const template = urlParams.get('template');
                    if (template && CONSTRUCT_LIBRARY[template]) {
                        setStructDef(CONSTRUCT_LIBRARY[template].code);
                        setParseStatus(`>>> Loaded template: ${CONSTRUCT_LIBRARY[template].name}`);
                    } else if (template) {
                        console.error('Template from URL not found:', template);
                        setParseStatus(`>>> Error: Template "${template}" not found`);
                    }
                }).catch(err => {
                    setError('Failed to initialize Pyodide: ' + err.message);
                    setIsLoading(false);
                });
            }, []);

            // Reactive parsing with debounce
            useEffect(() => {
                if (!fileData || !pyodideReady) return;
                
                // Check if structDef has actual content (not just comments)
                const hasRealContent = structDef.split('\n').some(line => {
                    const trimmed = line.trim();
                    return trimmed && !trimmed.startsWith('#');
                });
                
                if (!hasRealContent) return;
                
                // For PCAP files, parse immediately when packet changes (no debounce)
                if (isPcapFile) {
                    handleParse();
                    return;
                }
                
                // For regular files, use debounced parsing
                // Clear previous timeout
                if (parseTimeoutRef.current) {
                    clearTimeout(parseTimeoutRef.current);
                }
                
                // Set new timeout for debounced parsing
                parseTimeoutRef.current = setTimeout(() => {
                    handleParse();
                }, 500); // Parse 500ms after user stops typing
                
                return () => {
                    if (parseTimeoutRef.current) {
                        clearTimeout(parseTimeoutRef.current);
                    }
                };
            }, [structDef, fileData, pyodideReady, isPcapFile]);

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                setFileName(file.name);
                setParseStatus(`>>> Loading file: ${file.name}`);
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    const arrayBuffer = e.target.result;
                    const uint8Array = new Uint8Array(arrayBuffer);
                    
                    // Check if it's a PCAP file by magic number (more reliable than extension)
                    let isPcap = false;
                    if (uint8Array.length >= 4) {
                        const view = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
                        const magic = view.getUint32(0, true);  // Try little-endian
                        const magicBE = view.getUint32(0, false); // Try big-endian
                        
                        // PCAP: 0xa1b2c3d4 (LE) or 0xd4c3b2a1 (BE)
                        // PCAPNG: 0x0A0D0D0A
                        isPcap = (magic === 0xa1b2c3d4 || magicBE === 0xd4c3b2a1 || magic === 0x0A0D0D0A);
                        
                        if (!isPcap) {
                            // Also check file extension as fallback
                            const fileName = file.name.toLowerCase();
                            isPcap = fileName.endsWith('.pcap') || fileName.endsWith('.pcapng');
                        }
                    }
                    
                    if (isPcap) {
                        try {
                            const packets = parsePcap(uint8Array);
                            setIsPcapFile(true);
                            setPcapPackets(packets);
                            setOriginalPcapData(uint8Array);
                            setCurrentPacketIndex(0);
                            
                            // Load first packet
                            if (packets.length > 0) {
                                setFileData(packets[0].data);
                                setOriginalFileData(new Uint8Array(packets[0].data));
                                setParseStatus(`>>> PCAP loaded: ${packets.length} packets, showing packet 0 (${packets[0].data.length} bytes)`);
                            } else {
                                setParseStatus(`>>> PCAP loaded but contains no packets`);
                            }
                        } catch (err) {
                            console.error('PCAP parsing error:', err);
                            setParseStatus(`>>> PCAP parse error: ${err.message}`);
                            // Fall back to loading as regular binary
                            setIsPcapFile(false);
                            setFileData(uint8Array);
                            setOriginalFileData(new Uint8Array(uint8Array));
                        }
                    } else {
                        // Regular binary file
                        setIsPcapFile(false);
                        setPcapPackets([]);
                        setFileData(uint8Array);
                        setOriginalFileData(new Uint8Array(uint8Array));
                        setHasUnsavedChanges(false);
                        setParseStatus(`>>> File loaded: ${uint8Array.length} bytes`);
                    }
                };
                
                reader.readAsArrayBuffer(file);
            };
            
            // PCAP parsing function (supports both PCAP and PCAPNG)
            const parsePcap = (data) => {
                const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
                const packets = [];
                
                // Check magic number to determine format
                const magic = view.getUint32(0, true);
                const magicBE = view.getUint32(0, false);
                
                // PCAPNG format: 0x0A0D0D0A (Section Header Block)
                if (magic === 0x0A0D0D0A) {
                    console.log('PCAPNG format detected');
                    return parsePcapNG(data, view);
                }
                
                // PCAP format: 0xa1b2c3d4 (LE) or 0xd4c3b2a1 (BE)
                const isLittleEndian = magic === 0xa1b2c3d4;
                const isBigEndian = magicBE === 0xd4c3b2a1;
                
                if (!isLittleEndian && !isBigEndian) {
                    throw new Error('Not a valid PCAP/PCAPNG file (invalid magic number)');
                }
                
                console.log(`PCAP file detected, endianness: ${isLittleEndian ? 'little' : 'big'}`);
                
                // PCAP Global Header is 24 bytes
                let offset = 24;
                let packetNum = 0;
                
                while (offset + 16 <= data.length) {
                    // Packet Header (16 bytes):
                    const ts_sec = view.getUint32(offset, isLittleEndian);
                    const ts_usec = view.getUint32(offset + 4, isLittleEndian);
                    const incl_len = view.getUint32(offset + 8, isLittleEndian);
                    const orig_len = view.getUint32(offset + 12, isLittleEndian);
                    
                    offset += 16;
                    
                    if (offset + incl_len > data.length) {
                        console.warn(`Packet ${packetNum} truncated`);
                        break;
                    }
                    
                    const packetData = new Uint8Array(data.buffer, data.byteOffset + offset, incl_len);
                    
                    packets.push({
                        index: packetNum,
                        timestamp: ts_sec + ts_usec / 1000000,
                        capturedLength: incl_len,
                        originalLength: orig_len,
                        data: packetData,
                        offset: offset
                    });
                    
                    offset += incl_len;
                    packetNum++;
                }
                
                console.log(`Parsed ${packets.length} packets from PCAP`);
                return packets;
            };
            
            // PCAPNG parsing function (simplified - only extracts Enhanced Packet Blocks)
            const parsePcapNG = (data, view) => {
                const packets = [];
                let offset = 0;
                let packetNum = 0;
                
                while (offset + 12 <= data.length) {
                    // Block type (4 bytes) + Block total length (4 bytes)
                    const blockType = view.getUint32(offset, true);
                    const blockLen = view.getUint32(offset + 4, true);
                    
                    if (blockLen < 12 || offset + blockLen > data.length) {
                        console.warn(`Invalid block at offset ${offset}`);
                        break;
                    }
                    
                    // Enhanced Packet Block (type 0x00000006) or Simple Packet Block (type 0x00000003)
                    if (blockType === 0x00000006) {
                        // Enhanced Packet Block
                        // Skip: interface ID (4), timestamp high (4), timestamp low (4)
                        const capturedLen = view.getUint32(offset + 20, true);
                        const originalLen = view.getUint32(offset + 24, true);
                        
                        const dataOffset = offset + 28; // After EPB header
                        
                        if (dataOffset + capturedLen <= offset + blockLen) {
                            const packetData = new Uint8Array(data.buffer, data.byteOffset + dataOffset, capturedLen);
                            
                            const tsHigh = view.getUint32(offset + 12, true);
                            const tsLow = view.getUint32(offset + 16, true);
                            const timestamp = (tsHigh * 0x100000000 + tsLow) / 1000000; // Microseconds to seconds
                            
                            packets.push({
                                index: packetNum,
                                timestamp: timestamp,
                                capturedLength: capturedLen,
                                originalLength: originalLen,
                                data: packetData,
                                offset: dataOffset
                            });
                            
                            packetNum++;
                        }
                    } else if (blockType === 0x00000003) {
                        // Simple Packet Block (older format)
                        const originalLen = view.getUint32(offset + 8, true);
                        const capturedLen = Math.min(originalLen, blockLen - 16);
                        
                        const dataOffset = offset + 12;
                        
                        if (dataOffset + capturedLen <= offset + blockLen) {
                            const packetData = new Uint8Array(data.buffer, data.byteOffset + dataOffset, capturedLen);
                            
                            packets.push({
                                index: packetNum,
                                timestamp: 0,
                                capturedLength: capturedLen,
                                originalLength: originalLen,
                                data: packetData,
                                offset: dataOffset
                            });
                            
                            packetNum++;
                        }
                    }
                    
                    offset += blockLen;
                }
                
                console.log(`Parsed ${packets.length} packets from PCAPNG`);
                return packets;
            };
            
            const handlePacketChange = (newIndex) => {
                if (!isPcapFile || newIndex < 0 || newIndex >= pcapPackets.length) return;
                
                const packet = pcapPackets[newIndex];
                console.log(`📦 Switching to packet ${newIndex}, size: ${packet.data.length} bytes`);
                console.log(`📦 First 16 bytes: ${Array.from(packet.data.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
                
                setCurrentPacketIndex(newIndex);
                setFileData(packet.data);
                setOriginalFileData(new Uint8Array(packet.data));
                setHasUnsavedChanges(false);
                setParseStatus(`>>> Showing packet ${newIndex} of ${pcapPackets.length - 1} (${packet.data.length} bytes)`);
                
                // Parse will be triggered automatically by useEffect when fileData changes
            };

            const flattenFields = (fields, list = []) => {
                fields.forEach((field, topLevelIndex) => {
                    // For top-level fields, add them with their index
                    list.push({
                        offset: field.offset,
                        length: field.length,
                        topLevelIndex: topLevelIndex,  // Track which top-level struct this belongs to
                        name: field.name,
                        value: field.value
                    });
                    // For nested children, inherit the parent's top-level index
                    if (field.children) {
                        flattenFieldsNested(field.children, list, topLevelIndex, field.name);
                    }
                });
                return list;
            };
            
            const flattenFieldsNested = (fields, list, topLevelIndex, parentName) => {
                fields.forEach(field => {
                    list.push({
                        offset: field.offset,
                        length: field.length,
                        topLevelIndex: topLevelIndex,  // Inherit parent's top-level index
                        name: parentName + '.' + field.name,
                        value: field.value
                    });
                    if (field.children) {
                        flattenFieldsNested(field.children, list, topLevelIndex, parentName + '.' + field.name);
                    }
                });
            };

            const handleParse = async () => {
                if (!fileData || !pyodideReady) {
                    console.log('Parse skipped: fileData=', !!fileData, 'pyodideReady=', pyodideReady);
                    return;
                }
                
                console.log('Starting parse with', fileData.length, 'bytes');
                setIsParsing(true);
                setError(null);
                setParseStatus('>>> Parsing structure...');
                
                try {
                    const fields = await parseWithConstruct(fileData, structDef);
                    console.log('Parse result:', fields);
                    setParsedFields(fields);
                    setHighlightRanges(flattenFields(fields));
                    setParseStatus(`>>> Parse complete: ${fields.length} fields`);
                } catch (err) {
                    console.error('Parse error:', err);
                    setError(err.message);
                    setParsedFields([]);
                    setHighlightRanges([]);
                    setParseStatus('>>> Parse error');
                } finally {
                    setIsParsing(false);
                }
            };

            const handleFieldSelect = (field) => {
                setSelectedField(field);
            };
            
            const handleFieldHover = (field) => {
                setHoveredField(field);
            };
            
            const handleFieldEdit = (field) => {
                setEditingField(field);
            };
            
            const handleExportField = (field, format) => {
                if (!fileData || !field || field.length === 0) return;
                
                // Extract the field's bytes from fileData
                const fieldBytes = fileData.slice(field.offset, field.offset + field.length);
                
                if (format === 'python') {
                    // Generate Python bytes literal
                    const hexBytes = Array.from(fieldBytes)
                        .map(b => '\\x' + b.toString(16).padStart(2, '0'))
                        .join('');
                    const pythonCode = `b"${hexBytes}"`;
                    
                    // Copy to clipboard
                    navigator.clipboard.writeText(pythonCode).then(() => {
                        setParseStatus(`>>> Copied ${field.name} as Python bytes (${field.length} bytes)`);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        // Fallback: show in alert
                        alert(`Python bytes:\n${pythonCode}`);
                    });
                } else if (format === 'file') {
                    // Save as binary file
                    const blob = new Blob([fieldBytes], { type: 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    
                    // Generate safe filename
                    const safeFieldName = field.name.replace(/[^a-zA-Z0-9_-]/g, '_');
                    const baseFileName = fileName.replace(/\.[^.]+$/, '');
                    a.download = `${baseFileName}_${safeFieldName}.bin`;
                    
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    setParseStatus(`>>> Exported ${field.name} to file (${field.length} bytes)`);
                }
            };
            
            // Expose to window for menu callbacks
            useEffect(() => {
                window.onExportField = handleExportField;
                
                // Close all export menus when clicking outside
                const handleClickOutside = (e) => {
                    if (!e.target.closest('.export-menu') && !e.target.closest('.edit-btn')) {
                        document.querySelectorAll('.export-menu').forEach(menu => {
                            menu.style.display = 'none';
                        });
                    }
                };
                
                document.addEventListener('click', handleClickOutside);
                
                return () => {
                    delete window.onExportField;
                    document.removeEventListener('click', handleClickOutside);
                };
            }, [fileData, fileName]);
            
            const handleSaveEdit = (offset, newBytes) => {
                // Create a new array with the edited bytes
                const newData = new Uint8Array(fileData);
                newData.set(newBytes, offset);
                setFileData(newData);
                setHasUnsavedChanges(true);
                setParseStatus(`>>> Field edited at 0x${offset.toString(16)}`);
                
                // Re-parse to update the display
                setTimeout(() => handleParse(), 100);
            };
            
            const handleSaveFile = () => {
                if (!fileData) return;
                
                const blob = new Blob([fileData], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName.replace(/(\.[^.]+)?$/, '_modified$1');
                a.click();
                URL.revokeObjectURL(url);
                
                setHasUnsavedChanges(false);
                setOriginalFileData(new Uint8Array(fileData));
                setParseStatus('>>> File saved');
            };
            
            const handleResetChanges = () => {
                if (originalFileData) {
                    setFileData(new Uint8Array(originalFileData));
                    setHasUnsavedChanges(false);
                    setParseStatus('>>> Changes reset');
                    setTimeout(() => handleParse(), 100);
                }
            };

            const handleExportSVG = () => {
                if (!fileData || parsedFields.length === 0) {
                    alert('Please load a file and parse it first!');
                    return;
                }
                
                // Generate SVG
                const svg = generateSVG(fileData, parsedFields);
                
                // Create blob and download
                const blob = new Blob([svg], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${fileName}_structure.svg`;
                a.click();
                URL.revokeObjectURL(url);
                
                setParseStatus('>>> SVG exported successfully');
            };
            
            const generateSVG = (data, fields) => {
                const bytesPerLine = 16;
                const lineHeight = 20;
                const charWidth = 10;
                const offsetWidth = 100;
                const hexWidth = bytesPerLine * charWidth * 3;
                const margin = 20;
                const headerHeight = 60;
                
                // Color palette (matches CSS)
                const colors = [
                    '#f85149', '#f6ad55', '#57ab5a', '#58a6ff',
                    '#bc80f0', '#ff79c6', '#79c0ff', '#ff9e64'
                ];
                
                // Build the flattened list with top-level tracking
                const flattenedRanges = flattenFields(fields);
                
                // Group ranges by top-level index for legend
                const topLevelGroups = [];
                fields.forEach((field, idx) => {
                    const groupRanges = flattenedRanges.filter(r => r.topLevelIndex === idx);
                    if (groupRanges.length > 0) {
                        topLevelGroups.push({
                            name: field.name,
                            color: colors[idx % colors.length],
                            ranges: groupRanges
                        });
                    }
                });
                
                // Calculate SVG dimensions
                const numLines = Math.ceil(data.length / bytesPerLine);
                const hexViewHeight = numLines * lineHeight + headerHeight;
                
                // Legend height based on number of ranges (not groups)
                const legendHeight = flattenedRanges.length * 25 + 40;
                const totalHeight = hexViewHeight + legendHeight + margin * 3;
                const totalWidth = offsetWidth + hexWidth + margin * 4;
                
                console.log(`SVG Export: ${flattenedRanges.length} ranges in ${topLevelGroups.length} top-level groups`);
                
                let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${totalWidth}" height="${totalHeight}" viewBox="0 0 ${totalWidth} ${totalHeight}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      text { font-family: 'JetBrains Mono', 'Courier New', monospace; font-size: 12px; }
      .offset { fill: #58a6ff; font-weight: 600; }
      .hex { fill: #8b949e; }
      .title { fill: #c9d1d9; font-size: 18px; font-weight: 600; }
      .subtitle { fill: #8b949e; font-size: 12px; }
      .field-name { fill: #c9d1d9; font-weight: 500; }
      .field-value { fill: #8b949e; font-size: 11px; }
    </style>
  </defs>
  
  <!-- Background -->
  <rect width="${totalWidth}" height="${totalHeight}" fill="#0d1117"/>
  
  <!-- Header -->
  <text x="${margin}" y="${margin + 20}" class="title">Binary Structure Visualization</text>
  <text x="${margin}" y="${margin + 38}" class="subtitle">File: ${fileName} (${data.length} bytes)</text>
  
  <!-- Hex Dump -->
  <g transform="translate(${margin}, ${headerHeight})">
`;
                
                // Draw hex dump with highlights using top-level coloring
                for (let i = 0; i < data.length; i += bytesPerLine) {
                    const lineNum = Math.floor(i / bytesPerLine);
                    const y = lineNum * lineHeight + 20;
                    
                    // Offset
                    svg += `    <text x="0" y="${y}" class="offset">${i.toString(16).padStart(8, '0').toUpperCase()}</text>\n`;
                    
                    // Hex bytes
                    for (let j = 0; j < bytesPerLine && i + j < data.length; j++) {
                        const byte = data[i + j];
                        const x = offsetWidth + j * charWidth * 3;
                        const byteIndex = i + j;
                        
                        // Find which range this byte belongs to
                        let rangeColor = null;
                        for (let r = 0; r < flattenedRanges.length; r++) {
                            const range = flattenedRanges[r];
                            if (byteIndex >= range.offset && byteIndex < range.offset + range.length) {
                                rangeColor = colors[range.topLevelIndex % colors.length];
                                break;
                            }
                        }
                        
                        if (rangeColor) {
                            svg += `    <rect x="${x - 2}" y="${y - 14}" width="${charWidth * 2.5}" height="16" fill="${rangeColor}" opacity="0.3" rx="2"/>\n`;
                        }
                        
                        svg += `    <text x="${x}" y="${y}" class="hex">${byte.toString(16).padStart(2, '0').toUpperCase()}</text>\n`;
                    }
                }
                
                svg += `  </g>\n`;
                
                // Legend - grouped by top-level structure
                const legendY = hexViewHeight + margin * 2;
                svg += `  <g transform="translate(${margin}, ${legendY})">
    <text x="0" y="0" class="title" font-size="14">Parsed Fields (Colored by Top-Level Structure)</text>
`;
                
                let currentY = 10;
                topLevelGroups.forEach((group) => {
                    // Group header
                    currentY += 25;
                    svg += `    <rect x="0" y="${currentY - 12}" width="12" height="12" fill="${group.color}" opacity="0.6" rx="2"/>\n`;
                    svg += `    <text x="18" y="${currentY}" class="field-name" font-weight="600">${group.name}</text>\n`;
                    
                    // Group members (indented)
                    group.ranges.forEach((range) => {
                        currentY += 20;
                        const fieldValue = range.value || '';
                        
                        svg += `    <rect x="20" y="${currentY - 10}" width="8" height="8" fill="${group.color}" opacity="0.4" rx="1"/>\n`;
                        svg += `    <text x="35" y="${currentY}" class="field-value" font-size="11">${range.name}</text>\n`;
                        svg += `    <text x="250" y="${currentY}" class="field-value">@0x${range.offset.toString(16).padStart(4, '0')} (${range.length} bytes)</text>\n`;
                        if (fieldValue) {
                            const displayValue = fieldValue.length > 30 ? fieldValue.substring(0, 30) + '...' : fieldValue;
                            svg += `    <text x="450" y="${currentY}" class="field-value">${displayValue}</text>\n`;
                        }
                    });
                });
                
                svg += `  </g>\n`;
                svg += `</svg>`;
                
                return svg;
            };

            const loadSampleFile = () => {
                // Create a sample binary file (ZIP header-like)
                // 4 + 2 + 2 + 4 + 8 + 4 = 24 bytes total
                const sample = new Uint8Array([
                    0x50, 0x4B, 0x03, 0x04,                         // Magic: PK (ZIP signature) - 4 bytes
                    0x14, 0x00,                                     // Version: 20 (0x0014) - 2 bytes  
                    0x00, 0x00,                                     // Flags: 0 - 2 bytes
                    0x08, 0x00, 0x00, 0x00,                         // Size: 8 - 4 bytes
                    0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x57, 0x6F, // Data: "Hello Wo" - 8 bytes
                    0xDE, 0xAD, 0xBE, 0xEF                          // Checksum: 0xEFBEADDE - 4 bytes
                ]);
                
                setFileData(sample);
                setOriginalFileData(new Uint8Array(sample));
                setHasUnsavedChanges(false);
                setFileName('sample.bin');
                setParseStatus(`>>> Sample loaded: ${sample.length} bytes`);
                
                // Set sample structure
                setStructDef(`# Sample ZIP-like structure
format_struct = Struct(
    "magic" / Bytes(4),
    "version" / Int16ul,
    "flags" / Int16ul,
    "size" / Int32ul,
    "data" / Bytes(8),
    "checksum" / Int32ul,
)`);
            };

            if (isLoading) {
                return (
                    <div className="h-screen flex items-center justify-center" style={{ background: '#0d1117' }}>
                        <div className="text-center">
                            <div className="loading-spinner mx-auto mb-4"></div>
                            <h2 className="text-2xl font-semibold" style={{ color: '#58a6ff' }}>Initializing Python Environment</h2>
                            <p className="mt-2 text-base" style={{ color: '#8b949e' }}>Loading Pyodide and Construct library...</p>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-screen flex flex-col" style={{ background: '#0d1117' }}>
                    {editingField && (
                        <EditModal
                            field={editingField}
                            onClose={() => setEditingField(null)}
                            onSave={handleSaveEdit}
                        />
                    )}
                    
                    {/* Header */}
                    <header className="terminal-border p-4" style={{ background: '#161b22' }}>
                        <div className="flex items-center justify-between">
                            <div className="flex items-center space-x-4">
                                <h1 className="text-2xl font-semibold" style={{ color: '#58a6ff' }}>
                                    BinTV
                                </h1>
                                <span className="text-sm opacity-70">Binary Structure Viewer v1.0</span>
                                {hasUnsavedChanges && (
                                    <span className="text-sm px-2 py-1 rounded" style={{ background: '#f6ad55', color: '#000' }}>
                                        • Modified
                                    </span>
                                )}
                            </div>
                            
                            <div className="flex items-center space-x-2">
                                <button
                                    onClick={loadSampleFile}
                                    disabled={isLoading}
                                    className="px-4 py-2 btn-terminal rounded"
                                >
                                    Sample
                                </button>
                                <input
                                    type="file"
                                    ref={fileInputRef}
                                    onChange={handleFileUpload}
                                    accept="*,.pcap,.pcapng"
                                />
                                <button
                                    onClick={() => fileInputRef.current?.click()}
                                    disabled={isLoading}
                                    className="px-4 py-2 btn-terminal rounded"
                                >
                                    Open File
                                </button>
                                {hasUnsavedChanges && (
                                    <>
                                        <button
                                            onClick={handleResetChanges}
                                            className="px-4 py-2 btn-terminal rounded"
                                            title="Reset all changes"
                                        >
                                            Reset
                                        </button>
                                        <button
                                            onClick={handleSaveFile}
                                            className="px-4 py-2 btn-terminal rounded"
                                            title="Save modified file"
                                        >
                                            Save File
                                        </button>
                                    </>
                                )}
                                <button
                                    onClick={handleExportSVG}
                                    disabled={!fileData || parsedFields.length === 0 || isLoading}
                                    className="px-4 py-2 btn-terminal rounded"
                                >
                                    Export SVG
                                </button>
                            </div>
                        </div>
                        
                        {/* PCAP Packet Navigation Bar */}
                        {isPcapFile && pcapPackets.length > 0 && (
                            <div className="mb-4 p-3 rounded" style={{ background: '#161b22', border: '1px solid #30363d' }}>
                                <div className="flex items-center justify-between mb-2">
                                    <div className="flex items-center gap-2">
                                        <span className="text-sm font-semibold" style={{ color: '#58a6ff' }}>📦 PCAP Mode</span>
                                        <span className="text-xs opacity-70">{pcapPackets.length} packets total</span>
                                    </div>
                                </div>
                                <div className="flex items-center justify-between gap-3">
                                    <div className="flex items-center gap-2">
                                        <button
                                            className="px-2 py-1 text-xs rounded btn-terminal"
                                            onClick={() => handlePacketChange(0)}
                                            disabled={currentPacketIndex === 0}
                                        >
                                            ⏮ First
                                        </button>
                                        <button
                                            className="px-2 py-1 text-xs rounded btn-terminal"
                                            onClick={() => handlePacketChange(currentPacketIndex - 1)}
                                            disabled={currentPacketIndex === 0}
                                        >
                                            ◀ Prev
                                        </button>
                                        <span className="text-sm font-mono px-3" style={{ color: '#58a6ff' }}>
                                            Packet {currentPacketIndex} / {pcapPackets.length - 1}
                                        </span>
                                        <button
                                            className="px-2 py-1 text-xs rounded btn-terminal"
                                            onClick={() => handlePacketChange(currentPacketIndex + 1)}
                                            disabled={currentPacketIndex >= pcapPackets.length - 1}
                                        >
                                            Next ▶
                                        </button>
                                        <button
                                            className="px-2 py-1 text-xs rounded btn-terminal"
                                            onClick={() => handlePacketChange(pcapPackets.length - 1)}
                                            disabled={currentPacketIndex >= pcapPackets.length - 1}
                                        >
                                            Last ⏭
                                        </button>
                                        <span className="text-xs opacity-50 px-2">|</span>
                                        <span className="text-xs opacity-70">Go to:</span>
                                        <input
                                            type="number"
                                            className="w-20 px-2 py-1 text-xs rounded"
                                            style={{ background: '#0d1117', border: '1px solid #30363d', color: '#c9d1d9' }}
                                            min="0"
                                            max={pcapPackets.length - 1}
                                            value={currentPacketIndex}
                                            onChange={(e) => handlePacketChange(parseInt(e.target.value) || 0)}
                                        />
                                    </div>
                                    <div className="text-xs opacity-70">
                                        Captured: {pcapPackets[currentPacketIndex].capturedLength}B • 
                                        Original: {pcapPackets[currentPacketIndex].originalLength}B
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        <div className="mt-2 text-sm flex items-center justify-between">
                            <div>
                                {fileName && (
                                    <>
                                        <span style={{ color: '#58a6ff' }}>File:</span>
                                        <span className="ml-2">{fileName}</span>
                                        {fileData && (
                                            <span className="ml-4">
                                                <span style={{ color: '#58a6ff' }}>Size:</span>
                                                <span className="ml-2">{fileData.length} bytes</span>
                                            </span>
                                        )}
                                    </>
                                )}
                            </div>
                            <div className="flex items-center space-x-2">
                                {isParsing && (
                                    <span style={{ color: '#f6ad55' }}>
                                        Parsing...
                                    </span>
                                )}
                                {parseStatus && !isParsing && (
                                    <span className="opacity-70">{parseStatus}</span>
                                )}
                            </div>
                        </div>
                    </header>

                    {/* Main Content */}
                    <div className="flex-1 flex overflow-hidden">
                        {/* Left Panel - Structure Editor */}
                        <div className="w-1/3 flex flex-col panel" style={{ borderRight: '1px solid #30363d' }}>
                            <div className="terminal-title flex items-center justify-between">
                                <span>Construct Structure Definition</span>
                                <div className="flex items-center space-x-2">
                                    {isParsing && <span style={{ color: '#f6ad55', fontSize: '12px' }}>Parsing...</span>}
                                    <button
                                        onClick={handleParse}
                                        disabled={!fileData || !pyodideReady || isParsing}
                                        className="px-3 py-1 btn-terminal rounded"
                                        title="Manual parse (or auto-parses on edit)"
                                    >
                                        Parse
                                    </button>
                                </div>
                            </div>
                            
                            {/* Template Selector */}
                            <div className="p-2" style={{ borderBottom: '1px solid #30363d', background: '#161b22' }}>
                                <div className="flex items-center gap-2 mb-2">
                                    <label className="text-xs" style={{ color: '#8b949e' }}>Load Template:</label>
                                    <div className="flex-1 flex items-center gap-1">
                                        <select
                                            className="flex-1 px-2 py-1 text-xs rounded"
                                            style={{ 
                                                background: '#0d1117', 
                                                border: '1px solid #30363d', 
                                                color: '#c9d1d9',
                                                cursor: 'pointer'
                                            }}
                                            onChange={(e) => {
                                                const templateKey = e.target.value;
                                                console.log('📋 Template selected:', templateKey);
                                                
                                                if (templateKey && CONSTRUCT_LIBRARY[templateKey]) {
                                                    const template = CONSTRUCT_LIBRARY[templateKey];
                                                    console.log('✅ Loading template:', template.name);
                                                    setStructDef(template.code);
                                                    setParseStatus(`>>> Loaded: ${template.name}`);
                                                    setError(null); // Clear any previous errors
                                                    // Reset dropdown to allow re-selection
                                                    e.target.value = "";
                                                } else if (templateKey) {
                                                    console.error('❌ Template not found in library:', templateKey);
                                                    console.log('Available templates:', Object.keys(CONSTRUCT_LIBRARY).sort());
                                                    setParseStatus(`>>> Error: Template "${templateKey}" not found in library`);
                                                    setError(`Template "${templateKey}" exists in dropdown but not in CONSTRUCT_LIBRARY. This is a bug.`);
                                                }
                                            }}
                                            value=""
                                        >
                                            <option value="">-- Select a template --</option>
                                            <optgroup label="📡 Network - Full Stack">
                                                <option value="full_tcp">Full TCP Packet (Eth+IP+TCP)</option>
                                                <option value="full_udp">Full UDP Packet (Eth+IP+UDP)</option>
                                                <option value="full_dns">Full DNS Packet (Eth+IP+UDP+DNS)</option>
                                                <option value="full_dhcp">Full DHCP Packet (Eth+IP+UDP+DHCP)</option>
                                                <option value="full_arp">Full ARP Packet (Eth+ARP)</option>
                                            </optgroup>
                                            <optgroup label="📁 Files - Executables & Archives">
                                                <option value="elf">ELF Header (64-bit)</option>
                                                <option value="pe">PE Header (Windows)</option>
                                                <option value="zip">ZIP Local File Header</option>
                                                <option value="gzip">GZIP Header</option>
                                                <option value="tar">TAR Header (POSIX)</option>
                                                <option value="png">PNG Chunk</option>
                                                <option value="jpeg">JPEG Segment</option>
                                            </optgroup>
                                            <optgroup label="🔧 Firmware - Filesystems">
                                                <option value="squashfs">SquashFS Superblock</option>
                                                <option value="ext4">EXT2/3/4 Superblock</option>
                                                <option value="cpio">CPIO Archive (newc/initramfs)</option>
                                            </optgroup>
                                        </select>
                                    </div>
                                </div>
                                <div className="text-xs px-1" style={{ color: '#6e7681', lineHeight: '1.4' }}>
                                    💡 Templates support dynamic fields using <code>this.field.value</code> pattern (e.g., <code>Bytes(this.length.value)</code>)
                                </div>
                            </div>
                            
                            <div className="flex-1 flex flex-col">
                                <textarea
                                    value={structDef}
                                    onChange={(e) => setStructDef(e.target.value)}
                                    className="flex-1 p-3 font-mono resize-none focus:outline-none focus:ring-1"
                                    style={{ 
                                        background: '#0d1117',
                                        color: '#c9d1d9',
                                        lineHeight: '1.6',
                                        border: 'none',
                                        fontSize: '13px'
                                    }}
                                    placeholder="# Define Construct structure"
                                    spellCheck={false}
                                />
                            </div>
                            
                            {error && (
                                <div className="m-2 error-box rounded">
                                    <div className="font-semibold mb-1" style={{ fontSize: '12px' }}>⚠️ Parse Error:</div>
                                    <pre className="whitespace-pre-wrap overflow-auto max-h-32" style={{ fontSize: '11px' }}>
                                        {error}
                                    </pre>
                                    {error.includes('this.') && (
                                        <div className="mt-2 p-2 rounded" style={{ background: 'rgba(246, 173, 85, 0.1)', border: '1px solid rgba(246, 173, 85, 0.3)' }}>
                                            <div className="text-xs" style={{ color: '#f6ad55' }}>
                                                💡 <strong>Hint:</strong> Dynamic fields need <code>.value</code> when wrapped with RawCopy. 
                                                Use <code>this.field.value</code> instead of <code>this.field</code>.
                                                <br/>
                                                Example: <code>Bytes(this.length.value)</code>
                                            </div>
                                        </div>
                                    )}
                                    {error.includes('not enough bytes') && (
                                        <div className="mt-2 p-2 rounded" style={{ background: 'rgba(246, 173, 85, 0.1)', border: '1px solid rgba(246, 173, 85, 0.3)' }}>
                                            <div className="text-xs" style={{ color: '#f6ad55' }}>
                                                💡 <strong>Hint:</strong> The file is too small for this structure. This template expects more bytes than available.
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}
                            
                            <div className="flex-1 overflow-hidden flex flex-col" style={{ borderTop: '1px solid #30363d' }}>
                                <div className="terminal-title">
                                    Parsed Structure ({parsedFields.length})
                                </div>
                                <div className="flex-1 overflow-y-auto scrollbar-thin p-2">
                                    <StructureTree
                                        fields={parsedFields}
                                        onFieldSelect={handleFieldSelect}
                                        selectedField={selectedField}
                                        onFieldEdit={handleFieldEdit}
                                        onFieldHover={handleFieldHover}
                                    />
                                </div>
                            </div>
                        </div>

                        {/* Right Panel - Hex View */}
                        <div className="flex-1 flex flex-col panel">
                            <div className="terminal-title">
                                Hex Dump
                            </div>
                            
                            <div className="flex-1 overflow-hidden scrollbar-thin" style={{ background: '#0d1117' }}>
                                {fileData ? (
                                    <HexView
                                        data={fileData}
                                        highlightRanges={highlightRanges}
                                        selectedField={selectedField}
                                        hoveredField={hoveredField}
                                    />
                                ) : (
                                    <div className="h-full flex items-center justify-center">
                                        <div className="text-center">
                                            <div className="text-6xl mb-4" style={{ opacity: 0.3 }}>📁</div>
                                            <h3 className="text-xl font-semibold mb-2" style={{ color: '#8b949e' }}>
                                                No file loaded
                                            </h3>
                                            <p style={{ color: '#6e7681', fontSize: '15px' }}>
                                                Click "Open File" or "Sample" to get started
                                            </p>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* Footer */}
                    <footer className="terminal-border p-2 text-center" style={{ background: '#161b22', opacity: 0.7, fontSize: '12px' }}>
                        <span>BinTV • Binary Structure Viewer • Powered by Pyodide &amp; Construct</span>
                    </footer>
                </div>
            );
        };

        // Render app
        ReactDOM.render(<BinTVApp />, document.getElementById('root'));

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'o') {
                e.preventDefault();
                document.querySelector('input[type="file"]')?.click();
            }
        });
    </script>
</body>
</html>